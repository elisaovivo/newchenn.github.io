<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自顶向下：第1章</title>
    <url>/2020/08/11/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%EF%BC%9A%E7%AC%AC1%E7%AB%A0/</url>
    <content><![CDATA[<p>因特网标准（Internet standard）由因特网工程任务组（Internet Engineering Task Force,IETF）研发。IETF的标准文档称为请求评论（Reuqect For Comment,RFC）。它们定义TCP、IP、HTTP和SMTP等协议。其他组织也在定义用于网络组件的标准，例如IEEE 802LAN/MAN标准化委员会（IEEE 802 202）制定了以太网和无线WiFi的标准。</p>
<p>与因特网相连的端系统提供了一个应用程序编程接口(Application Programming Interface,API),该API规定了运行在一个端系统上的软件 请求因特网基础设施向运行在另一个端系统上的特定软件交付数据的方式。</p>
<p>一个协议定义了两个或多个通信实体之间交换的报文格式和次序，以及报文发送和接受一条保温或其他事件采取的动作。</p>
<p>局域网（LAN）技术有很多种，以太网是目前为止最为流行的接入技术。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>自顶向下</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp第七章-链接</title>
    <url>/2020/08/08/csapp%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件加载到内存并执行。链接可以在各个时间段执行。链接是由链接器（linker）的程序自动执行。</p>
<p>链接使得分离编译(separate compilation)成为可能。不用将大型的应用程序组织为一个巨大的源文件，而是分成更小、更好管理的模块，可以独立地修改和编译这些模块。</p>
<h1 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h1>]]></content>
      <categories>
        <category>《深入理解计算机系统》</category>
      </categories>
      <tags>
        <tag>csapp,视频课程</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp第六章-存储器层次结构</title>
    <url>/2020/08/04/csapp%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><h2 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h2><p>随机访问存储器（Random-Access Memory,RAM）分为两类：</p>
<ul>
<li>静态（SRAM）</li>
<li>动态（DRAM）</li>
</ul>
<p>SRAM更快，通常用来作为高速缓存存储器，既可以在CPU芯片上，也可以在片下。</p>
<p>DRAM用来作为主存以及图形系统的帧缓冲区。</p>
<h3 id="静态RAM"><a href="#静态RAM" class="headerlink" title="静态RAM"></a>静态RAM</h3><p>将每个位存储在一个双稳态的（bistable）存储器单元里。每个单元是用一个六晶体管电路来实现的。它可以无限期得保持在两个不同得电压状态之一。其他任何状态都不稳定，从不稳定状态开始，电路会迅速转移到两个稳定状态之一。</p>
<p>图</p>
<p>SRAM只要有点，就会永远保存它得值。即使有干扰（电子燥音）来扰乱电压，当干扰消除时，电路就会恢复正常值。</p>
<h3 id="动态RAM"><a href="#动态RAM" class="headerlink" title="动态RAM"></a>动态RAM</h3><p>DRAM将每一位存储为对一个电容的充电。每个单元由一个电容和一个访问晶体管组成。但DRAM对干扰非常敏感。当被扰乱，就不会恢复了。暴露在光线下会导致电容电压改变。数码照相机和摄像机中的传感器本质上就是DRAM单元的阵列。计算机系统必须周期性读出，然后重写来刷新内存的每一位。</p>
<h3 id="传统的DRAM"><a href="#传统的DRAM" class="headerlink" title="传统的DRAM"></a>传统的DRAM</h3><p>DRAM芯片中的单元被分成d个超单元（supercell），每个超单元由w个DRAM单元组成。 超单元被组织成一个r行c列的长方形阵列，rc = d。</p>
<p>图</p>
<p>8个data引脚，2个addr引脚，携带1位行1位列。</p>
<p>行地址i称为RAS（Row Access Strobe，行访问选通脉冲)请求。列地址j称为CAS（Column Access Strobe,列访问选通脉冲）请求。RAS和CAS请求共享相同的DRAM地址引脚。先发行再发列。</p>
<p>图</p>
<p>设置成二维序列是为了降低芯片上地址引脚的数量。但也增加了访问时间</p>
<h3 id="内存模块"><a href="#内存模块" class="headerlink" title="内存模块"></a>内存模块</h3><p>图</p>
<h3 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h3><p>如果断电，DRAM和SRAM会丢失信息，它们是易失的（volatile）。对应也存在非易失性存储器(nonvolatile memory)。</p>
<p>但ROM中有的类型可以读也可以写，整体被称为只读存储器(Read-Only Memory,ROM)。</p>
<p>ROM是以它们能够被重编程的次数和对它们进行重编所用的机制划分。</p>
<ul>
<li><p>PROM（Programmable ROM）只能编程一次，每个存储器单元用一种熔丝(fuse)，只能高电流熔断一次。</p>
</li>
<li><p>可擦写编程ROM（Erasable Programmable ROM,EPROM）,被擦除和重编程的次数的数量级可以达到1000次。</p>
</li>
<li><p>电子可擦拭PROM（Electrically Erasable PROM,EEPROM）,达到100000次</p>
</li>
<li><p>闪存（flash memory）是一类易失性存储器，基于EEPROM。固态硬盘基于闪存。</p>
<p>存储在ROM设备中的程序通常被称为固件（firmware）。当计算机通电，它会运行存储在ROM中的固件。一些系统在固件中提供了少量基本的输入和输出函数，例如PC的BIOS（基本输入/输出系统）例程。复杂设备，图形卡和磁盘驱动控制器，也依赖固件翻译来自CPU的I/O（输入/输出）请求。</p>
</li>
</ul>
<h3 id="访问主存"><a href="#访问主存" class="headerlink" title="访问主存"></a>访问主存</h3><p>数据流通过称为总线（bus）传递。每次数据传送都是一系列步骤来完成的，这些步骤称为总线事务（bus transaction）。读事务（read transaction）从主存传送到数据到CPU。写事务（write transaction）从CPU传送的主存。</p>
<p>图</p>
<p>I/O桥接器（包括内存控制器）。</p>
<p>系统总线连接CPU和I/O桥接器。内存总线连接I/O桥接器和主存。</p>
<p>I/O桥接器将系统总线的电子信号翻译成内存总线的电子信号。</p>
<p>图</p>
<h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><h3 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h3><p>磁盘由盘片（platter）构成。每个盘面有两面或称为表面(surface)。盘片中央有可以旋转的主轴（spindle），以固定的旋转速率(rotational rate)旋转，通常5400-15000转每分钟（Revolution Per Minute,PRM）</p>
<p>图</p>
<p>每个扇区都包含同样数据位（通常512字节），之间由一些间隙隔开，这些间隙用来标识扇区的格式化位。</p>
<p>b图整个设备称为磁盘驱动器（disk drive），简称磁盘。</p>
<p>柱面（cylinder）来描述所有盘片表明到主轴中心的距离相等的磁道的集合。</p>
<h3 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h3><p>磁盘容量 = 扇区x磁道x表明x盘片x磁盘</p>
<h3 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h3><p> 图</p>
<p>对扇区的访问时间（access time）有三个主要的部分：寻道时间（seek time）、旋转时间（rotational latency）和传送时间（transfer time）</p>
<ul>
<li>寻道时间：依赖于读/写头以前的位置和传动臂在盘面上移动的速度。</li>
<li>旋转时间：1/RPM。平均旋转时间为一半。</li>
<li>传送时间：当目标扇区的第一位位于读/写头下，驱动器就可以开始读或者写。1/RPM*（1/扇区数）</li>
</ul>
<h3 id="逻辑磁盘块"><a href="#逻辑磁盘块" class="headerlink" title="逻辑磁盘块"></a>逻辑磁盘块</h3><p>磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护磁盘块号和实际磁盘扇区之间的映射关系。</p>
<p>当一个命令发送到磁盘控制器。控制器上的固件执行一个快速表查找，讲逻辑块号翻译成（盘面，磁道，扇区）的三元组，这个三元组唯一地标识了对应的物理扇区。</p>
<p>磁盘控制器必须对磁盘进行格式化，然后才能存储数据。格式化包括用标识扇区的信息填写扇区之间的空隙，标识出表面有故障的柱面并且不使用它们，预留一组柱面作为备用，所以格式化容量比最大容量要小。</p>
<h3 id="连接I-O设备"><a href="#连接I-O设备" class="headerlink" title="连接I/O设备"></a>连接I/O设备</h3><p>I/O设备都需要通过I/O总线。例如Intel的外围设备互联(Peripheral Component Interconnect, PCI)总线连接到CPU和主存的。</p>
<p>图</p>
<ul>
<li>通用串行总线(Universal Serial Bus,USB)控制器是一个连接到USB总线的设备的中转机构。</li>
<li>图形卡（或适配器）包含硬件和软件逻辑，代表CPU在显示器上画像素。</li>
<li>主机总线适配器讲一个或多个磁盘连接到I/O总线。最常见的磁盘接口是SCSI和SATA。SCSI通常比SATA驱动器更快但是也更贵。SCSI适配器可以支持多个磁盘驱动器，SATA只能支持一个。</li>
</ul>
<p>其他设备可以通过适配器插入到主板上的扩展槽中，从而连接到I/O总线。</p>
<h3 id="访问磁盘"><a href="#访问磁盘" class="headerlink" title="访问磁盘"></a>访问磁盘</h3><p>CPU使用一种称为内存映射I/O（memory-mapped I/O）的技术来向I/O设备发射命令。地址空间为于I/O设备通信保留。这样的地址称为一个I/O端口（I/O port）。当一个设备连接到总线时，它于一个或多个端口相关联。</p>
<p>图</p>
<p>CPU可能执行三个命令：</p>
<ol>
<li>发送以一个命令字，告诉磁盘发起一个读，同时还发送其他参数，例如当完成时，是否中断CPU。</li>
<li>指明应该读的逻辑块号</li>
<li>指明存储磁盘扇区内容的主存地址。</li>
</ol>
<p>在磁盘控制器收到来自CPU的读命令之后，它将逻辑块号翻译成一个扇区地址，读该扇区内容，然后将这些内容直接传送到主存，不需要CPU干涉。设备可以自己执行读或写总线事务而不需要CPU干涉的过程，称为直接内存访问（Direct Memory Access,DMA）。这种数据传送称为DMA传送（DMA transfer）。</p>
<p>当传送完成，磁盘控制器通过给CPU发送一个中断信号来通知CPU。基本思想是中断会发信号到CPU芯片的一个外部引脚上，导致CPU暂停当前工作，跳转到一个操作系统例程。这个程序会记录下I/O已经完成，然后将控制返回到CPU被中断的地方。</p>
<h2 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h2><p>一种基于闪存的存储技术。</p>
<p>图</p>
<p>SSD封装插到I/O总线上标准硬盘插槽（USB或SATA）中。</p>
<p>SSD由一个或多个闪存芯片和闪存翻译层（flash translation layer）组成，闪存翻译层代替磁盘中的机械驱动器，这是一种硬件设备，扮演与磁盘控制器相同的角色，对逻辑块的请求翻译成对底层物理设备的访问。</p>
<p>读SSD比写快。这是由底层闪存基本属性决定的。</p>
<p>闪存由B个块序列组成，每个块由P页组成。数据以页为单位读写的。只有在一页所属的块整个被擦除后，才能写这一页（指的是这个块每一位都设置为1）。一旦一个块被擦除，块里每一页不需要擦除可以写一次。</p>
<p>重复写，块就会坏，坏了之后就不能用了。</p>
<p>随机写慢，有两个原因：</p>
<ul>
<li>擦除块需要相对较长的时间，1ms级，比访问页所需时间高一个数量级。</li>
<li>若要改写其中一页，需要先将这个块所有数据先复制到一个新块，再写。</li>
</ul>
<h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>一个好的计算机程序常常具有良好的局部性（locality）。倾向于引用邻近于最近引用过的数据项的数据项，或者最近引用过的数据本身。这种倾向性称为局部性原理(principle of locality)。</p>
<p>局部性通常有两种形式：时间局部性（temporal locality）和空间局部性（spatial locality）。</p>
<p>时间局部性：被引用过一次的内存位置很可能在不远的将来被引用</p>
<p>空间局部性：一个内存位置被引用，不远的将来附近位置也会被引用</p>
<p>在硬件层面，局部性原理允许计算机设计者通过高速缓存存储器来保存最近被引用的指令和数据项。在操作系统级，局部性原理允许系统使用主存作为虚拟地址空间最近被引用块的高速缓存。操作系统用主存来缓存磁盘文件系统最近使用的磁盘块。在应用层，Web服务器将最近被请求的文档放在前端磁盘高速缓存中。</p>
<h2 id="对程序数据引用的局部性"><a href="#对程序数据引用的局部性" class="headerlink" title="对程序数据引用的局部性"></a>对程序数据引用的局部性</h2><p>图</p>
<p>对于sum来说有好的时间局部性，没有空间局部性。</p>
<p>对于v来说有好的空间局部性，没有好的时间局部性。</p>
<p>顺序访问一个向量每个元素的函数，具有步长为1的引用模式（stride-1 reference pattern）。步长为1的引用模式为顺序引用模式(sequential reference pattern)。随着步长增长，空间局部性下降。</p>
<p>对于二维数组，行优先访问和列优先访问差别很大。</p>
<h2 id="取指令的局部性"><a href="#取指令的局部性" class="headerlink" title="取指令的局部性"></a>取指令的局部性</h2><p>对于上图，循环体里的指令有良好的空间局部性，循环体有好的时间局部性。</p>
<h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>图片</p>
<h2 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h2><p>高速缓存（cache）是一个小而快速的存储涉黑。使用高速缓存的过程称为缓存（caching）</p>
<p>第k+1层的存储器被分成连续数据对象组块(chunk)，称为块(block)。每个块都有唯一名字或地址，可以固定大小，也可以是可变大小的。第k层被分为较小块的集合，块大小于k+1层一样。第k层的缓存包括第k+1层的一个子集的副本。</p>
<p>一般而言，层级结构中较低层的设备的访问时间较长，因此补偿较长的访问时间，倾向于使用较大的块。</p>
<h3 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h3><p>当程序需要第k+1层数据对象d时，首先看第k层的一个块总找d，若找到，称为命中（cache hit）。</p>
<h3 id="缓存不命中"><a href="#缓存不命中" class="headerlink" title="缓存不命中"></a>缓存不命中</h3><p>没有就称为缓存不命中（cache miss）。不命中时，k层缓存从第k+1层缓存中取出包含d的块，如果k层满了，就会覆盖现存的一个块。</p>
<p>覆盖现有块过程称为替换(replacing)或驱逐（evicting）块。这个被驱逐的块也称为牺牲块（victim block）。这是由缓存的替换策略(replacement policy)来控制的。</p>
<h3 id="缓存不命中的种类"><a href="#缓存不命中的种类" class="headerlink" title="缓存不命中的种类"></a>缓存不命中的种类</h3><p>一个空的缓存称为冷缓存(cold cache)。此类不命中称为强制性不命中（compulsory miss）或冷不命中（cold miss）。冷不命中只是短暂时间，不会在缓存暖身（warmed up）之后的稳定状态中出现。</p>
<p>对于高层缓存，通常硬件实现，若在里面乱放，定位起来代价很高。因此硬件缓存通常使用更严格的放置策略。这个策略将k+1层的某个块限制放置在第k层块的一个小的子集中。这种策略会引起冲突不命中（conflict miss）。</p>
<p>例如，一个嵌套的循环可能反复访问同一个数组的元素，这个块的集合称为这个阶段的工作集（working set）。当工作集的大小超过缓存大小时，缓存会经历容量不命中（capacity miss）。</p>
<h3 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h3><p>在每一层上，某种形式的逻辑必须管理缓存。指某个东西要将缓存划分为块，在不同的层之间传送块，判定是命中还是不命中，并处理它们。管理缓存的逻辑可以是硬件、软件，或是两者的结合。L1，L2和L3层的缓存完全是由内置在缓存中的硬件逻辑来管理的。在一个有虚拟内存的系统中，DRAM主存作为存储在磁盘上的数据块的缓存，是由操作系统软件和CPU上的地址翻译硬件共同管理的。</p>
<h2 id="存储器层次结构概念小结"><a href="#存储器层次结构概念小结" class="headerlink" title="存储器层次结构概念小结"></a>存储器层次结构概念小结</h2><p>图</p>
<h1 id="高速缓存存储器"><a href="#高速缓存存储器" class="headerlink" title="高速缓存存储器"></a>高速缓存存储器</h1><p>图</p>
<p>为缩短CPU和主存之间的差距，系统设计者被迫在CPU寄存器文件和主存之间插入了一个小的SRAM高速缓存存储器，称为L1高速缓存，速度几乎和寄存器一样快，大约4个时钟周期。随着差距还在不断扩大，又相继插入了L2、L3高速缓存。</p>
<h2 id="通用的高速缓存存储器组织结构"><a href="#通用的高速缓存存储器组织结构" class="headerlink" title="通用的高速缓存存储器组织结构"></a>通用的高速缓存存储器组织结构</h2><p>图</p>
<p>一个机器的高速缓存被组织成一个有S = 2的s次个高速缓存组(cache set)的数组。每个组包含E个高速缓存行（cache line）。每个行由一个B = 2的b次个字节的数据块（block）组成的，一个有效位(valid bit)指明这个行是否包含有意义的信息 ，还有t = m-(b+s)个标志位（tag bit）（当前内存地址的子集），它们唯一地标识存储在这个高速缓存行中的块。</p>
<p>高速缓存的结构可以用元组（S,E,B,m）来描述。高速缓存的大小C指的所有快的大小和，标记位和有效位不包括在内。因此，C=SxExB。</p>
<p>当一条加载指令指示CPU从内存地址A中读一个字，它将地址A发送到高速缓存。如果高速缓存保存副本，它将立即将那个字发回给CPU。</p>
<p>高速缓存的结构使得它能通过简单地检查地址位，找到所请求地字，类似于使用极其简单地哈希函数地哈希表。</p>
<p>工作原理:</p>
<ol>
<li>组索引位被解释为一个无符号整数，它高速我们这个字存储在哪个组中。</li>
<li>t个标记位告诉我们这个组中的哪一行包含这个字。</li>
<li>当且仅当设置了有效位并且改行的标记位与地址A的标记位相匹配，才成功。</li>
<li>一旦定位由标号所标识的行，那么b个块偏移位给出了在B个字节的数据块中的字偏移。</li>
</ol>
<h2 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h2><p>每个组只有一行称为（direct-mapped cache）。当不命中，L1高速缓存向主存请求包含w的块的一个副本，CPU必须等待。当从内存到达时，L1高速缓存将这个块寸放在它的一个高速缓存行里，然后再从这个存储块中抽取出字w，返回给CPU。若高速缓存里已经有了，替换掉。</p>
<h2 id="组相联高速缓存（set-associative-cache）"><a href="#组相联高速缓存（set-associative-cache）" class="headerlink" title="组相联高速缓存（set associative cache）"></a>组相联高速缓存（set associative cache）</h2><p>每个组保存有多于一个的高速缓存行。一个1&lt;E&lt;C/B的高速缓存通常称为E路组相联高速缓存。</p>
<p>图</p>
<h2 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h2><p>全相联高速缓存(fully associative cache)</p>
<p>图</p>
<p>高速缓存电路必须并行地搜索许多相匹配地标记，构造一个又大又快地相联高速缓存很困难，而且很昂贵。全相联高速缓存只适合做小地高速缓存，例如虚拟内存系统中的翻译备用缓冲器（TLB），它缓存页表项。</p>
<h2 id="有关写的问题"><a href="#有关写的问题" class="headerlink" title="有关写的问题"></a>有关写的问题</h2><p>对于写命中(write hit)，如何更新低一层中的副本?</p>
<ol>
<li>直写（write-through）：立即写回，但会引起总线流量。</li>
<li>写回（write-back）：当这个更新块要被驱逐时，再写回。由于局部性，能减少总线流量，但增加了复杂性，需要多维护一个修改位（dirty bit）</li>
</ol>
<p>对于写不命中：</p>
<ol>
<li>写分配（write-allocate）：加载低一层中的块到高速缓存中，然后更新这个高速缓存块。</li>
<li>非写分配(not-write-allocate)：直接把字写到低一层中。</li>
</ol>
<p><strong>直写高速缓存通常是非写分配，写回高速缓存通常是写分配的</strong></p>
<p>对于试图编写高速缓存比较友好的程序的程序员来说，建议在心里采用一个使用写回ihe写分配的高速缓存的模型。。</p>
<ol>
<li>用于较长的传送时间，存储器层级结构中较低层的缓存更可能使用写回，而不是直写。例如，虚拟内存系统只使用写回。而且随着逻辑电路密度的提高，写回的复杂性也越来越不成为阻碍了。</li>
<li>它与处理读的方式向对称，因为写回写分配试图利用局部性。</li>
</ol>
<h2 id="一个真实高速缓存层次结构的解剖"><a href="#一个真实高速缓存层次结构的解剖" class="headerlink" title="一个真实高速缓存层次结构的解剖"></a>一个真实高速缓存层次结构的解剖</h2><p>只保存指令的高速缓存称为i-cache。只保存程序数据的高速缓存称为d-cache。既有数据又包括指令的高速缓存称为统一的高速缓存（unified cache）。现代处理器包括独立的i-cache和d-cache。有两个独立的高速缓存能同时读一个指令字和一个数据字。</p>
<p>i-cache通常只读，因此比较简单。</p>
<p>使用不同的高速缓存确保了数据访问不会与指令访问形成冲突不命中，代价就是容量不命中的可能性增加。</p>
<h2 id="高速缓存参数的性能影响"><a href="#高速缓存参数的性能影响" class="headerlink" title="高速缓存参数的性能影响"></a>高速缓存参数的性能影响</h2><ul>
<li>不命中率（miss rate）：不命中数量/引用数量</li>
<li>命中率(hit rate)：1-不命中率</li>
<li>命中时间（hit time）：高速缓存传送一个字到CPU所需的时间，包括组选择，行确认和字选择的时间。L1高速缓存通常在几个时钟周期。</li>
<li>不命中处罚（miss penalty）：例如L1不命中需要从L2得到服务的除法，通常是数10个周期。</li>
</ul>
<h3 id="高速缓存大小的影响"><a href="#高速缓存大小的影响" class="headerlink" title="高速缓存大小的影响"></a>高速缓存大小的影响</h3><p>较大的高速缓存可能提高命中率，另一方面，使大存储器运行得更快总要更难一些。</p>
<h3 id="块大小的影响"><a href="#块大小的影响" class="headerlink" title="块大小的影响"></a>块大小的影响</h3><p>有利有弊。块大，能利用程序中可能可能存在的空间局部性，帮助提高命中率。不过这会影响时间局部性比空间局部性更好的程序的命中率。较大的块对不命中处罚也会产生负面影响，块越大，传送时间就越长。</p>
<h3 id="相联度的影响"><a href="#相联度的影响" class="headerlink" title="相联度的影响"></a>相联度的影响</h3><p>指每个族中高速缓存行数。行数越大，减少冲突不命中所带来抖动的可能性。但会造成更高成本。需要更多标记位，需要额外的LRU状态位和额外的控制逻辑。会增加命中时间，增加不命中处罚，选择牺牲行的复杂性也会增加。</p>
<p>传统上，努力争取时钟频率的高性能系统会为L1高速缓存选择较低的相联度。</p>
<h3 id="写策略的影响"><a href="#写策略的影响" class="headerlink" title="写策略的影响"></a>写策略的影响</h3><p>直写高速缓存比较容易实现，而且能使用独立于高速缓存的写缓冲区(write buffer)，用来更新内存。读不命中开销不大，它们不会触发内存写。另一方面，写回高速缓存引起的传送较少，它允许更多的到内存的带宽用于执行DMA的I/O设备。此外，越往下层走，传送时间增加，减少传送的数量变得更加重要。一般来说，越往下层，越可能使用写回而不是直写。</p>
]]></content>
      <categories>
        <category>《深入理解计算机系统》</category>
      </categories>
      <tags>
        <tag>csapp,视频课程</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp第四章-处理器体系结构</title>
    <url>/2020/07/30/csapp%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行这些指令的处理器。</p>
<a id="more"></a>

<h1 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a>Y86-64指令集体系结构</h1><p>定义一个指令体系结构包括定义各种你状态单元、指令集和它们的编码、一组编程规范和异常事件处理。</p>
<h2 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h2><p>Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为程序员可见状态。这里的程序员指用汇编代码写程序的人，也可以是产生机器级代码的编译器。</p>
<p>图2</p>
<p>15个程序寄存器，rsp作为栈指针，3个一位条件码。</p>
<p>目前只认为虚拟内存系统向Y86-64提供了一个单一的字节数组映像。</p>
<p>Stat来表明程序执行的总体状态。它会指示是正常运行，还是出现了某种异常。</p>
<h2 id="Y86-64指令"><a href="#Y86-64指令" class="headerlink" title="Y86-64指令"></a>Y86-64指令</h2><p>图片</p>
<p>这个指令集就是处理器实现的目标。它只包括8字节整数操作，寻址方式较少，操作也较少。因为只有8字节数据，所以称之为“字（word）”不会有歧义。</p>
<ul>
<li>四种movq，第一第二个字母代表源和目的格式</li>
<li>内存引用方式采用基址和偏移量形式</li>
<li>四个整数操作指令，如图4-2中的OPq。只对寄存器数据进行操作</li>
<li>7个跳转指令jxx</li>
<li>6个条件传送指令</li>
<li>call指令将返回地址入栈，然后跳到目的地址。ret指令从这样的调用中返回。</li>
<li>pushq和popq指令实现入栈和出栈</li>
<li>halt指令停止指令的执行。执行该指令会导致处理器停止，并将状态设置为HLT</li>
</ul>
<h2 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h2><p>每个指令第一个字节表明指令的类型。该字节分为两部分：高4位代码（code）部分，第4位是功能（function）部分。</p>
<p>图片</p>
<p>有些指令只有一个字节长，但有些更长，往往带有寄存器指示符字节（regisiter specifier byte），用于指定一或两个寄存器。对于只需要一个寄存器操作数的指令只要将另一个寄存器指示符设为0xF。</p>
<p>有些指令需要一个附加的4字节常数字(constant word)。这个字能作为立即数数据，偏移量，以及目的地址。</p>
<p>指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。只要从序列的一个字节开始处理，我们仍然可以容易确定指令序列。若不知道起始位置，就不能准确确定怎样将序列分成单独的指令。</p>
<h2 id="Y86-64异常"><a href="#Y86-64异常" class="headerlink" title="Y86-64异常"></a>Y86-64异常</h2><p>图片</p>
<p>在完整设计中，处理器通常会调用一个异常处理程序（exception handler），这个过程被指定用来处理遇到的某种类型的异常。</p>
<h2 id="Y86-64程序"><a href="#Y86-64程序" class="headerlink" title="Y86-64程序"></a>Y86-64程序</h2><p>图</p>
<p>“.”开头的词是汇编器伪指令（assmebler directives），告诉汇编器调整地址，以便在那儿产生代码或插入一些数据。</p>
<p>.pos告诉汇编器从地址0开始产生代码。</p>
<p>第3行初始化指针，程序结尾处声明了标号stack，并且指明地址0x200。</p>
<p>8~13声明4个字的数组，标号arry标签数组的起始，并且在8字节边界处对齐（.align伪指令指定）</p>
<p>16~19给出main过程</p>
<p>图</p>
<p>这里实现了一个指令集模拟器YIS，可以模拟Y86-64机器代码程序的执行</p>
<p>图</p>
<p>模拟输出的第一行总结了执行以及PC和程序状态的结果值。模拟器只打印出在模拟过程中被改变了的寄存器或内存的字。左边是原始值，右边是最终值。</p>
<h2 id="一些Y86-64指令的详情"><a href="#一些Y86-64指令的详情" class="headerlink" title="一些Y86-64指令的详情"></a>一些Y86-64指令的详情</h2><p>当执行pushq %rsp指令时，通常有2种约定：1）压入原始值，2）压入减去8的%rsp值</p>
<p>popq也一样</p>
<h1 id="逻辑设计和硬件控制语言HCL"><a href="#逻辑设计和硬件控制语言HCL" class="headerlink" title="逻辑设计和硬件控制语言HCL"></a>逻辑设计和硬件控制语言HCL</h1><p>硬件设计种，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。大多数现代电路技术都是用信号线上的高压电或低压电表示不同位置。当前技术中，逻辑1用1伏特左右的高压电表示，而逻辑0用0伏特左右的低电压表示。</p>
<p>实现一个数字系统要三个主要的组成部分：</p>
<ol>
<li>计算对位机型操作的函数的组合逻辑</li>
<li>存储位的存储器单元</li>
<li>控制存储器单元更新的时钟信号</li>
</ol>
<p>HCL（Hardware Control Language，硬件控制语言）来描述不同处理器设计的控制逻辑。</p>
<h2 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h2><p>数字电路的基本计算单元。它们产生输出，等于它们输入位值得某个布尔函数。</p>
<p>图</p>
<p>逻辑门总是活动的。一旦一个门输入变化了，很短时间内，输出就会相应地变化。</p>
<h2 id="组合电路和HCL布尔表达式"><a href="#组合电路和HCL布尔表达式" class="headerlink" title="组合电路和HCL布尔表达式"></a>组合电路和HCL布尔表达式</h2><p>多个逻辑门组合成网，构建计算块(computational block)，称为组合电路（combinational circuits）。构建有如下限制：</p>
<ul>
<li>输入必须是:1)一个系统输入，2）某个存储器单元的输出，3）某个逻辑门的输出</li>
<li>两个或多个逻辑门的输出不能连在一起</li>
<li>网必须无环</li>
</ul>
<p>图</p>
<p>HCL来写4-10函数就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool eq &#x3D; (a &amp;&amp; b) || (!a &amp;&amp; !b)</span><br></pre></td></tr></table></figure>

<p>eq仅仅只是给表达式一个名字</p>
<p>图4-11的组合电路，称为多路复用器（multiplexor,称为“MUX”）。多路复用器根据输入控制信号的值，从一组不同的数据信号中选出一个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;s为1输出a，s为0，输出b</span><br><span class="line">bool out &#x3D; (s &amp;&amp; a) || (!s &amp;&amp; b);</span><br></pre></td></tr></table></figure>

<h2 id="字级的组合电路和HCL整数表达式"><a href="#字级的组合电路和HCL整数表达式" class="headerlink" title="字级的组合电路和HCL整数表达式"></a>字级的组合电路和HCL整数表达式</h2><p>通常我们设计对数据字(word)进行操作的电路。有一些位级信号，代表一个整数或一些控制模式。</p>
<p>执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。</p>
<p>图</p>
<p>这个电路用64个图4-10所示的单个位相等电路实现。</p>
<p>在HCL中，将所有字级信号都声明位int,不指定字的大小。HCL允许比较字是否相等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool Eq &#x3D; (A&#x3D;&#x3D;B)</span><br></pre></td></tr></table></figure>

<p>这里参数A和B是int型的。</p>
<p>4-12所示，画字级电路用中等粗度的线表示携带字的每个位的线路，而用虚线来表示布尔信号结果。</p>
<p>图</p>
<p>处理器会用到很多种多路复用器，使得我们能根据某些控制条件，从许多源种选出一个字。在HCL中，多路复用器是情况表达式（case expression）来描述的。情况表达式的通用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	select1	:	expr1;</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">	select2	:	exprn;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这个表达式包含一系列的情况，每种情况i都有一个布尔表达式selecti，和一个整数表达式expr，前者表明什么时候该选择这种情况，后者表明的是得到的值。</p>
<p>同C的switch语句不同，不要求不同的选择表达式之间互斥。从逻辑上讲，这些选择表达式是顺序求值的，且第一个求值为1的情况会被选中。例如4-13中的字级多路复用器用HCL来描述就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">work out &#x3D; [</span><br><span class="line">	s:	A;</span><br><span class="line">	1:	B;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>第二个选择表达式1，如果前面情况都没被选中，就选择这个情况。这是HCL中一种指定默认情况的方法。几乎所有的情况表达式都是以此结尾。</p>
<p>例子：</p>
<p>图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word Out4 &#x3D; [</span><br><span class="line">	!s1 &amp;&amp; !s0	:	A;#00</span><br><span class="line">	!s1			:	B;#01</span><br><span class="line">	!s0			:	C;#10</span><br><span class="line">	1			:	D;#11</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作。算术/逻辑单元(ALU)是一种很重要的组合电路。</p>
<h2 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h2><p>在处理器设计中，很多时候需要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。</p>
<h2 id="存储器与时钟"><a href="#存储器与时钟" class="headerlink" title="存储器与时钟"></a>存储器与时钟</h2><p>组合电路本质上不存储任何信息，只是响应输入，然后输出。为了让计算机系统有状态运行，引入时序电路（sequential circuit），引入按位存储信息的设备。存储设备都是由同一个时钟控制。时钟是周期性信号，决定什么时候要把新值加载到设备中。有两类存储器设备:</p>
<ul>
<li>时钟寄存器（简称寄存器）：存储多个字。时钟信号控制寄存器加载输入值。</li>
<li>随机访问存储器（简称内存）:存储多个字，用地址来选择该读写哪个字。</li>
</ul>
<p>图</p>
<p>寄存器作为电路不同部分中的组合逻辑之间的屏障。每当时钟到达上升沿时，值才会从寄存器的输入传送到输出。</p>
<p>图</p>
<p>向寄存器文件写入字是由时钟信号控制的。每次时钟上升时，输入valw上的值会被写入输入dstw上的寄存器ID指示的程序寄存器。</p>
<p>随机访问存储器与时钟寄存器类似。</p>
<h1 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h1><h2 id="将处理组织成阶段"><a href="#将处理组织成阶段" class="headerlink" title="将处理组织成阶段"></a>将处理组织成阶段</h2><p>通常，将一条指令划分为以下阶段：</p>
<ul>
<li>取指（fetch）: 从内存读取指令字节，地址为PC的值。从指令中抽取指令指示符字节的两个四位部分：icode(指令代码)和ifun(指令功能)。还可能有后面部分。它还会按顺序方式计算当前指令的下一条指令的地址valp。valp等于PC的值加已取指令的长度。</li>
<li>译码（decode）：从寄存器文件读入最多两个操作数。</li>
<li>执行（execute）：ALU要么执行指令指明的操作，计算内存引用的有效地址，要么增加或减少栈指针。得到的值，我们称为valE。在此，可能设置条件码。对条件传送指令来说，这个阶段会检查条件码和传送条件，如果成立，就更新目标寄存器。对跳转指令，该阶段会决定是不是选择分支。</li>
<li>访存（memory）：将输入写入内存，或者从内存读出数据。读出的值为valM。</li>
<li>写回（write back）：最多写两个结果到寄存器文件</li>
<li>更新PC（PC update）：将pc设置为下一条指令的地址。</li>
</ul>
<p>图</p>
<p>图</p>
<p>整数操作指令的处理遵循上面列出的通用模式</p>
<p>图</p>
<p>rrmoq指令通用规则</p>
<p>irmpvq指令具体实例</p>
<p>图</p>
<p>rmmovq指令具体实例</p>
<p>图</p>
<p>mrmovq指令具体实例</p>
<p>图</p>
<p>pushq指令通用规则和实例</p>
<p>图</p>
<p>popq指令通用规则和实例</p>
<p>图</p>
<p>三类控制转移指令的处理</p>
<h2 id="SEQ（sequential-顺序的）硬件结构"><a href="#SEQ（sequential-顺序的）硬件结构" class="headerlink" title="SEQ（sequential,顺序的）硬件结构"></a>SEQ（sequential,顺序的）硬件结构</h2><p>图片</p>
<ul>
<li>取值：从内存读取指令的字节。PC增加器计算valp</li>
<li>译码：A和B是两个读端口，同时读出valA和valB</li>
<li>执行：ALU计算，并对条件码寄存器(CC)三个条件码位。ALU负责计算条件码的新值。这里的cnd是分支信号。</li>
<li>访存：内存读出或写入一个内存字。</li>
<li>写回：寄存器文件有两个端口。端口E用来写ALU计算出来的值，端口M用来写从数据内存中写出的值。</li>
<li>PC更新：PC新值选择自：valp，下一条指令的地址；valc,调用指令或跳转指令指定的目标地址；valM，从内存读取的返回地址。</li>
</ul>
<p>图</p>
<ul>
<li>白色方框表示始终寄存器。PC是SEQ中唯一的时钟寄存器。</li>
<li>浅蓝色方框表示硬件单元。当作黑盒子</li>
<li>控制逻辑块用灰色圆角矩形表示。用来从一组信号源中进行选择，或计算布尔函数。</li>
<li>线路的名字的白色圆圈中说明。</li>
<li>宽度位字长的数据连接用中等粗度的线表示。64</li>
<li>宽度为字节或更窄的数据连接用细线表示。</li>
<li>单个位的连接用虚线表示。</li>
</ul>
<p>SEQ的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序寄存器和条件码寄存器），随机访问存储器(寄存器文件、指令内存和数据内存)。</p>
<p>所有涉及写数据的存储器就需要对时序进行明确控制。为了精准控制，遵循以下原则组织计算。</p>
<p>原则：从不回读。<strong>处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态</strong></p>
<p>例如有些指令会读取条件码，但没有指令必须既设置又读取条件码。通过寄存器和内存的时钟控制，这么做能保证即使所有状态同时更新，也能等价于顺序执行各个阶段，也保证了能在一个周期中完成一条指令。</p>
<p>图</p>
<h2 id="SEQ阶段的实现"><a href="#SEQ阶段的实现" class="headerlink" title="SEQ阶段的实现"></a>SEQ阶段的实现</h2><p>图</p>
<p>这里还包括了多nop和halt指令的处理。nop指令只是简单地经过各个阶段，除了pc加1，不进行任何处理。halt指令使得处理器状态设置为HLT，导致处理器停止运行。</p>
<h3 id="取指阶段"><a href="#取指阶段" class="headerlink" title="取指阶段"></a>取指阶段</h3><p>图</p>
<p>其中标号为“icode”和“ifun”的控制逻辑块计算指令和功能码，或者当指令地址不合法时（imem_error信号指明），使这些值对应于nop指令。根据icode值，可以计算三个一位的信号（用虚线表示）：</p>
<ul>
<li>instr_valid:这个字节对于的是合法指令吗？这个信号用来发现不合法的指令。</li>
<li>need_valc:这个指令包括一个寄存器指示符字节吗</li>
<li>instr_valid和imem_error在访存阶段被用来产生状态码。</li>
</ul>
<p>need_regids的HCL描述只是确定了icode的值是否为一条带有寄存器指示值字节的指令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool need_regids &#x3D; icode in &#123;IRRMOVQ,...&#125;</span><br></pre></td></tr></table></figure>

<p>当计算出的信号need_regids为1时，字节1会被分开装入寄存器指示符rA和rB中。否则，这两个字段会被设为0xF，这表明这条指令没有寄存器。根据need_regids的值，要么根据字节1<del>8来产生valC，要么根据字节2</del>9来产生。</p>
<p>PC增加器硬件单元根据当前pc及两个信号，产生信号valp。值为p+1+r+8i。</p>
<h3 id="译码和写回阶段"><a href="#译码和写回阶段" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h3><p>图</p>
<p>scrA 和 srcB是两个读端口的地址输入</p>
<p>dstE和dstM是两个写端口的地址输入</p>
<p>寄存器文件又4个端口，支持同时进行两个读 和 两个写。</p>
<p>如某个地址端口为特殊标识符0xF（PRONE），表明不需要访问寄存器。</p>
<p>根据指令代码icode以及寄存器指示符rA和rB，可能还根据执行阶段计算出Cnd条件信号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word srcA &#x3D; &#123;</span><br><span class="line">	icode in&#123;IRRMOVQ,...&#125;	: rA;</span><br><span class="line">	icode in&#123;IPOPQ,IRET&#125;	: RRSP;</span><br><span class="line">	1	:	PRONE; # Dont need register</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>图</p>
<p>根据alufun信号的设置，对输入aluA和aluB进行操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word aluA &#x3D; [</span><br><span class="line">	icode in &#123;IRRMOVQ,IOPQ&#125; : valA;</span><br><span class="line">	icode in &#123;IIRMOVQ,..&#125;	: valC;</span><br><span class="line">	icode in &#123;ICALL,IPUSHQ&#125;	: -8;</span><br><span class="line">	icode in &#123;IRET,IPOPQ&#125;	: 8;</span><br><span class="line">	# other instructions dont need ALU;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>ALU在执行阶段，通常它作为加法器。对于OPq指令，我们希望它使用ifun字段中编码的操作。因此:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word alfun &#x3D; [</span><br><span class="line">	icode &#x3D;&#x3D; IOPQ	:	ifun;</span><br><span class="line">	1	:	ALUADD;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>每次运行，ALU都会产生三个与条件码相关的信号——零、符号和溢出。不过只希望在执行OPq指令才设置条件码。。因此产生一个信号set_cc来控制是否更新条件码寄存器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool set_cc &#x3D; icode in &#123;IOPQ&#125;</span><br></pre></td></tr></table></figure>

<p>”cond“硬件单元会根据条件码和功能码来确定是否进行条件分支或条件数据传送。Cnd信号用于设置条件传送的dstE，也用在条件分支的下一个PC逻辑中。</p>
<h3 id="访存阶段"><a href="#访存阶段" class="headerlink" title="访存阶段"></a>访存阶段</h3><p>图</p>
<p>该阶段就是读或写程序数据。</p>
<p>访存阶段最后的功能时根据取值阶段产生的icode、imem_error、instr_valid值以及数据内存产生的dmem_error信号，从指令执行的结果来计算状态码Stat。</p>
<h2 id="更新PC阶段"><a href="#更新PC阶段" class="headerlink" title="更新PC阶段"></a>更新PC阶段</h2><p>图</p>
<p>根据指令类型和是否选择分支，HCL如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word new_pc &#x3D; [</span><br><span class="line">	#Call.	Use instruction constant</span><br><span class="line">	icode &#x3D;&#x3D; ICALL	:	valC;</span><br><span class="line">	#Taken branch. Use instruction constant</span><br><span class="line">	icode &#x3D;&#x3D; IJXX &amp;&amp; Cnd : valC;</span><br><span class="line">	# Completion of RET instruction. Use value from stack</span><br><span class="line">	icode &#x3D;&#x3D; IRET	:	valM;</span><br><span class="line">	# Default : Use incremented PC</span><br><span class="line">	1	:	valP;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="SEQ小结"><a href="#SEQ小结" class="headerlink" title="SEQ小结"></a>SEQ小结</h3><p>SEQ太慢，时钟必须非常慢，以使信号能在一个周期内传播所有的阶段。</p>
<p>这种实现方法不能充分利用硬件单元。每个单元只能在整个时钟周期的一部分时间内才被使用。</p>
<h1 id="流水线的通用原理"><a href="#流水线的通用原理" class="headerlink" title="流水线的通用原理"></a>流水线的通用原理</h1><p>流水线化的一个重要特性就是提高了系统的吞吐量(throughput),也就是单位时间内服务的顾客总数，不过也会略微增加延迟(latency)，也就是服务一个用户所需要的时间。例如，自主餐厅里的一个只需要甜点的顾客，能很快通过一个非流水线化的系统，只在甜点阶段停留。但流水线系统中，如果直接取甜点阶段，会影响其他顾客的愤怒。</p>
<h2 id="计算流水线"><a href="#计算流水线" class="headerlink" title="计算流水线"></a>计算流水线</h2><p>图</p>
<p>对于非流水系统。CD播放器的译码器就是这样一个系统。出入信号是CD表面读出的位，逻辑电路对这些位进行译码，产生音频信号。</p>
<p>图</p>
<p>延迟为320ps，也就是吞吐量的倒数。</p>
<p>图</p>
<p>时钟周期缩为了120ps。代价是增了一些硬件，延迟增加到了360，这主要是因为流水线寄存器的时间开销</p>
<h2 id="流水线操作的详细说明"><a href="#流水线操作的详细说明" class="headerlink" title="流水线操作的详细说明"></a>流水线操作的详细说明</h2><p>图 P285</p>
<p>减缓时钟不会影响流水线的行为。若时钟运行过快，值可能来不及通过组合逻辑，因此时钟上升时，寄存器的输入还不是合法值。</p>
<h2 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h2><p>这是一种理想化的方案，但会出现一些因素，降低流水线的效率</p>
<h3 id="不一致的划分"><a href="#不一致的划分" class="headerlink" title="不一致的划分"></a>不一致的划分</h3><p>若每个阶段的时间不等，那么时钟周期的速率就由最慢阶段的延迟限制的。</p>
<p>通常某些硬件单元如ALU和内存，是不能被划分成多个延迟较小的单元的。</p>
<h3 id="流水线过深，收益反而下降"><a href="#流水线过深，收益反而下降" class="headerlink" title="流水线过深，收益反而下降"></a>流水线过深，收益反而下降</h3><p>若划分过多，流水寄存器也会多，导致无法有很好的优化。</p>
<p>为了提高时钟频率，现代处理器采用很深的（15或更多的阶段）流水线。处理器架构师将指令的执行划分成很多简单的步骤，这样每个阶段延迟就很小。电路设计者小心设计流水线寄存器，，使其延迟尽可能小。芯片设计者也必须小心地设计时钟传播网络，以保证时钟在整个芯片同时改变。</p>
<h2 id="带反馈地流水线系统"><a href="#带反馈地流水线系统" class="headerlink" title="带反馈地流水线系统"></a>带反馈地流水线系统</h2><p>相邻指令可能存在数据相关（data dependency），也有可能存在指令控制流造成地顺序相关（control dependency）。</p>
<h1 id="Y86-64的流水线实现"><a href="#Y86-64的流水线实现" class="headerlink" title="Y86-64的流水线实现"></a>Y86-64的流水线实现</h1><p>改动:将PC的计算挪到取指阶段。然后，在各个阶段之间加上流水线寄存器。</p>
<h2 id="SEQ-重新安排计算阶段"><a href="#SEQ-重新安排计算阶段" class="headerlink" title="SEQ+:重新安排计算阶段"></a>SEQ+:重新安排计算阶段</h2><p>图片2</p>
<h2 id="插入流水线寄存器"><a href="#插入流水线寄存器" class="headerlink" title="插入流水线寄存器"></a>插入流水线寄存器</h2><p>在SEQ+的各个阶段之间插入流水线寄存器，并对信号重新排列，得到PIPE-处理器。</p>
<p>流水线寄存器用黑色方框表示，每个寄存器包含不同的字段，用白色方框表示。</p>
<p>图片</p>
<p>可以看到 PIPE-使用了与顺序设计SEQ几乎一样的硬件单元，但是有流水线寄存器分隔开这些阶段</p>
<h2 id="对信号进行重新排列和标号"><a href="#对信号进行重新排列和标号" class="headerlink" title="对信号进行重新排列和标号"></a>对信号进行重新排列和标号</h2><p>顺序是先SEQ和SEQ+在一个时刻只处理一条指令，因此诸如valC，srcA，valE这样的信号值有唯一的值</p>
<p>在流水线化的设计中，与各个指令相关的这些值由多个版本，会随着指令一起流过系统</p>
<p>采用命名机制，存储在流水线寄存器中的信号可以唯一地被标识</p>
<h2 id="预测下一个PC"><a href="#预测下一个PC" class="headerlink" title="预测下一个PC"></a>预测下一个PC</h2><p>流水线化是为了增大吞吐量，在一个时钟周期内，都有一条指令完成。但要做到这点，必须在取出当前指令之后，马上确定下一条指令位置。但对于条件分支指令，要在执行阶段之后，才能确定是否分支。对于ret，要通过访存阶段，才能确定返回地址。所以要采用分支预测技术。</p>
<p>ret指令的新pc值无法预测，因为返回地址使栈顶的字，其内容是任意的。</p>
<h2 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h2><p>因为数据相关和控制相关，这些相关导致流水线产生计算错误，称为冒险（hazard）。冒险也可以分为数据冒险和控制冒险。</p>
<p>图</p>
<h3 id="用暂停（stalling）来避免数据冒险"><a href="#用暂停（stalling）来避免数据冒险" class="headerlink" title="用暂停（stalling）来避免数据冒险"></a>用暂停（stalling）来避免数据冒险</h3><p>暂停技术就是让一组指令阻塞在它们所处的阶段，而允许其他指令继续通过流水线。比如每次要把一条指令阻塞在译码阶段，就在执行阶段插入一个气泡。气泡就行一个自动产生的nop指令——不改变寄存器、内存、条件码或程序状态。</p>
<p>这种机制实现容易，但性能不好，会严重降低整体的吞吐量。</p>
<h3 id="用转发来避免数据冒险"><a href="#用转发来避免数据冒险" class="headerlink" title="用转发来避免数据冒险"></a>用转发来避免数据冒险</h3><p>PIPE-的设计是在译码阶段从寄存器文件读入源操作数，但是对这些源寄存器的写可能要在写回阶段才能进行。与其暂停值到写完成，不如简单将要写的值传到流水线寄存器E作为源操作数。</p>
<p>这种将结果值直接从一个流水线阶段传到较早阶段的技术称为数据转发（data forwarding，有时称为旁路bypassing）。这需要在基本的硬件结构中增加一些额外的数据连接和控制逻辑。</p>
<h3 id="加载-使用数据冒险"><a href="#加载-使用数据冒险" class="headerlink" title="加载/使用数据冒险"></a>加载/使用数据冒险</h3><p>如果后面一条指令需要上一条数据的时间比上一条指令更改的时间都还要早，也就是转发都晚了的情况。这种情况不能单纯用转发来解决。称为加载/使用冒险（load/use hazard）。</p>
<p>这里可以将暂停和转发结合起来，避免加载/使用冒险。</p>
<h3 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a>避免控制冒险</h3><p>在出现特殊情况时，暂停和往流水线中插入气派的技术可以动态调整流水线的流程。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>处理器有很多事情都会导致异常控制流，此时，程序执行的正常流程被破坏掉。异常可以由程序执行内部产生，也可以由某个外部信号从外部产生。我们的指令集体系结构包含三种不同的内部产生的异常。</p>
<ol>
<li>halt指令</li>
<li>有非法指令和功能码组合的指令</li>
<li>取指或数据读写试图访问一个非法地址</li>
</ol>
<p>我们把导致异常的指令称为异常指令（excepting instruction）。</p>
<p>在一个流水线周期内，如果发生多种异常。我们必须处理器应该向操作系统报告哪个异常。</p>
<p><strong>基本原则：由流水线中最深的指令引起的异常，优先级最高</strong></p>
<p>当首先取出一条指令，开始执行，导致异常，而后来分支预测错误，取消该指令。</p>
<p>为了避免异常指令之后的指令更新任何程序员可见的状态，当处于访存或写回阶段中的指令导致异常时，流水线控制逻辑必须禁止更新条件码寄存器或是数据内存。</p>
<h2 id="PIPE各阶段的实现"><a href="#PIPE各阶段的实现" class="headerlink" title="PIPE各阶段的实现"></a>PIPE各阶段的实现</h2><h3 id="PC选择和取指阶段"><a href="#PC选择和取指阶段" class="headerlink" title="PC选择和取指阶段"></a>PC选择和取指阶段</h3><p>图</p>
<p>这个阶段必须选择程序计数器的当前值，并且预测下一个PC值。</p>
]]></content>
      <categories>
        <category>《深入理解计算机系统》</category>
      </categories>
      <tags>
        <tag>csapp,视频课程</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp第三章-程序的机器级表示</title>
    <url>/2020/07/24/csapp%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<p>机器代码，用字节序列编码低级的操作。编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。</p>
<a id="more"></a>

<h1 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;假设一个C程序，有两个文件p1.c和p2.c。</span><br><span class="line">linux&gt; gcc -0g p p1.c p2.c</span><br></pre></td></tr></table></figure>

<p>编译选项-Og告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。</p>
<p>实际上gcc命令调用了一整套程序，将源代码转化成可执行代码。</p>
<ol>
<li>C预处理器扩展源代码，插入所有用#include指令指定的文件，并扩展所有用#define声明指定的宏。</li>
<li>编译器产生两个源文件的汇编代码，p1.s和p2.s</li>
<li>汇编器将汇编代码转成二进制目标代码文件p1.o和p2.o。（目标代码是机器代码的而一种形式，包括指令的二进制表示，但还没有填入全局值的地址）</li>
<li>链接器将两个目标代码文件和实现库函数得代码合并，并产生最终得可执行代码文件p</li>
</ol>
<h1 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h1><p>对于机器编程来说，其中两种抽象尤为重要。</p>
<ol>
<li>指令集体系结构或指令集架构（Instruction Set Architecture,ISA）定义机器级程序得格式和行为，它定义了处理器状态，指令的格式，以及每条指令对状态的影响。但硬件层面描述复杂，它们并发执行许多指令，但可以采取措施保证整体行为与ISA指定顺序完全一致。</li>
<li>机器级程序使用内存地址是虚拟地址。存储器系统的实际实现是将 多个硬件存储器 和 操作系统软件 给结合起来。</li>
</ol>
<p>一些x86-64的机器代码对于C语言程序员隐藏的处理器状态都是可见的：</p>
<ol>
<li>程序计数器（PC，x86-64中用%rip表示）给除将要执行恶下一条指令在内存中的地址。</li>
<li>整数寄存器文件包括16个命名的地址，分别存储64位的值，可以存放地或整数数据。</li>
<li>条件码寄存器保存最近执行的算术或逻辑命令的状态信息。用来实现控制或条件流中的条件变化。</li>
<li>一组向量寄存器用来存放一个或多个整数或浮点数值。</li>
</ol>
<p>从机器代码角度看内存，内存只是一个很大的、按字节寻址的数组。</p>
<p>程序在内存中包括：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。</p>
<h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>由于是从16位体系结构拓展成32位的，Intel用术语“字（word）”表示16位数据类型。32位“双子（double words）”。64位数为“四字（quad words）”。</p>
<p><img src="https://i.loli.net/2020/07/30/Lsay2w8dNQqUlbI.png" alt="1334023-20190807170430649-1604938390.png"></p>
<p>大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有四个变种:movb(传送字节)、movw（传送字）、movl（传送双字）和movq（传送四字。）</p>
<h1 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h1><p>x86-84的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器。用来存储整数数据和指针。</p>
<p><img src="https://i.loli.net/2020/07/30/zX4ckLaEUbd9eVf.png" alt="1334023-20190809115302856-2146181911.png"></p>
<p>指令可以对这16个寄存器得低位字节中存放得不同大小数据进行操作。</p>
<p>在常见得程序里不同得寄存器扮演不同角色。其中最特别得栈指针%rsp。用来指明运行时栈结束位置。</p>
<h2 id="操作器指令符"><a href="#操作器指令符" class="headerlink" title="操作器指令符"></a>操作器指令符</h2><p>大多数指令有一个或多个操作数（operand）。操作数分为三种类型。</p>
<ol>
<li>立即数(immediate)：用来表示常数值。</li>
<li>寄存器（register）</li>
<li>内存引用</li>
</ol>
<p>寻找方式也有多种。Imm（rb,ri,s）表示最常用的形式:<strong>一个立即数偏移Imm，一个基址寄存器rb，一个变址寄存器ri和一个比例因子s,s必须是1，2，4，或者8.</strong></p>
<p><img src="https://i.loli.net/2020/07/30/Wo5YMb7fDKLBywm.png" alt="1334023-20190809144635365-1131133860.png"></p>
<h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><p><img src="https://i.loli.net/2020/07/30/1KO2aN9n3roqFt6.png" alt="1334023-20190809153000104-990216913.png"></p>
<p>原操作数是一个立即数，存储在寄存器或内存中。目的操作数只当一个位置。</p>
<p><strong>x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。需要第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。</strong></p>
<p><strong>大部分mov指令仅仅更新目的范围内的操作数，movl指令以寄存器为目的时，它会把该寄存器的高位4字节设置为0</strong></p>
<p><img src="https://i.loli.net/2020/07/30/a3PGm4geExc8kbo.png" alt="1334023-20190809154255266-1023894161.png"></p>
<p>常规的movq指令只能以表示为32位补码数字的立即数作为原操作数，然后把这个值符号扩展得到64位，放到目的位置。<strong>movabsq指令能以任意64位，并且只能放到寄存器作为目的。</strong></p>
<p><img src="https://i.loli.net/2020/07/30/UnziyT9DhxmE4oH.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/30/x8MdiERTnCe72XZ.png" alt="img"></p>
<p>第一类零扩展数据传送，第二类符号扩展数据传送。每条指令名字的最后两个字符都是大小指示符：第一个指定源的大小，第二个指明目的大小。</p>
<h2 id="数据传送实例"><a href="#数据传送实例" class="headerlink" title="数据传送实例"></a>数据传送实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long exchange(long *xp,long y)</span><br><span class="line">&#123;</span><br><span class="line">	long x &#x3D; *xp;</span><br><span class="line">	*xp &#x3D; y;</span><br><span class="line">	return x;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编</span><br><span class="line">&#x2F;&#x2F;xp in %rdi,y in %rsi,x in %rax</span><br><span class="line">exchange:</span><br><span class="line">	movq	(%rdi),%rax</span><br><span class="line">	movq	%rsi,(%rdi)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。像x这样的局部变量通常保存在寄存器中，而不是内存。访问寄存器比访问内存快许多。</p>
<h2 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h2><p>最后两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据。</p>
<p><img src="https://i.loli.net/2020/07/30/NDsZzGUVE1hTap4.png" alt="img"></p>
<p>在x86-64中，程序栈存放在内存中某个区域。栈向下增长，栈顶元素的地址是栈中元素地址中最低的。栈指针%rsp保存着栈顶元素的地址。</p>
<p>将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此，pushq %rbp 的行为等价于:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub $8,%rsp	&#x2F;&#x2F;Decrement stack pointer</span><br><span class="line">movq %rbp,(%rsp)	&#x2F;&#x2F;store %rbp on stack</span><br></pre></td></tr></table></figure>

<p>区别在于pushq指令编码为1字节，上面两条一共8字节。</p>
<p><img src="https://i.loli.net/2020/07/30/D2Zx5RJn1ITtAB3.png" alt="img"></p>
<p>popq    %rax等价于下面两条指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movq (%rsp),%rax	&#x2F;&#x2F;Read %rax from stack</span><br><span class="line">addq $8,%rsp	&#x2F;&#x2F;Incremetn stack pointer</span><br></pre></td></tr></table></figure>

<p>因为栈其实就是内存中的一片空间，其实可以用程序访问栈内的任意位置。假设栈顶元素是四字，指令movq 8(%rsp),%rdx会将第二个四字从栈中复制到寄存器%rdx。</p>
<h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><p><img src="https://i.loli.net/2020/07/30/t7lTmPAco8S4YEg.jpg" alt="img"></p>
<p>大部分操作都分成了指令类，指令类都带不同大小操作数变种<strong>只有leaq没有</strong>。例如，ADD由四条加法指令组成：addb、addw、addl和addq。</p>
<p>这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。</p>
<h2 id="加载有效地址（load-effective-address）"><a href="#加载有效地址（load-effective-address）" class="headerlink" title="加载有效地址（load effective address）"></a>加载有效地址（load effective address）</h2><p>lea指令实际上是movq指令的变型。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令将有效地址写入到目的操作数。</p>
<p>这条指令可以为后面的内容引用产生指针。它还可以简洁得描述普通得算术操作。<strong>目的操作数必须是一个寄存器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long scale(long x,long y,long z)&#123;</span><br><span class="line">	long t &#x3D; x + 4*y + 12*z;</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编</span><br><span class="line">&#x2F;&#x2F;x in %rdi,y in %rsi,z in %rdx</span><br><span class="line">scale:</span><br><span class="line">	leaq	(%rdi,%rsi,4), %rax	&#x2F;&#x2F;x + 4*y</span><br><span class="line">	leaq	(%rdx,%rdx,2), %rdx	&#x2F;&#x2F;z+2*z &#x3D; 3*z</span><br><span class="line">	leaq	(%rax,%rdx,4), %rax &#x2F;&#x2F;(x+4*y)+4*(3*z) &#x3D; x + 4*y + 12*z</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>leaq指令能执行加法和有限形式得乘法，在编译如上简单算术表达式时，是很有用处的。</p>
<h2 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h2><p>第二组操作是一元操作，操作数可以是寄存器，也可以是内存位置。</p>
<p>第三组是二元操作，第一个操作数可以是立即数、寄存器或是内存地址。第二个操作数可以是寄存器或者是内存位置。<strong>当第二个操作数为内存地址时，处理器必须从内存中读出值，执行操作，再把结果写回内存。</strong></p>
<h2 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h2><p>最后一组为移位操作，先给出位移量，第二项给出要位移的数。可以逻辑移动，也可以算术。位移量可以是一个立即数，或者放在单字节寄存器%cl中。（这些指令只允许特定的寄存器作为操作数）。位移操作对w位长的数据值进行操作，位移量是由%cl寄存器的低m位决定，2的m次 = w。</p>
<p>例如当寄存器%cl的十六进制值为0xFF时，指令salb会移7位，salw会移15位，sall移31位，salq移63位。移位操作的目的操作数可以是一个寄存器值或是一个内存位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long arith(long x,long y,long z)</span><br><span class="line">&#123;</span><br><span class="line">	long t1 &#x3D; x^y;</span><br><span class="line">	long t2 &#x3D; z*48;</span><br><span class="line">	long t3 &#x3D; t1&amp;0x0F0F0F0F;</span><br><span class="line">	long t4 &#x3D; t2-t3;</span><br><span class="line">	return t4;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编</span><br><span class="line">&#x2F;&#x2F;x in %rdi,y in %rsi,z in %rdx</span><br><span class="line">arith:</span><br><span class="line">	xorq	%rsi,%rdi &#x2F;&#x2F;t1 &#x3D; x^y</span><br><span class="line">	leaq	(%rdx,%rdx,2),%rax	&#x2F;&#x2F;3*z</span><br><span class="line">	salq	$4,%rax		&#x2F;&#x2F;t2 &#x3D; 16*(3*z) &#x3D; 48*z</span><br><span class="line">	andl	$252645135,%edi		&#x2F;&#x2F;t3 &#x3D; t1&amp;0x0F0F0F0F</span><br><span class="line">	subq	%rdi,%rax		&#x2F;&#x2F;Return t2-t3</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<h2 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h2><p>对于两个64位有符号或无符号整数相乘得到乘积需要128位来表示。Intel把16字节的数称为八字(oct word)。</p>
<p><img src="https://i.loli.net/2020/07/30/rphUSTxIvDWtNJ4.jpg" alt="img"></p>
<p>两种乘法都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器%rdx（高64位）和%rax（低64位）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">typedef unsigned __int128 unit128_t</span><br><span class="line">void store_uprod(uint128_t *dest,unit64_t x,unit64_t y)&#123;</span><br><span class="line">	*dest &#x3D; x*(unit128_t)y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inttypes.h对标准C拓展的一部分，但这个标准并没有实现128位的值。只好依赖GCC提供的128位整数支持，用名字__int128声明。这段代码指明得到的乘积应该存放在指针dest指向的16字节处。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dest in %rdi,x in %rsi,y in %rdx</span><br><span class="line">store_uprod:</span><br><span class="line">	movq	%rsi,%rax	&#x2F;&#x2F;Copy x to mutiplicand</span><br><span class="line">	mulq	%rdx	&#x2F;&#x2F;Multiply by y</span><br><span class="line">	movq	%rax,(%rdi)	&#x2F;&#x2F;store lower 8 bytes at dest</span><br><span class="line">	movq	%rdx,8(%rdi)	&#x2F;&#x2F;store upper 8 bytes at dest+8</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>这段代码针对小端机器，所以高位字节存储在大地址。</p>
<p>单操作数除法指令。有符号除法指令idivl将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存在%rax中，余数存储在%rdx中。</p>
<p>对于64位除法来说，这个值在%rax中，%rdx的位设置为全0（无符号）或%rax的符号位（有符号）。后面这个操作由指令cqto来完成。这条指令隐含读出%rax符号位，并将它复制到%rdx所在的位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void remdiv(long x,long y,long *qp,long *rp)&#123;</span><br><span class="line">	long q &#x3D; x&#x2F;y;</span><br><span class="line">	long r &#x3D; x%y;</span><br><span class="line">	*qp &#x3D; q;</span><br><span class="line">	*rp &#x3D; r;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; x in %rdi,y in %rsi,qp in %rdx,rp in %rcx</span><br><span class="line">rediv:</span><br><span class="line">	movq	%rdx，%r8	&#x2F;&#x2F;Copy qp</span><br><span class="line">	movq	%rdi,%rax	&#x2F;&#x2F;Move x to lower 8 bytes of dividend</span><br><span class="line">	cqto	&#x2F;&#x2F;Sign-extend to upper 8 bytes of dividend</span><br><span class="line">	idiq	%rsi	&#x2F;&#x2F;Divide by y</span><br><span class="line">	movq	%rax,(%r8)	&#x2F;&#x2F;Store quotient at qp</span><br><span class="line">	movq	%rdx,(%rcx)	&#x2F;&#x2F;Store remainder at rp</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>首先把qp保存到另一个寄存器中（第2行），因为除法操作要使用参数寄存器%rdx。3~4准备被除数，复制并符号扩展x。</p>
<p>无符号除法使用divq指令。通常，寄存器%rdx会事先设置为0。</p>
<h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><p>C语言中的某些机构，比如条件语句、循环语句和分支语句，要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：<strong>测试数据值，然后根据测试的结果来改变控制流或者数据流。</strong></p>
<p>用jump指令可以改变一组机器代码指令的执行顺序，通过某个测试结果调转到程序的其他部分。</p>
<h2 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h2><p>除整数寄存器，CPU还维护一组单个位的条件码(condition code)寄存器。它们描述最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。常用有:</p>
<ul>
<li>CF:进位标志。最近的操作最高位产生了进位。可用来无符号操作的溢出。</li>
<li>ZF:零标志。最近操作结果为0.</li>
<li>SF:符号标志。最近的操作得到结果为负。</li>
<li>OF：溢出标志。最近操作导致一个补码溢出–正溢出或负溢出。</li>
</ul>
<p>leaq指令不改变任何条件码，因为它用来进行地址计算。除此之外3-10中所有指令都会设置条件码。</p>
<p>除了3-10中的指令会设置条件码，还有两类指令(有8，16，32和64位形式)，它们只设置条件码不改变任何其他寄存器。</p>
<p><img src="https://i.loli.net/2020/07/30/Oe6sWRwL82alYtp.jpg" alt="img"></p>
<p>CMP根据两数之差设置条件码。CMP与SUB指令的行为一样。列出操作数的顺序是相反的。</p>
<p>TEST指令的行为与AND指令一样，除了它们只设置条件码而不改变目的寄存器值，典型用法是，两个操作数一样（检查是 正、负还是0），或其中一个操作数是掩码，用来指示哪些位应该被测试。</p>
<h2 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h2><p>条件码通常不会直接读取，常用使用方法有三种:</p>
<ol>
<li>可以根据条件码的某种组合，将一个字节设置为0或1。</li>
<li>可以条件跳转到程序的某个其他的部分</li>
<li>可以有条件地传送数据</li>
</ol>
<p>对于第一种情况，有一整类指令称为SET指令。这些后缀表示不同条件而不是操作数大小，例如，指令setl和setb表示“小于时设置（set less）”和“低于时设置（set below）”，而不是“设置长字“set long word”和“set byte”。</p>
<p>一条set指令的目的操作数是低位单字节寄存器运算之一，或是一个字节的内存位置，指令会将这个字节设置成0或者1。</p>
<p><img src="https://i.loli.net/2020/07/30/WZJgbXfSmYEjxsT.png" alt="img"></p>
<p>一个计算C语言表达式a&lt;b的经典指令序列如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; int comp(data_t a,data_t b)</span><br><span class="line">&#x2F;&#x2F; a in %rdi,b in %rsi</span><br><span class="line">comp:</span><br><span class="line">	cmpq	%rsi,%rdi	&#x2F;&#x2F;Compare a:b</span><br><span class="line">	setl	%al			&#x2F;&#x2F;Set low-order byte of %eax to 0 or 1</span><br><span class="line">    movzbl	%al,%eax	&#x2F;&#x2F;Clear rest of %eax(and rest  of %rax)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>cmp指令参数虽然是先b后a，但其实是a:b。</p>
<p>movzbl指令不仅会把%eax的高3个字节清零，还会把整个寄存器%rax的高4个字节清零。</p>
<p>某些底层的机器指令可能有多个名字，称之为“同义词（synonym）”</p>
<p>各个SET命令的描述都适用的情况是：执行比较指令，根据计算t=a-b设置条件码。</p>
<p>不像C语言，机器代码不会将每个程序值和一个数据类型联系起来。<strong>大多数情况下，机器代码对有符号和无符号两种情况都使用一样的指令，这是因为许多算术运算对无符号和补码算术都有一样的位级行为。但也有些情况需要不同指令来处理有符号和无符号操作，例如，使用不同版本的右移、除法和乘法指令，以及不同条件码组合。</strong></p>
<h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><p>jump指令会导致执行切换到程序中一个全新的位置。跳转目的由标号（label）指明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	movq $0,%rax	&#x2F;&#x2F; set %rax to 0</span><br><span class="line">	jmp .L1			&#x2F;&#x2F; Goto .L1</span><br><span class="line">	movq (%rax),%rdx	&#x2F;&#x2F; Null pointer dereference(skipped)</span><br><span class="line">.L1:</span><br><span class="line">	popq %rdx	&#x2F;&#x2F;jump target</span><br></pre></td></tr></table></figure>

<p>在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令地址）编码为跳转指令的一部分。</p>
<p><img src="https://i.loli.net/2020/07/30/uIERk64tpmAQ7cB.jpg" alt="img"></p>
<p>jmp指令是无条件跳转。可以是直接跳转(跳转目标作为指令一部分编码)，也可以是间接跳转(从寄存器或内存位置读出的)。直接跳转给出一个标号为目标，间接跳转写法是“*”后跟操作数指示符。</p>
<p>其他跳转指令都是有条件的，或者跳转或者执行下一条指令。<strong>条件跳转只能是直接跳转</strong></p>
<h2 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h2><p>跳转指令有几种不同的编码，但最常用的都是PC相对的（PC-relative）就是将目标指令地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这个偏移量可以编码为1，2或4字节。第二种编码方式是给出“绝对”地址，用4个字节直接指定目标。汇编器与链接器会选择适当的跳转目的编码。</p>
<h2 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h2><p>C语言中的if-else语句的通用形式模板如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(text-expr)</span><br><span class="line">	then-statement</span><br><span class="line">else</span><br><span class="line">	else-statement</span><br></pre></td></tr></table></figure>

<p>这里test-expr是一个整数表达式，取值为0或非0,两个分支语句只会执行一个。</p>
<p>对于这种通用形式，汇编实现通常使用下面这种形式。用C语言来描述控制流：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	t &#x3D; text-expr</span><br><span class="line">	if(!t)</span><br><span class="line">		goto false;</span><br><span class="line">	then-statement</span><br><span class="line">	goto done;</span><br><span class="line">false:</span><br><span class="line">	else-statement;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p>汇编器为then-statement和else-statement产生各自的代码块。它会插入条件和无条件分支，以保证执行正确的代码块。</p>
<h2 id="用条件传送来实现条件分支"><a href="#用条件传送来实现条件分支" class="headerlink" title="用条件传送来实现条件分支"></a>用条件传送来实现条件分支</h2><p>使用<strong>控制的条件转移</strong>这种机制简单而通用，但在现在处理器上，有点低效。一种替代的策略是使用<strong>数据的条件转移。</strong>这种方法计算一个条件操作的两种结果，然后再根据条件是否满足选取一个。只在受限制的情况中，这种策略可行，如果可行就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性。</p>
<p>为何条件数据传送的方式比较快?</p>
<p>处理器使用流水线（pipelining）来获得高性能，而这需要提前确定要执行的指令序列，当机器遇到条件跳转（也称为“分支”）时，只有当分支条件求值完成时，才能决定走哪个分支。处理器采用分支预测逻辑来推测每条跳转指令是否执行。只要预测可靠(现代处理器设计试图达到90%的成功率)，指令流水线就可以充满指令。若预测失败，处理器就要丢掉它为该跳转指令后的所有工作，然后再从正确位置处起始的指令去填充流水线。一次预测失误，会浪费15~30个时钟周期。</p>
<p><img src="https://i.loli.net/2020/07/30/f8Zmr3eqWSko7Xx.png" alt="img"></p>
<p>每条指令有两个操作数:源寄存器或者内存地址S，和目的寄存器R。源和目的值可以是16位、32位或64位长。<strong>不支持单字节的条件传送。</strong></p>
<p>汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度，所以对所有的操作数长度，到可以使用同一个的指令名字。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v &#x3D; test-expr ? the-expr:else-expr;</span><br></pre></td></tr></table></figure>

<p>条件控制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	if(!text-pr)</span><br><span class="line">		goto false;</span><br><span class="line">	v &#x3D; then-expr;</span><br><span class="line">	goto done;</span><br><span class="line">false:</span><br><span class="line">	v &#x3D; else-expr;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p>条件传送：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v &#x3D; then-expr;</span><br><span class="line">ve &#x3D; else-expr;</span><br><span class="line">t &#x3D; test-expr;</span><br><span class="line">if(!t) v &#x3D; ve;</span><br></pre></td></tr></table></figure>

<p>不是所有条件表达式都可以用条件出传送来编译，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long cread(long *xp)&#123;</span><br><span class="line">	return (xp?*xp:0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xp in %rdi</span><br><span class="line">cread:</span><br><span class="line">	movq	(%rdi),%rax;	&#x2F;&#x2F;v &#x3D; *xp</span><br><span class="line">	test	%rdi,%rdi		&#x2F;&#x2F;Test &#x3D; x</span><br><span class="line">	movl	$0,%edx			&#x2F;&#x2F;Set ve &#x3D; 0</span><br><span class="line">	cmove	%rdx,%rax		&#x2F;&#x2F;if(x&#x3D;&#x3D;0) v &#x3D; ve</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>不过，这个实现是非法的，因为计时当测试为假，movq指令对xp的间接引用还是发生了，导致了间接引用空指针的错误。</p>
<p>所以如果两个表达式中的任意一个可能产生错误条件或者副作用，就会导致非法行为。</p>
<p>如果then-expr或者else-expr部分很麻烦，用条件传送传送也不适合，所以各有各的优点。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>C语言提供多种循环结构，即do-while、while和for。汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。</p>
<h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h3><p>通用形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do</span><br><span class="line">	body-statement</span><br><span class="line">	while(test-expr)</span><br></pre></td></tr></table></figure>

<p>可以看见，body-statement至少执行一次</p>
<p>翻译如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">	t &#x3D; test-expr</span><br><span class="line">	if(t)</span><br><span class="line">		goto loop</span><br></pre></td></tr></table></figure>

<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>通用形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(text-expr)</span><br><span class="line">	body-statement</span><br></pre></td></tr></table></figure>

<p>这个有两种翻译方法</p>
<h4 id="跳转到中间（jump-to-middle）"><a href="#跳转到中间（jump-to-middle）" class="headerlink" title="跳转到中间（jump to middle）"></a>跳转到中间（jump to middle）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	goto test;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">test:</span><br><span class="line">	t &#x3D; test-expr;</span><br><span class="line">	if(t)</span><br><span class="line">		goto loop;</span><br></pre></td></tr></table></figure>

<h4 id="guarded-do"><a href="#guarded-do" class="headerlink" title="guarded-do"></a>guarded-do</h4><p>当采用较高优化等级编译时，会采用这种策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; test-expr;</span><br><span class="line">if(!t)</span><br><span class="line">	goto done;</span><br><span class="line">do</span><br><span class="line">	body-statement</span><br><span class="line">	while(test-expr)</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p>把它翻译成goto代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; text-expr;</span><br><span class="line">if(!t)</span><br><span class="line">	goto done;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">	t &#x3D; text-expr;</span><br><span class="line">	if(t)</span><br><span class="line">		goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>通用形式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(init-expr; test-expr;update-expr)</span><br><span class="line">	body-statement</span><br></pre></td></tr></table></figure>

<p>这个行为与while代码行为一样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">while(text-expr)&#123;</span><br><span class="line">	body-statement;</span><br><span class="line">	update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GCC也对应两种翻译</p>
<h4 id="跳转到中间策略"><a href="#跳转到中间策略" class="headerlink" title="跳转到中间策略"></a>跳转到中间策略</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">goto test;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">	update-expr;</span><br><span class="line">test:</span><br><span class="line">	t&#x3D; text-expr;</span><br><span class="line">	if(t)</span><br><span class="line">		goto loop;</span><br></pre></td></tr></table></figure>

<h4 id="guarded-do-1"><a href="#guarded-do-1" class="headerlink" title="guarded-do"></a>guarded-do</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">	t &#x3D; test-expr;</span><br><span class="line">	if(!t)</span><br><span class="line">		goto done;</span><br><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">	update-expr;</span><br><span class="line">	t &#x3D; text-expr;</span><br><span class="line">	if(t)</span><br><span class="line">		goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><p>switch(开关)语句可以根据一个整数索引值进行多重分支（mutiway branching）。这种语句通过使用跳转表（jump table）这种数据结构使得实现更加高效。跳转表是一个数组，表项i是一个代码段的地址，这个地址段实现当开关索引值等于i时程序应该采取的动作。</p>
<p>与很长的if-else语句相比，使用跳转表的优先是执行开关语句的时间与开关情况的数量无关。GCC根据开关情况的数量和开关情况值得稀疏程度来翻译开关语句。当开关情况比较多（例如4个以上），并且值得范围跨度很小时，就会使用跳转表。</p>
<p><img src="https://i.loli.net/2020/07/30/XgYcP7zrpLN2mo6.png" alt="img"></p>
<p>b代码采用了GCC提供的对跳转表的支持，这是对C语言的拓展，GCC的作者创造了新的运算符&amp;&amp;,这个运算符创建了一个指向代码位置的指针。</p>
<p><img src="https://i.loli.net/2020/07/30/7i3tH1SCWIM9R52.png" alt="img"></p>
<p>汇编器首先将n减去100，把取值范围移到0和6之间，创建新变量index，<strong>补码表示的负数会被映射成符号位表示的大正数，利用这事实，将index看作无符号数，从而进一步简化分支的可能性。通过测试index是否大于6来判定index是否在0~6范围之外。</strong></p>
<p>执行switch语句的关键步骤是通过跳转表来访问代码位置。C代码16行，一条goto语句引用跳转表jt。在汇编代码中，类似操作在第5行，jmp指令操作数有前缀”*”,表明是间接跳转，操作数指定一个内存位置，索引由%rsi给出，这个寄存器保存index的值。</p>
<p>在汇编代码中，跳转表用以下申明表示:</p>
<p><img src="https://i.loli.net/2020/07/30/h8IOwiZR3DeplNy.jpg" alt="img"></p>
<p>这些申明表明，在叫做“.rodata“（只读数据，Read-Only Data）的目标代码文件的段中，应该有一组7个”四“字（8个字节），每个字的的值都是与指定的汇编代码标号（例如.L3）相关联的指令地址。标号.L4标记出这个分配地址的起始，与这个标号相对应的地址会作为间接跳转（第5行）的基地址。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>过程是软件一种重要抽象。它提供一种封装代码的方式。不同编程语言中，过程的形式多样：函数（function）、方法(method)、子例程（subroutine）、处理函数（handler）等等，但它们具备共性。</p>
<p>假设过程P调用过程Q，Q执行后返回P。这些动作包括一个或多个机制。</p>
<ul>
<li>传递控制。进入进程Q时，PC必须被设置为Q的代码的起始位置，返回时，PC为P调用Q后那条指令的地址。</li>
<li>传递数据。P必须向Q提供一个或多个参数，Q必须能向P返回一个值。</li>
<li>分配和释放内存。在开始时，Q可能需要为局部变量分配空间，返回时，又必须释放这些空间。</li>
</ul>
<h2 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h2><p>C语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。Q执行中，P以及所有在向上追溯到P的调用链的过程，都暂时被挂起。Q运行时，它只需要为局部变量分配新的存储空间。Q返回时，它局部存储空间都被释放。程序可以用栈来管理它的过程所需要的存储空间。栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。</p>
<p><img src="https://i.loli.net/2020/07/30/6aB2VvWqzl7oKL9.png" alt="img"></p>
<p>x86-64的栈向低地址方向增长，而栈指针%rsp指向栈顶元素。可以用pushq和popq指令将数据存入或取出。</p>
<p>当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧（stack fram）。</p>
<p>过程P调用过程Q时，会把返回地址压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。Q代码会拓展栈的边界，分配它栈帧所需空间。这个空间中，可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。</p>
<p>大多数过程帧都是定长的，在开始就分配好了。但有些过程需要变长的帧。例如通过寄存器，过程P可以传递最多6个整数值，但如果Q需要更多参数，P可以在调用Q之前在自己的栈帧里存储这些参数。</p>
<p>例如，所有参数都可以用寄存器传递。图中某些栈帧部分可以省略。而且有些过程都不需要栈帧，当所有局部变量都可以保存在寄存器中，而且该函数都不调用其他函数(称为叶子过程，次数把过程调用看成树结构)，就可以这样处理。</p>
<h2 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h2><p>将控制从函数P转到函数Q只需要简单把PC设置为Q的代码的其实位置。当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。这个信息用指令call Q调用过程Q来记录。<strong>call指令把地址A（返回地址：紧跟在call指令后那条指令的地址）压入栈，并将PC设置为Q的起始地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A。</strong></p>
<p>call指令分为 两种：</p>
<ul>
<li>直接调用（标号）</li>
<li>间接调用（*后面跟一个操作数指示符）</li>
</ul>
<p>例子：P166</p>
<h2 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h2><p>过程调用还包括数据作为参数传递，从过程返回还可能包含返回的值。大部分都是通过寄存器实现。</p>
<p>x86-64中，可以通过寄存器最多传递6个整型参数。寄存器使用有特殊顺序，使用的名字取决于传递的数据类型的大小。</p>
<p><img src="https://i.loli.net/2020/07/30/NduBQ9oxr6wIWhH.png" alt="img"></p>
<p>如果大于6个参数，多余就用栈传递。1<del>6复制到对应的寄存器，把参数7</del>n放到栈上， 而参数7位于栈顶。通过栈传递参数，数据大小向8的倍数对齐。</p>
<p><img src="https://i.loli.net/2020/07/30/EvMRS1moP8OcY5Z.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/30/X3mpRwj9qUCl1eQ.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/30/9YDsEiZuGVxIy62.png" alt="img"></p>
<h3 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h3><p>有时局部数据必须存放在内存中，常见情况：</p>
<ul>
<li>寄存器不足够存放所有本地数据</li>
<li>对一个局部变量使用地址运算符’&amp;’，因此必须为它产生一个地址。</li>
<li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到</li>
</ul>
<p><img src="https://i.loli.net/2020/07/30/tBwzKNpqYaIXDMk.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/30/AGQOeztxXEbWqaK.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/30/AGQOeztxXEbWqaK.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/30/jUFANuIDrfM8Et9.png" alt="img"></p>
<h2 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h2><p>寄存器是共享资源，我们必须保证一个进程(调用者)调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。x86-64使用了一组统一的寄存器使用惯例，所有过程都必须遵循。</p>
<p><strong>惯例，寄存器%rbx、%rbp和%r12~%r15被划分为被调用者保存寄存器</strong>。P调用Q，Q必须保存这些寄存器的值，保证到时候返回时一样的。</p>
<p>过程Q要不保存，要不根本就不去改变。可以选择把原始值压入栈中，然后在返回时弹出改回去。压入的值会在栈中创建标号为“保存的寄存器”一部分。</p>
<p><strong>所有其他的寄存器，除了栈指针%rsp，都分类为调用者保存寄存器。</strong></p>
<p><img src="https://i.loli.net/2020/07/30/cdyisBH6SRTjrgo.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/30/B7WsmntIjbyVFer.png" alt="img"></p>
<h2 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h2><p><img src="https://i.loli.net/2020/07/30/iXpUYsxnOMvH6zP.png" alt="img"></p>
<p>该汇编代码用寄存器%rbx保存n，先把已有值保存到栈上（第2行）,随后在返回时恢复该值（第11行）。每次调用rfact(n-1)结果在%rax中。</p>
<h1 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h1><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><p>C语言可以产生指向数组中元素的指针，并对指针运算。在机器代码中，这些指针会被翻译成地址运算。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T A[N]</span><br></pre></td></tr></table></figure>

<p>这个申明有两个效果。</p>
<ul>
<li>内存中分配一个L*N字节的连续区域。</li>
<li>引入标识符A，用A来表示指向数组开头的指针。</li>
</ul>
<p>元素i会被存放在地址xA+L*i的地方。</p>
<p>x86-64可以用内存引用指令来简化数组访问。例如，E是一个int型的数组，而我们想计算E[i]，E的地址存放在寄存器%rdx中，i存放在%rcx中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl (%rdx,%rcx,4),%eax</span><br></pre></td></tr></table></figure>

<h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>P是一个指向类型为T的数据的指针，p的值为xp，那么表达式p+i的值为xp+L*i,这里L是数据类型T的大小。</p>
<h2 id="嵌套的数组"><a href="#嵌套的数组" class="headerlink" title="嵌套的数组"></a>嵌套的数组</h2><p>声明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int A[5][3];</span><br></pre></td></tr></table></figure>

<p>等价于:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef int row3_t[3];</span><br><span class="line">row3_t A[5];</span><br></pre></td></tr></table></figure>

<p>数组元素在内存中按照“行优先”的顺序排序。</p>
<p>对于数组：T D[R][C];</p>
<p>数组元素D[i][j]的内存地址为：&amp;D[i][j] = xd + L（C*i+j）；</p>
<p>将A[i][j]复制到寄存器%eax中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A in %rdi,i in %rsi,and j in %rdx</span><br><span class="line">leaq (%rsi,%rsi,2),%rax	 &#x2F;&#x2F;compute 3i</span><br><span class="line">leaq (%rdi,%rax,3),%rax	&#x2F;&#x2F;compute 12i</span><br><span class="line">movl (%rax,%rdx,4),%eax &#x2F;&#x2F;Read from M[xa+12i+4j]</span><br></pre></td></tr></table></figure>

<h2 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h2><p>C语言编译器能优化定长多维数组上的操作代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define N 16</span><br><span class="line">typedef int fix_matrix[N][N];</span><br></pre></td></tr></table></figure>



<p>它去掉了整数索引j，并把所有的数组引用都换成了指针间接引用。</p>
<h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>C语言只支持大小在编译时就能确定的多维数组（对第一维可能有些例外）。程序员需要变长数组时不得不用malloc或calloc这样的函数为这些数组分配存储空间。</p>
<p>ISOC99引入一种功能，运行数组的维度是表达式，在数组被分配的时候再计算出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int A[expr1][expr2]</span><br></pre></td></tr></table></figure>

<p>访问n*n数组的元素i,j,我们可以写一个如下函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int var_ele(long n,int A[N][N],long i,long j)&#123;</span><br><span class="line">	return A[i][j]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数n必须再参数A[n][n]之前，这样函数就可以遇到这个数组的时候计算出数组的维度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n in %rdi,A in %rsi,i in %rdx,j in %rcx</span><br><span class="line">var_ele:</span><br><span class="line">	imlq	%rdx,%rdi &#x2F;&#x2F;compute n*i</span><br><span class="line">	leaq	(%rsi,%rdi,4),	%rax	&#x2F;&#x2F;compute xa+4(n*i))</span><br><span class="line">	movl	(%rax,%rcx,4),	%eax	&#x2F;&#x2F;read from M[xa+4*(n*i)+4j]</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>跟定长数组的地址计算不同在于:</p>
<ul>
<li>增加了参数n,寄存器的使用变化了</li>
<li>用了乘法指令计算n<em>i，而不是用leaq指令计算3\</em>i</li>
</ul>
<p>动态版本必须用乘法指令伸缩n倍，而不能用一系列移位和加法。这会导致严重性能处罚。</p>
<p><img src="https://i.loli.net/2020/07/30/HacQhKNFtJxV5uy.png" alt="img"></p>
<p>生成代码会避免直接引用等式&amp;D[i][j] = xd + L(C*i+j)会导致的乘法。</p>
<h1 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h1><p>C语言提供两种将不同类型的对象组合到一起创建数据类型的机制：结构(structure),将多个对象集合到一个单位中；联合(union),用关键字union来声明，允许用不同的类型来引用一个对象。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>指向结构的指针就是结构第一个字节的地址。</p>
<p>看下面的结构声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct rec&#123;</span><br><span class="line">	int i;</span><br><span class="line">	int j;</span><br><span class="line">	omt a[2];</span><br><span class="line">	int *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设struct rec*类型的变量r放在寄存器%rdi中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r in %rdi</span><br><span class="line">movl (%rdi),%eax	&#x2F;&#x2F;Get r-&gt;i</span><br><span class="line">movl %eax,4(%rdi)	&#x2F;&#x2F;store in r-&gt;j</span><br></pre></td></tr></table></figure>

<p>结构的各个字段的选取完全是在编译时处理的，机器代码不包含关于字段声明或字段名字的信息。</p>
<h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p>可以用不同字段来引用相同的内存块。这种方式规避C语言的类型系统。</p>
<p>联合的一种引用情况是，对一个数据结构中的两个不同字段的使用是互斥的，那可以声明为联合，这样可以减少分配空间的总量。</p>
<p>还有一种情况用来不同数据类型的位模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned long u &#x3D; (unsigned long) d;</span><br></pre></td></tr></table></figure>

<p>这种情况下u的位模式与d的位模式是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unsigned long double2bits(double d)&#123;</span><br><span class="line">	union&#123;</span><br><span class="line">		double d;</span><br><span class="line">		unsigned long u;</span><br><span class="line">	&#125;temp;</span><br><span class="line">	temp.d &#x3D; d;</span><br><span class="line">	return temp.u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样u和d会有一样的位表示。</p>
<h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><p>许多计算机对基本数据类型的合法地址都做了一些限制，要求地址必须是k的倍数。对齐限制简化硬件设计。例如处理器一次往内存取8字节，则地址必须要是8的倍数，否则就要取两次。</p>
<p>无论是否对齐，x86-64都能工作。不过对齐提高性能。</p>
<h1 id="在机器级程序中将控制与数据结合起来"><a href="#在机器级程序中将控制与数据结合起来" class="headerlink" title="在机器级程序中将控制与数据结合起来"></a>在机器级程序中将控制与数据结合起来</h1><h2 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h2><p>指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。例如p是一个char<em>类型的指针，它的值为p，那么表达式(int</em>)p+7计算为p+28，而（int*)(p+7)计算为p+7。</p>
<h2 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h2><p>C对数组引用不进行边界调查，而且局部变量和状态信息都在栈中。这就有可能导致写操作直接写到栈中，破坏原有数据。</p>
<p>一种特别常见的状态破坏被称为缓冲区溢出（buffer overflow）</p>
<p>gets函数的问题是它没有颁发确定是否为保存整个字符串分配了足够的康健。若将缓冲区设置得很小，若读入这个长度就会越界。</p>
<p>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种通过计算机网络攻击系统安全的方法。输入给程序一个字符串，这个字符串包括一些可执行代码的文件编码，称为攻击代码（exploit code）,另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。</p>
<h2 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h2><h3 id="栈随机化"><a href="#栈随机化" class="headerlink" title="栈随机化"></a>栈随机化</h3><p>使得栈的位置在程序每次运行时都有变化。实现方式：程序开始时，在栈上分配一段0~n字节之间的随机大小的空间。程序不适用这段抗击那，但会使后续栈位置发生改变。</p>
<h3 id="栈破坏检测"><a href="#栈破坏检测" class="headerlink" title="栈破坏检测"></a>栈破坏检测</h3><p><img src="https://i.loli.net/2020/07/30/Dlmoi3k1SIgwutM.jpg" alt="img"></p>
<p>最新GCC版本在产生的代码中加入一种栈保护者（stack protector）机制，来检测缓冲区越界。其思想是在栈帧任何局部缓冲区与栈状态之间存储一个特殊的金丝雀(canary)值，也称为哨兵值（guard value）。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被改变了，如果是，程序异常终止。</p>
<h3 id="限制可执行代码区域"><a href="#限制可执行代码区域" class="headerlink" title="限制可执行代码区域"></a>限制可执行代码区域</h3><h2 id="支持变长栈帧"><a href="#支持变长栈帧" class="headerlink" title="支持变长栈帧"></a>支持变长栈帧</h2><p><img src="https://i.loli.net/2020/07/30/J4jLmGx3TRCsuzM.png" alt="img"></p>
<p>函数声明n个指针的局部数组，这里n可变，要求在栈上分配8n个字节。此外还有一个对局部变量i的地址引用，因此i必须在栈中。</p>
<p>为了管理边长栈帧，x86-64代码使用寄存器%rbp作为栈指针（frame pointer，也称为 base pointer,也是bp由来）。</p>
<p><img src="https://i.loli.net/2020/07/30/EwFA8UtTQlZ12J9.png" alt="img"></p>
<p>保存%rbp之前的值到栈中，因为%rbp是一个被调用者保存寄存器。</p>
<h1 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h1><p>处理器的浮点体系结构有多个方面：</p>
<ul>
<li>如何存储和访问浮点数值。通常是通过某种寄存器方式完成</li>
<li>对浮点数操作的指令</li>
<li>向函数传递浮点数参数和从函数返回浮点数结果的规则</li>
<li>函数调用过程中保存寄存器的规则</li>
</ul>
<p>SIMD：对多个不同的数据采用并行执行同一个操作。</p>
<h2 id="浮点传送和转换操作"><a href="#浮点传送和转换操作" class="headerlink" title="浮点传送和转换操作"></a>浮点传送和转换操作</h2><p><img src="https://i.loli.net/2020/07/30/cT8jGLvfow7HaZb.jpg" alt="img"></p>
<p>指令名字中的字母’a’表示“aligned（对齐的）”</p>
<p>下两张图里的格式转换指令都是对单个数据值进行操作的标量指令。</p>
<p><img src="https://i.loli.net/2020/07/30/oncrPBICAm9fiSj.jpg" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/30/QpM2WPD8v3c4uxY.jpg" alt="img"></p>
<p>3-48中的指令有两个源和一个目的，第二个操作数的值只会影响结果的高位字节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vcvtsi2sdq %rax,%xmm1,%xmm1</span><br></pre></td></tr></table></figure>

<p>从%rax中读出长整数，转换成double，放进xmm1低字节中</p>
<h2 id="过程中的浮点代码"><a href="#过程中的浮点代码" class="headerlink" title="过程中的浮点代码"></a>过程中的浮点代码</h2><p>x86-64中，XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值。</p>
<ul>
<li>XMM寄存器%xmm0~%xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。通过栈传递额外的浮点参数。</li>
<li>函数使用寄存器%mm0来返回浮点值。</li>
<li>所有xmm寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中的任意一个。</li>
</ul>
<h2 id="浮点运算操作"><a href="#浮点运算操作" class="headerlink" title="浮点运算操作"></a>浮点运算操作</h2><p><img src="https://i.loli.net/2020/07/30/i2LmNbPfqRu3a61.png" alt="img"></p>
<p>第一个源操作数s1可以是xmm寄存器或内存位置。第二个源操作数和目的操作数都必须是XMM寄存器。每个操作都有针对单精度的指令和针对双精度的指令。</p>
<h2 id="定义和使用浮点常数"><a href="#定义和使用浮点常数" class="headerlink" title="定义和使用浮点常数"></a>定义和使用浮点常数</h2><p>浮点操作不能以立即数值作为操作数。对于立即数，编译器必须为所有常量值分配和初始化存储空间。然后代码在把这些值从内存读入。</p>
<h2 id="在浮点代码中使用位级操作"><a href="#在浮点代码中使用位级操作" class="headerlink" title="在浮点代码中使用位级操作"></a>在浮点代码中使用位级操作</h2><h2 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h2><p>类似于CMP指令，与cmpq一样，都是反序列出操作数的ATT格式管理。S2必须在XMM寄存器中，S1可以在XMM寄存器中，也可以在内存中。</p>
<p>浮点比较指令会设置三个条件码：零标志位ZF、进位标志位CF和奇偶标志位PF。当两个操作数任一个是NAN时，会设置PF位。</p>
]]></content>
      <categories>
        <category>《深入理解计算机系统》</category>
      </categories>
      <tags>
        <tag>csapp,视频课程</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法的比较</title>
    <url>/2020/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p><img src="https://pic2.zhimg.com/80/v2-88e47948380615b5adb6e7c313a916e5_1440w.jpg" alt="浙江大学-数据结构-算法排序的比较-10.4.1 - 知乎"></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/2020/07/21/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>假设我们有N个学生，他们的成绩是0到100之间的整数（于是有M=101个不同的成绩值）。如何在线性时间内将学生按成绩排序?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Bucket_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">	count[]初始化;</span><br><span class="line">	while(读入1个学生成绩grade)</span><br><span class="line">		将该生插入count[grade]链表;</span><br><span class="line">	for(i&#x3D;0;i&lt;M;i++)&#123;</span><br><span class="line">		if(count[i])</span><br><span class="line">			输出整个count[i]链表;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;T(N,M) &#x3D; O(M+N)</span><br></pre></td></tr></table></figure>

<p>若M&gt;&gt;N该怎么办?</p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>假设我们有N=10个整数，而M = 1000个不同的值。还有可能在线性时间内排序吗？</p>
<p>这里M已经等于了，N的三次方了。</p>
<p>可以采用“次位优先”(Least Significant Dighit),T = O(P(N+B)) (P为趟数，B等价于上面的B)</p>
<h1 id="多关键字的排序"><a href="#多关键字的排序" class="headerlink" title="多关键字的排序"></a>多关键字的排序</h1><p>例如扑克牌排序问题，用主位优先（Most Signficant Digit）排序：为花色建4个桶。</p>
<p>在每个桶内分别排序，最后合并结果。</p>
<p>若用次位优先排序:为面值建13个桶，将结果合并，然后再为花色建四个桶。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>表排序</title>
    <url>/2020/07/19/%E8%A1%A8%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><ul>
<li>简介排序</li>
</ul>
<p>定义一个指针数组作为”表”（table)</p>
<p>如果要求按顺序输出，则输出：</p>
<p>A[table[0]],A[table[1]]…A[table[N]]</p>
<h1 id="物理排序"><a href="#物理排序" class="headerlink" title="物理排序"></a>物理排序</h1><p>N个数字的排序由由若干个独立的环组成</p>
<p>Temp = f</p>
<p>如何判断一个环的结束？</p>
<p>if（table[i]== i）(前提是每移动一本书，将就table改为A下标)</p>
<h1 id="物理排序复杂度分析"><a href="#物理排序复杂度分析" class="headerlink" title="物理排序复杂度分析"></a>物理排序复杂度分析</h1><p>最好情况：初始即有序</p>
<p>最坏情况：</p>
<ul>
<li>有N/2个环，每个环2个元素</li>
<li>需要3*（N/2）次元素移动(a-&gt;tmp,b-&gt;a,b-&gt;tmp）</li>
</ul>
<p>T = O(mN),m是每个A元素的复制时间</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/07/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>什么是快速排序算法的最好情况？</p>
<p>每次正好中分    T(N) = O(NlogN)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Quicksort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	pivot &#x3D; 从A[]中选一个主元;</span><br><span class="line">	将S &#x3D; &#123;A[]\pivot&#125; 分成2个独立子集:</span><br><span class="line">	A1 &#x3D; &#123;a∈S | a ≤ pivot&#125; 和 A2 &#x3D; &#123;a∈S | a ≥ pivot&#125;;</span><br><span class="line">	A[] &#x3D; Quicksort(A1,N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2,N2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选主元"><a href="#选主元" class="headerlink" title="选主元"></a>选主元</h1><p>若选主元每次选择A[0]?</p>
<p>可能会产生下列情况：</p>
<p>1 2 3 4 5 6 … N</p>
<p>   2 3 4 5 6 … N</p>
<p>​      3 4 5 6 … N</p>
<p>T(N) = O(N) + T(N-1)</p>
<p>​        = O(N) + O(N-1) + T(N-2)</p>
<p>​        = O(N2)</p>
<p>这里距离一种选主元的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ElementType Median3	(ElementType A[],int Left,int Right)</span><br><span class="line">&#123;</span><br><span class="line">	int Center &#x3D; ([Left+Right)&#x2F;2;</span><br><span class="line">	if(A[Left] &gt; A[Center])</span><br><span class="line">		Swap(&amp;A[Left],&amp;A[Center]);</span><br><span class="line">	if(A[Left] &gt; A[Right])</span><br><span class="line">		Swap(&amp;A[Left],&amp;A[Right]);</span><br><span class="line">	if(A[Center]&gt;A[Right])</span><br><span class="line">		Swap(&amp;A[Center],&amp;A[Right]);</span><br><span class="line">	</span><br><span class="line">	Swap(&amp;A[Center],&amp;A[Right-1]);	&#x2F;&#x2F;将pivot藏到右边</span><br><span class="line">	&#x2F;&#x2F;接下来只需要考虑A[left+1]...A[Right-2]</span><br><span class="line">	return A[Right-1]	&#x2F;&#x2F;返回pivot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子集划分"><a href="#子集划分" class="headerlink" title="子集划分"></a>子集划分</h1><p>如果有元素正好等于pivot怎么办？</p>
<ul>
<li>停下来交换</li>
<li>不理它，继续移动指针</li>
</ul>
<p>第一种方式，优势是最后位置会被移动到靠中的位置，劣势是会有无用的交换</p>
<p>第二种方式，优势是不用进行无用交换，但劣势会移动到一端去。</p>
<p>综合起来，还是第一种方式比较好</p>
<h1 id="小规模数据的处理"><a href="#小规模数据的处理" class="headerlink" title="小规模数据的处理"></a>小规模数据的处理</h1><p>因为快速排序采用递归，所以需要不断压栈出栈，对于N不到100的情况，可能还不如插入排序快。</p>
<p>解决方案：当数据规模充分小，直接简单排序（比如插入排序)</p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Quicksort(ElementType A[],int Left,int Right)&#123;</span><br><span class="line">	if(Cutoff &lt;&#x3D; Right-Left)&#123;</span><br><span class="line">		Pivot &#x3D; Median3(A,Left,Right);</span><br><span class="line">		i &#x3D; Left; j &#x3D; Right-1;</span><br><span class="line">		for(;;)&#123;</span><br><span class="line">			while(A[++i]&lt;Pivot)&#123;&#125;</span><br><span class="line">			while(A[--j]&gt;Pivot)&#123;&#125;</span><br><span class="line">			if(i&lt;j)</span><br><span class="line">				Swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		Swap(&amp;A[i],&amp;A[Right-1]);</span><br><span class="line">		Quicksort(A,Left,i-1);</span><br><span class="line">		Quicksort(A,i+1,Right);</span><br><span class="line">	&#125;</span><br><span class="line">	else </span><br><span class="line">		Insertion_Sort(A+Left,Right-Left+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/07/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="核心-有序子列的归并"><a href="#核心-有序子列的归并" class="headerlink" title="核心: 有序子列的归并"></a>核心: 有序子列的归并</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;L &#x3D; 左边起始位置，R &#x3D; 右边起始位置，RightEnd &#x3D; 右边终点位置</span><br><span class="line">void Merge(ElementType A[],ElementType TmpA[],int L,int R,int RightEnd)</span><br><span class="line">&#123;</span><br><span class="line">	LeftEnd &#x3D; R-1;	&#x2F;&#x2F;左边终点位置</span><br><span class="line">	Tmp &#x3D; L;	&#x2F;&#x2F;存放数组的起始位置</span><br><span class="line">	NumElements &#x3D; RightEnd - L + 1;</span><br><span class="line">	while(L&lt;&#x3D;LeftEnd &amp;&amp; R&lt;&#x3D;RightEnd)&#123;</span><br><span class="line">		if(A[L]&lt;&#x3D;A[R]) TmpA[Tmp++] &#x3D; A[L++];</span><br><span class="line">		else	TmpA[Tmp++] &#x3D; A[R++];</span><br><span class="line">	&#125;</span><br><span class="line">	while(L&lt;&#x3D;LeftEnd)	TmpA[Tmp++] &#x3D; A[L++];</span><br><span class="line">	while(R&lt;&#x3D;RightEnd)	TmpA[Tmp++] &#x3D; A[R++];</span><br><span class="line">	for(i &#x3D; 0;i&lt;NumElements;i++,RightEnd--)</span><br><span class="line">		A[RightEnd]	&#x3D; TmpA[RightEnd];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><ul>
<li>分而治之</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;T(N) &#x3D; O(NlogN)</span><br><span class="line">void Msort(ElementType A[],ElementType TmpA[],int L,int RightEnd)&#123;</span><br><span class="line">	itn center;</span><br><span class="line">	if(L&lt;RightEnd)&#123;</span><br><span class="line">		center &#x3D; (L+RightEnd)&#x2F;2;</span><br><span class="line">		Msort(A,TmpA,L,center);</span><br><span class="line">		Msort(A,TmpA,center+1,RightEnd);</span><br><span class="line">		Merge(A,TmpA,L,Center+1,RightEnd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>统一函数接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Merge_sort(ElementType A[],int N)&#123;</span><br><span class="line">	ElementType *TmpA;</span><br><span class="line">	TmpA &#x3D; malloc(N*sizeof(ElementType)));</span><br><span class="line">	if(Tmp!&#x3D;NULL)&#123;</span><br><span class="line">		MSort(A,TmpA,0,N-1);</span><br><span class="line">		free(TmpA);</span><br><span class="line">	&#125;</span><br><span class="line">	else Error(&quot;空间不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Merge_pass(ElementType A[],ElementType TmpA[],int N,int length)&#123;</span><br><span class="line">	&#x2F;&#x2F;length为当前有序子列的长度</span><br><span class="line">	for(i &#x3D; 0;i&lt;&#x3D;N-2*length;i+&#x3D;2*length)</span><br><span class="line">		merge1(A,TmpA,i,i+length,i+2*length-1);&#x2F;&#x2F;将A中元素归并到TmpA</span><br><span class="line">		if(i+length&lt;N)&#x2F;&#x2F;归并最后两个子序列</span><br><span class="line">			Merge1(A,TmpA,i,i+length,N-1);</span><br><span class="line">		else&#x2F;&#x2F;最后只剩1个子列</span><br><span class="line">			for(j &#x3D; i;j&lt;N;j++)	TmpA[j] &#x3D; A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge_sort(ElementType A[],int N)&#123;</span><br><span class="line">	ElementType *TmpA;</span><br><span class="line">	TmpA &#x3D; malloc(N*sizeof(ElementType));</span><br><span class="line">	if(TmpA !&#x3D; NULL)&#123;</span><br><span class="line">		while(length&lt;N)&#123;&#x2F;&#x2F;这个循环保证了最后TmpA的数据可以回A去</span><br><span class="line">			Merge_pass(A,TmpA,N,length);</span><br><span class="line">			length*&#x3D;2;</span><br><span class="line">			Merge_pass(TmpA,A,N,length);&#x2F;&#x2F;如果上一步length&gt;N也没关系，会倒回A</span><br><span class="line">			legth*&#x3D;2</span><br><span class="line">		&#125;</span><br><span class="line">		free(TmpA);</span><br><span class="line">	&#125;</span><br><span class="line">	else Error(&quot;空间不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该算法稳定，但是需要额外空间，不适用于内排序，适用于外排序。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp第二章:信息的表示和处理</title>
    <url>/2020/07/18/csapp%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h1><p>机器级程序将内存视为字节数组，每一个字节都有一个数字来标识，称它为地址（address）。在机器级程序的视角里，内存被抽象成了一个概念，名为虚拟内存(virtual address space)。而所有地址的集合被称为虚拟地址空间（virtual address space）。</p>
<h2 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h2><p>以16为基数，叫做十六进制（hexadecimal）数。在C语言中，以0x或0X开头的数字常量被认为是十六进制的值。</p>
<p><strong>十六进制转二进制的一个窍门是记住A,C和F对应的十进制的值。（10，12，15）</strong></p>
<h2 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h2><p>每台计算机都有字长（word size），虚拟地址都是用一个字来编码,因此对于字长为w位的机器，虚拟地址范围为0~2的w次-1；程序最多访问2的w次 的字节。</p>
<p>大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。</p>
<h2 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h2><p>对于跨越多字节的数据对象，必须建立两个规则：</p>
<ul>
<li>对象的地址是什么</li>
<li>内存中如何排列这些字节</li>
</ul>
<p>对象的地址为所使用字节中最小的地址</p>
<p>对于排列方式有两种：</p>
<ul>
<li>小端法(little endian)：最低有效字节在最前面</li>
<li>大端法(big endian)：最高有效字节在最前面</li>
</ul>
<p>看下面这段代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">typedef unsigned char *byte_pointer;</span><br><span class="line"></span><br><span class="line">void show_bytes(byte_pointer start,size_t len)&#123;</span><br><span class="line">	size_t i;</span><br><span class="line">	for(i &#x3D; 0;i&lt;len;i++)</span><br><span class="line">		printf(&quot;%.2x&quot;,start[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h2><p>C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都是以某个标准编码来表示，最常见的是ASCII字符码。注意：<strong>strlen()不计算字符结尾，且在使用ASCII码作为字符码的任何系统都得到相同的结果，与字节顺序和字大小规则无关。</strong></p>
<h2 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h2><p>对于指令的编码，因为机器类型、不同的操作系统等因素，会有不同编码规则，因此二进制代码不兼容。</p>
<h2 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h2><p>布尔代数是二元集合{0，1}基础上的定义。用来表示这些运算的符号是与C语言位级运算使用的符号相匹配的。</p>
<p>布尔运算 ~ 对应逻辑运算NOT</p>
<p>​                &amp; 对应逻辑运算AND</p>
<p>​                | 对应逻辑运算OR</p>
<p>​                ^ 对应逻辑运算异或</p>
<p>上面四个运算可以扩展到位向量的运算，位向量就是固定长度w，由0和1组成的串。</p>
<p>&amp;和|互相之间有分配律：a&amp;(b|c) = (a&amp;b)|(a&amp;c)，反之亦然。</p>
<p>位向量一个很有用的应用就是表示有限集合。布尔代数|和&amp;分别对应于集合的并和交哦，而~对应于集合的补。</p>
<h2 id="C语言中的位级运算"><a href="#C语言中的位级运算" class="headerlink" title="C语言中的位级运算"></a>C语言中的位级运算</h2><p>C语言中： ~ 对应逻辑运算NOT</p>
<p>​                &amp; 对应逻辑运算AND</p>
<p>​                | 对应逻辑运算OR</p>
<p>​                ^ 对应逻辑运算异或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个有意思的交换函数，运用a^a &#x3D; 0 这一性质</span><br><span class="line">void inplace_swap(int *x,int *y)&#123;</span><br><span class="line">	*y &#x3D; *x^*y;</span><br><span class="line">	*x &#x3D; *x^*y;</span><br><span class="line">	*y &#x3D; *x^*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位级运算一个常见用法就是实现掩码运算，例如：</p>
<p>x&amp;0xFF生成一个由x的最低有效字节组成的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例题：</span><br><span class="line">除了x的最低有效字节外，其他的位都取补，最低有效字节保持不变</span><br><span class="line">x^0xFF(这样写就可以忽略字长)</span><br><span class="line">x的最低有效字节设置全1，其他字节保持不变</span><br><span class="line">x|0xFF</span><br></pre></td></tr></table></figure>

<h2 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h2><p>C语言还提供了一组逻辑运算符||、&amp;&amp;和！。<strong>这与位级运算是不同的</strong></p>
<h2 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h2><p>左移只有逻辑左移对应x&lt;&lt;k。</p>
<p>右移分为逻辑右移和算术右移x&gt;&gt;k。在C语言中没有明确表示，但大多数编译器都是算术右移，在java中，x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k做逻辑右移。</p>
<p><strong>若移动k≥w位时，实际移动位数为k mod w</strong></p>
<p><strong>C语言中加减法的优先级比移位运算要高。1&lt;&lt;2+3&lt;&lt;4，其实时（1&lt;&lt;(2+3)）&lt;&lt;4</strong></p>
<h1 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h1><p>编码整数的两种不同的方式：一种只能表示非负数，而另一种能表示负数、零和正数。</p>
<p><img src="https://i.loli.net/2020/07/22/J9qTAOSXkBMFxPL.png" alt="img"></p>
<h2 id="整型数据类型"><a href="#整型数据类型" class="headerlink" title="整型数据类型"></a>整型数据类型</h2><p>很明显，对于相同的数据类型根据程序编译为32位还是64位而有所不同。</p>
<p><strong>C和C++都支持有符号和无符号数。java只支持有符号数</strong></p>
<h2 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h2><p>无符号数编码，定义一个 函数名为B2U(Binary to Unsigned)来表示。</p>
<p><img src="https://i.loli.net/2020/07/22/kDIMsYiCQdNbFma.png" alt="img"></p>
<p>B2U是一个双射，是唯一的。</p>
<h2 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h2><p>最常见的有符号数的计算机表示方式就是补码（two’s-complement）形式。</p>
<p>将字的最高有效位解释为负权（negative weight）。我们用函数B2T来表示</p>
<p><img src="https://i.loli.net/2020/07/22/982nGHZEBgDN15x.png" alt="img"></p>
<p>补码编码的唯一性</p>
<p>B2T是一个双射。</p>
<p>|TMin| = |TMax| + 1,之所以不对称，因为一半的位模式表示负数，而另一半（符号设置为0）表示非负数，也就意味能表示的整数比负数少一个。第二：UMAX = 2TMAX+1</p>
<p>为了一些程序也能够在大量的机器和编译器移植，C库中的&lt;limits.h&gt;定义了一组常量(消除了可变性)，INT_MAX,INT_MIN等等。</p>
<p>而数据类型的取值范围，java标准是非常明确的。</p>
<h2 id="有符号数和无符号数之间的转换"><a href="#有符号数和无符号数之间的转换" class="headerlink" title="有符号数和无符号数之间的转换"></a>有符号数和无符号数之间的转换</h2><p>C语言允许不同数字类型之间进行强制类型转换。</p>
<p>强制类型转换的本质是，位值不变，只是改变了解释这些位的方式。</p>
<h3 id="原理：补码转化位无符号数"><a href="#原理：补码转化位无符号数" class="headerlink" title="原理：补码转化位无符号数"></a>原理：补码转化位无符号数</h3><p><strong>若满足 Tmin≤x≤Tmax的x有</strong></p>
<p>​                        </p>
<p><strong>T2U（x） =   x+2的w次,     x&lt;0</strong></p>
<p>​                       <strong>x,                    x≥0</strong></p>
<p><img src="https://i.loli.net/2020/07/22/SNJO8wZUC5ugMdG.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/22/H1SgAlRJ4cM2OVz.png" alt="img"></p>
<h3 id="无符号数转化为补码"><a href="#无符号数转化为补码" class="headerlink" title="无符号数转化为补码"></a>无符号数转化为补码</h3><p><strong>若满足 0≤u≤Umax的u有</strong></p>
<p>​                        </p>
<p><strong>U2T（x） =  u,                            u≤Tmax</strong></p>
<p>​                       <strong>u-2的w次,                   u&gt;Tmax</strong></p>
<p><img src="https://i.loli.net/2020/07/22/qSPZxaJyVi3cmCk.png" alt="img"></p>
<h2 id="C语言中的有符号数与无符号数"><a href="#C语言中的有符号数与无符号数" class="headerlink" title="C语言中的有符号数与无符号数"></a>C语言中的有符号数与无符号数</h2><p>C语言标准没有指定有符号数采用哪种表示，但几乎所有机器都使用补码。</p>
<p>当申明一个常量默认被当作有符号，要创建一个无符号数常量，必须加上后缀字符U</p>
<h2 id="拓展一个数字的位表示"><a href="#拓展一个数字的位表示" class="headerlink" title="拓展一个数字的位表示"></a>拓展一个数字的位表示</h2><ul>
<li>无符号数的零扩展（zero extension）：高位填0就行了</li>
<li>符号宽展（sign extension)：<img src="https://i.loli.net/2020/07/22/IK2Tw5Ee1AJrmcO.png" alt="img"></li>
</ul>
<p>当short转换成unsigned时，首先要改变大小，再完成从有符号到无符号之间的转换。也就是说(unsigned)sx等价于(unsigned)(int)sx。这个规则是C语言标准要求的。</p>
<p>对于C语言而言，无符号数移位是逻辑移位，有符号数移位是算术移位。 </p>
<h2 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h2><ul>
<li>截断无符号数：x’ = x mod 2的k次（截断为k位的结果）</li>
<li>截断补码数值：具有相似的属性，只不过要将最高位转换为符号位。</li>
</ul>
<h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><h2 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h2><p><img src="https://i.loli.net/2020/07/22/yv7sYBCVqb65W1L.png" alt="img"></p>
<p>对于两个非负整数，满足0≤x,y≤2的w次。每个数都表示为w位无符号数字，然而计算和，可能范围为0≤x+y≤2的（w+1）次-2。</p>
<p>一般来说，如果x+y＜2的w次，和的w+1位表示中的最高位会等于0，因此不会改变。相反另一种情况会等于1，因此丢弃它相当于从和中减去2的w次。</p>
<p><img src="https://i.loli.net/2020/07/22/hRTqSjyYUQPf1Ni.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/22/eonkqLh6mjz8GTD.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/22/YDNaCt5d6y2on9l.png" alt="img"></p>
<p>当执行C程序时，不会将溢出作为错误而发信号。所以需要另外检测。</p>
<p>对在范围0≤x,y≤umax中的x和y，令s = x+y，当s&lt;x或s&lt;y时，发生了溢出。另一方面，如果s确实溢出了，我们就有 s = x+y-2的w次。假设 y&lt;2的w次，我们就有 y-2的w次＜0，因此s&lt;x。</p>
<h3 id="无符号数取反"><a href="#无符号数取反" class="headerlink" title="无符号数取反"></a>无符号数取反</h3><p><img src="https://i.loli.net/2020/07/22/UvECyAiYpIgMDbJ.png" alt="img"></p>
<h2 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h2><p><img src="https://i.loli.net/2020/07/22/NJMkY8ew3WszdDu.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/22/TwpNJS372iqrCUV.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/22/4KkTBxauCGRtdJj.png" alt="img"></p>
<p>检测补码加法中的溢出：当x&lt;0,y&lt;0,但s≥0,计算s发生了负溢出。负溢出也是同样道理。</p>
<h2 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h2><p><img src="https://i.loli.net/2020/07/22/IgLaNrQ8MKezFG4.png" alt="img"></p>
<p><strong>补码非得位级表示：在C语言中，对于任意整数x,计算-x和~x+1结果一样。</strong></p>
<h2 id="无符号数乘法"><a href="#无符号数乘法" class="headerlink" title="无符号数乘法"></a>无符号数乘法</h2><p>范围在0&lt;=x,y&lt;=2w-1内的整数x和y可以被表示为w位的无符号数，但是它们的乘积的取值范围为0到2的2w次-2的（w+1）次+1。这可能需要2w位来表示。不过，C语言中的无符号乘法被定义为产生w位的值，就是2w位的整数乘积的低w位表示的值。</p>
<p><img src="https://i.loli.net/2020/07/22/kA7ZIKoeCUTSmYp.png" alt="img"></p>
<h2 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h2><p><strong>补码乘法和无符号数乘法具有位级等价性。</strong></p>
<p><img src="https://i.loli.net/2020/07/22/lLXw4xIu7HPR2bF.png" alt="img"></p>
<h2 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h2><p>大多数机器，整数乘法指令相当慢，需要10个或者更多的时钟周期，然后其他整数运算只需要1个时钟周期，所以试着用移位和加法运算的组合来代替乘以常数因子的乘法</p>
<h3 id="乘以2的幂"><a href="#乘以2的幂" class="headerlink" title="乘以2的幂"></a>乘以2的幂</h3><p>需要C语言编译器试图以移位，加法和减法的组合来消除很多整数乘以常数的情况。例如：x*14，编译器将乘法重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)</p>
<h3 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h3><p>整数除法比乘法更慢，需要30个或更多时钟周期。才用右移来实现，无符号数和补码数分别使用逻辑移位和算术移位来达到目的。</p>
<p>整数除法总是舍入到0。对于负数向上，对于正数向下。</p>
<p>对于无符号数。采用逻辑移位。设x’为w-k位[x的w-1,…,w的k]的无符号数，而x’’为k位表示[x的k-1,…,x的0]的无符号数,x = 2的k次*x’+x’’,而0≤x’’&lt;2的k次。因此x’自然向下取整。</p>
<p>对于补码来说。移位执行的是算术移位。对于正数来说，与无符号数一样的。对于负数，普通的算术移位，会导致向下舍入，所以需要配调整。</p>
<p>对于，负数想要向上舍入，如何调整？</p>
<p>在移位之前，“偏置（biasing）”这个值，来修正不适合的舍入。C变量x和k分别有补码值x和无符号数值k，且0≤k&lt;w,则当执行算术移位时，C表达式(x+(1&lt;&lt;k)-1)&gt;&gt;K。</p>
<p>根本原理：x/y向上取整 = （x+y-1）/y向下取整。</p>
<p>假设x=qy+r，其中0≤r&lt;y,得到(x+y-1)/y=q+(r+y-1)/y，因此。当r=0时，后面一项等于0，而当r&gt;0时，等于1。也就是说，通过给x增加一个偏量y-1，然后再用除法向下舍入，当y整数x时，我们得到q，否则，就得到q+1。回到y=2k的情况，C表达式X+(1&lt;&lt;K)-1得到数值x+2的k次-1。</p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><h2 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h2><p>二进制小数点往左移动一位相当于这个数被2除。往右移动一位，相当于将该数乘2。假定我们仅考虑有限从长度的编码，有些小数是不能被精确表示(只能表示: x*2的y次)，只能通过长度不断逼近。</p>
<h2 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h2><p>IEEE浮点标准用<img src="https://i.loli.net/2020/07/22/olTFs5RBNMtiqvy.png" alt="img">的形式来表示一个数：</p>
<ul>
<li>符号（sign）s决定是负数（s=1）还是正数（s=0），而对于数值0的符号位解释作为特殊情况处理。</li>
<li>尾数（significand）M是一个二进制小数，它的范围是1<del>2-ε，或者是0</del>1-ε。</li>
<li>阶码（exponent）E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。</li>
</ul>
<p>在单精度浮点数中，s、exp、frac分别1、8、23。双精度1,11,52。</p>
<p>根据exp的值，被编码的值可以分成三种不同的情况（最后的情况有两个变种）。</p>
<p><img src="https://i.loli.net/2020/07/22/EfHFSGqmxK9oVBN.png" alt="img"></p>
<ul>
<li>情况1（规格化数）：阶码的值E = e-bias。e为无符号数。尾数具有隐含的1开头（implied leading 1）表示。</li>
<li>情况2 （非规格化数）:E = 1-bias。尾数不包含隐含位1开头。（这里设置1-bias是为了平滑过度到规格化值，具体看下图）</li>
<li>情况3（特殊值）：阶码全为1的时候出现的，当小数域全为0时，根据符号位，得到正负无穷。小数域非0时，结果值称为“NAN”(Not a Number)。例如计算根号-1。</li>
</ul>
<h2 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h2><p><img src="https://i.loli.net/2020/07/22/JUIsNwlijmrqC68.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/07/22/xYSnNpm7fCOu12j.png" alt="img"></p>
<p>可以观察到最大非规格化数和最小规格化数之间的平滑转变。这是一个有趣的属性，当这些表达式解释为无符号整数时，它们就是按升序排列的。</p>
<h2 id="舍入（rounding）"><a href="#舍入（rounding）" class="headerlink" title="舍入（rounding）"></a>舍入（rounding）</h2><p>向偶数舍入（round-to-even），也被称为向最接近的值舍入（round-to-nearest），是默认的方式。</p>
<p><img src="https://i.loli.net/2020/07/22/hl1zEIGjO5Hn4gt.png" alt="img"></p>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><p>浮点运算具有交换律，但不具备结合律。对于表达式（3.14+1e10）-1e10求得0，是因为3.14由于太小，被舍入丢失了。另外两个特例（正无穷加负无穷=NAN，x+NAN=NAN）</p>
]]></content>
      <categories>
        <category>《深入理解计算机系统》</category>
      </categories>
      <tags>
        <tag>csapp,视频课程</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2020/07/18/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Selection_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">		MinPostion &#x3D; ScanForMin(A,i,N-1);&#x2F;&#x2F;找最小元O（N）</span><br><span class="line">		Swap(A[i],A[MinPostion]);&#x2F;&#x2F;将未排序部分的最小元换到有序部分的最后位置</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看出，虽然元素交换次数变为N-1次，但是寻找最小元的次数固定为N2。</p>
<p>无论如何： T = O（N2）；</p>
<p>这里想提高效率，只能从寻找最小元找突破口。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Heap_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	BuildHeap(A);	&#x2F;&#x2F;O(N);</span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">		TmpA[i] &#x3D; DeleteMin(A);	&#x2F;&#x2F;O(logN)</span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">		A[i] &#x3D; TmpA[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T(N) = O(NlogN)</p>
<p>需要额外O（N）空间，并且复制元素需要时间。</p>
<h2 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Heap_Sort(ElemtType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	BuildHeap(A);</span><br><span class="line">	for(i &#x3D; N-1;i&gt;0;i--)&#123;</span><br><span class="line">		Swap(&amp;A[0],&amp;A[i]);&#x2F;&#x2F; DeleteMax</span><br><span class="line">		PercDown(A,0,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定理：堆排序处理N个不同元素的随机排列的平均比较次数是2NlogN-O(NloglogN);</p>
<p>虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Swap(ElementType *a,ElementType *b)</span><br><span class="line">&#123;</span><br><span class="line">	ElementType t &#x3D; *a;*a &#x3D; *b;*b &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line">void PercDown(ElementType A[],int p,int N)&#x2F;&#x2F;将N个元素的数组中以A[p]为根的子堆调为最大堆</span><br><span class="line">&#123;</span><br><span class="line">	int Parent,Child;</span><br><span class="line">	ElementType X;</span><br><span class="line">	X &#x3D; A[p];</span><br><span class="line">	for(Parent &#x3D; p;(Parent*2+1)&lt;N;Parent &#x3D; Child)&#123;</span><br><span class="line">		Child &#x3D; Parent*2+1;</span><br><span class="line">		if((Child!&#x3D;N-1)&amp;&amp;(A[Child]&lt;A[Child+1]))</span><br><span class="line">			Child++;&#x2F;&#x2F;取左右子节点中的最大者;</span><br><span class="line">		if(X&gt;&#x3D;A[Child]) break;</span><br><span class="line">		else</span><br><span class="line">			A[parent] &#x3D; A[Child];</span><br><span class="line">	&#125;</span><br><span class="line">	A[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i &#x3D; N&#x2F;2-1;i&gt;&#x3D;0;i--)</span><br><span class="line">		PercDown(A,i,N);</span><br><span class="line">	for(i &#x3D; N-1;i&gt;0;i--)&#123;</span><br><span class="line">		Swap(&amp;A[0],&amp;A[i]);</span><br><span class="line">		PercDown(A,0,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/07/18/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<a id="more"></a>

<p>定义增量序列 Dm&gt;Dm-1&gt;…&gt;D1 = 1</p>
<p>对每个Dk进行Dk间隔排序（k = m,m-1,…1）</p>
<p>注意: Dk间隔有序的序列，在执行Dk-1间隔排序后，仍然是Dk间隔有序的</p>
<h1 id="希尔增量序列"><a href="#希尔增量序列" class="headerlink" title="希尔增量序列"></a>希尔增量序列</h1><p>原始希尔排序    Dm =    N/2向下取整,    Dk = Dk+1/2向下取整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Shell_sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	for(D&#x3D;N&#x2F;2;D&gt;0;D&#x2F;&#x3D;2)&#123;&#x2F;&#x2F;希尔增量序列</span><br><span class="line">		for(P&#x3D;D;P&lt;N;P++)&#123;	&#x2F;&#x2F;插入排序</span><br><span class="line">			Tmp &#x3D; A[P];</span><br><span class="line">			for(i&#x3D;P;i&gt;&#x3D;0&amp;&amp;A[i-D]&gt;Tmp;i-&#x3D;D)</span><br><span class="line">				A[i] &#x3D; A[i-D];</span><br><span class="line">			A[i] &#x3D; Tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最坏情况：T &#x3D; 平均时间复杂度（N2），如果增量序列里的元素不互质数，下面的排序都是无用功，直到增量为1才起作用</span><br></pre></td></tr></table></figure>

<h1 id="更多增量序列"><a href="#更多增量序列" class="headerlink" title="更多增量序列"></a>更多增量序列</h1><h2 id="Hibbard增量序列"><a href="#Hibbard增量序列" class="headerlink" title="Hibbard增量序列"></a>Hibbard增量序列</h2><p>Dk = 2的k次-1(相邻元素互质)</p>
<p>最坏情况 T = O（N的3/2次）</p>
<p>猜想: T平均 = O（N的5/4次）</p>
<h2 id="Sedgewick增量序列"><a href="#Sedgewick增量序列" class="headerlink" title="Sedgewick增量序列"></a>Sedgewick增量序列</h2><p>{1，5，19，41，109，。。。}</p>
<p>9*4的i次-9*2的i次+1    或           4的i次-3*2的i次+1</p>
<p>猜想： T平均 = O（N的7/6次)    ,T最差 = O(N的4/3次)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellSort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	int si,D,P,i;</span><br><span class="line">	ElementType Tmp;</span><br><span class="line">	int Sedgewick[] &#x3D; &#123;929,505,209,41,19,5,1,0&#125;&#x2F;&#x2F;一小部分</span><br><span class="line">	for(si &#x3D; 0;Sedgewocl[si]&gt;&#x3D;N;si++)</span><br><span class="line">		;</span><br><span class="line">	for(D &#x3D; Sedgewick[si];D&gt;0;D &#x3D; Sedgewick[++D])&#123;</span><br><span class="line">		for(P &#x3D; D;P&lt;N;p++)&#123;</span><br><span class="line">			Tmp &#x3D; A[p];</span><br><span class="line">			for(i &#x3D; P;i&gt;&#x3D;0&amp;&amp;tmp&lt;A[i];i-&#x3D;D)</span><br><span class="line">				A[i] &#x3D; A[i-D];</span><br><span class="line">			A[i] &#x3D; Tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp第一章：计算机系统漫游</title>
    <url>/2020/07/17/csapp%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    <content><![CDATA[<p>本书第一章开头通过跟踪hello程序的生命周期对系统进行学习</p>
<a id="more"></a>



<h1 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h1><p>Hello程序在一开始仅仅只是由编辑器创建的文本文件。这些文本文件在本质上都只是比特序列。</p>
<p><strong>比特序列是如何表示成文本字符？</strong></p>
<p><strong>这里采用编码标准，标准有很多，这里已ASCII标准为例：ASCII标准将这些最原始的比特序列，分成以字节（8个bit）为单位来表示每个字符。相当于y = f(x),y是文本字符，x是一个字节的bit串，函数f()是ASCII标准，该函数一一映射</strong></p>
<p><img src="https://i.loli.net/2020/07/17/OKGhCnreoVE1NYX.png" alt></p>
<p><strong>注意：文本中，每个文本行都有看不见的换行符’\n’，对应整数10</strong></p>
<p>所以在计算机中，比特序列是通过<strong>读到数据对象时的上下文</strong>来区分不同的数据对象</p>
<h1 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h1><p>源程序到目标程序（也称为可执行目标文件）转变过程如下：</p>
<p><img src="https://i.loli.net/2020/07/18/kDML9f4TUYNvcIZ.jpg" alt></p>
<ul>
<li>预处理阶段：修改原始C程序，比如将#include&lt;stdio.h&gt;中的stdio.h的内容直接插入程序文本中。最后将扩展名改为.i</li>
<li>编译阶段：通过编译器，转成了汇编语言程序。</li>
<li>汇编阶段：通过汇编器，转成了机器语言指令，把这些指令打包成可重定位目标程序（relocatable object program）的格式，保存到hello.o中</li>
<li>链接阶段：hello程序中调用了printf函数，该阶段就是将hello.o与printf.o以某种方式合并起来</li>
</ul>
<h1 id="处理器读并解释存在内存中的指令"><a href="#处理器读并解释存在内存中的指令" class="headerlink" title="处理器读并解释存在内存中的指令"></a>处理器读并解释存在内存中的指令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux&gt; .&#x2F;hello</span><br><span class="line">hello,world</span><br><span class="line">linux&gt;</span><br></pre></td></tr></table></figure>

<p>上图是通过shell（命令行解释器）运行了hello程序。</p>
<h2 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h2><ol>
<li>总线：总线被设计成传送定长的字节快，也就是字（word）。字长是系统的一个基本参数，每个系统中都不尽相同。大多数系统中要不32位要不64位。</li>
<li>I/O设备：每个I/O设备都通过一个控制器或适配器与I/O总线相连。<ul>
<li>控制器是I/O设备本身或系统的电路板上的芯片组</li>
<li>适配器是插在主板卡槽上的卡</li>
</ul>
</li>
<li>主存：由一组动态随机存取存储器（DRAM）芯片组成的。</li>
<li>处理器：是届时或执行存储在内存中指令的引擎。存储器核心是一个大小为一个字的寄存器，称为程序计数器PC，用于指向内存中某条机器语言指令。</li>
</ol>
<h2 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h2><p>初始时，shell程序执行它的指令，等待我们输入一个命令。当在键盘上输入“./hello”后，shell程序将字符逐一读入寄存器，再把它放到内存中</p>
<p><img src="https://i.loli.net/2020/07/18/ygsBjpQWza2c8mK.png" alt></p>
<p>当输入回车，shell知道我们结束了命令的输入。然后shell执行一系列指令加载并执行hello文件，将这个文件复制到主存。</p>
<p><img src="https://i.loli.net/2020/07/18/sE1g2olaPY3XStk.png" alt></p>
<p>处理器就开始执行这些机器语言指令。“Hello world”字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备。</p>
<p><img src="https://i.loli.net/2020/07/18/req7AfVIOmHBhJl.png" alt></p>
<h2 id="高速缓存至关重要"><a href="#高速缓存至关重要" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><p>高速缓存通过静态随机访问存储器（SRAM）的硬件技术实现。</p>
<h2 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h2><p>主要思想是上一层的存储器作为第一层存储器的高速缓存。</p>
<h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>shell与hello程序都没有直接访问硬件，取而代之是由操作系统提供服务。</p>
<p>操作系统两个基本功能：</p>
<ol>
<li>防止硬件被应用程序滥用</li>
<li>向应用程序提供简单的机制来控制硬件设备</li>
</ol>
<p>操作系统主要采用几个抽象概念来实现上面两个功能：</p>
<ol>
<li>文件对I/O设备的抽象表示</li>
<li>虚拟内存对主存和磁盘I/O设备的抽象表示</li>
<li>进程则是对处理器、主存和I/O设备的抽象表示</li>
</ol>
<p><img src="https://i.loli.net/2020/07/18/IdOl8L1XK7VxJn6.jpg" alt></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是操作系统对一个正在运行的程序一种抽象。有了这种抽象，一个系统上可以并发多个进程。这种并发执行，通过处理器来进程间切换来实现的。操作系统实行这种交错执行的机制称为<strong>上下文切换</strong>。</p>
<p><strong>上下文是指操作系统跟踪进程运行所需要的状态信息，比如PC和寄存器的当前值，以及主存的内容</strong></p>
<p>上下文切换其实就是保存当前进程的上下文，恢复新进程的上下文，然后将控制区传递给新进程。</p>
<p>对于两个并发进程：shell进程和hello进程。刚开始shell进程在运行，即等待命令行输入。</p>
<p>当运行hello程序，shell系统调用-》系统调用将控制权从shell到给操作系统-》操作系统保存shell进程上下文-》创建hello进程上下文并将控制权给hello进程-》hello进程终止-》操作系统恢复shell上下文，并将控制区给shell</p>
<p><img src="https://i.loli.net/2020/07/18/sFRvVEjpfN2KTrX.png" alt></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>现代操作系统中，进程由多个线程的执行单元构成，每个线程运行在进程上下文中，享有同样的代码与数据。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存是一种抽象概念，给进程提供一种假象，即每个进程都在独占使用主存。每个进程看到都是虚拟地址空间</p>
<p><img src="https://i.loli.net/2020/07/18/7vjezVrfUP1kngA.png" alt="Linux进程的虚拟地址空间"></p>
<p>最低地址开始，从上介绍。</p>
<ul>
<li>程序代码和数据：先是代码，接着是数据。</li>
<li>堆：代码与数据在进程开始运行时就被指定了大小。但调用像malloc和free这样C标准库函数时，堆在运行时动态扩展与搜索。</li>
<li>共享库：用来存放C标准库和数学库这样的共享库的代码和数据区域。</li>
<li>栈：编译器用它实现函数调用，调用一个函数，栈增长，一个函数返回时，栈就会收缩。也可以动态扩展和收缩。</li>
<li>内核虚拟内存：为内核保留</li>
</ul>
<p>虚拟内存的运作需要<strong>硬件和操作系统之间交互，包括堆处理器生成的每个地址的硬件翻译</strong></p>
<p>基本思想是进程虚拟内存的内容存在磁盘上，用主存作为磁盘的高速缓存。</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件本质是字节序列。但它向应用程序提供了一个统一的视图来看待各式各样的I/O设备。</p>
<h1 id="系统之间的网络通信"><a href="#系统之间的网络通信" class="headerlink" title="系统之间的网络通信"></a>系统之间的网络通信</h1><p>系统从主存复制一串字到网络适配器时，数据流过网络到达另一台机器。同时，系统也可以从读取其他机器发送过来的数据，并复制到主存。</p>
<p><img src="https://i.loli.net/2020/07/18/8SheWR1Fi7Jp5Ug.png" alt></p>
<h1 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h1><h2 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h2><p>若系统执行某应用程序需要时间Told。假设其中某部分与整体时间的比例为a。</p>
<p>若该部分性能提升k。则新的执行时间为：<strong>Tnew = (1-a)Told+（aTold）/k = Told[(1-a)+a/k]</strong></p>
<p>加速比 <strong>S = Told/Tnew = 1/[(1-a)+a/k];</strong></p>
<p><strong>若k-&gt;∞，则S = 1/（1-a）</strong>，说明想要高的加速比只有通过优化系统大部分组件才行。</p>
<h2 id="并发（concurrency）与并行-parallelism"><a href="#并发（concurrency）与并行-parallelism" class="headerlink" title="并发（concurrency）与并行(parallelism)"></a>并发（concurrency）与并行(parallelism)</h2><ol>
<li>线程级并发：使用线程可以在一个进程中执行多个控制流。想要实现线程级的并发，可以采用以下两个技术<ol>
<li>多核处理器：将多个CPU集成到一个集成电路芯片上。<img src="https://i.loli.net/2020/07/18/RPd5SgyTNUwiVlf.png" alt></li>
<li>超线程（hyperthreading）或称为同时多线程(simultaneous multi-threading)，允许一个CPU通过执行多个CPU。说是一个CPU，其实CPU里的某些硬件变成了多份，比如程序计数器和寄存器文件。平常线程切换大约需要20000个周期，而采用超线程技术后，只要一个周期。</li>
</ol>
</li>
<li>指令集并行：在较低抽象层次上，现代处理器可以同时执行多条指令。采用流水线(Pipelining),将一条指令分成不同步骤，将硬件组织分成一系列阶段。硬件不同部分来处理指令的不同部分。能够达到接近于一个时钟周期的执行效率。而超标量（super-scalar）处理器速度更快。</li>
<li>单指令、多数据并行(SIMD):允许一条指令产生多个可以并行的操作。</li>
</ol>
<h2 id="计算机系统中抽象的重要性"><a href="#计算机系统中抽象的重要性" class="headerlink" title="计算机系统中抽象的重要性"></a>计算机系统中抽象的重要性</h2><p>例如为一组函数规定简单的应用程序接口（API），使程序员无需了解它内部的工作便可使用。</p>
<p>指令集架构就是提供了堆实际处理器硬件的抽象。使用这个抽象，机器代码程序好像运行在一个一次只执行一次指令的处理器上。</p>
<p><img src="https://i.loli.net/2020/07/18/wchIqyM1FjCWVBP.png" alt></p>
]]></content>
      <categories>
        <category>《深入理解计算机系统》</category>
      </categories>
      <tags>
        <tag>csapp,视频课程</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp</title>
    <url>/2020/07/17/csapp/</url>
    <content><![CDATA[<p>计划:阅读CSAPP和看对应CMU课程，看完后，总结笔记。</p>
<a id="more"></a>

<hr>
<p>该篇blog用于记录实施进度。</p>
<p>2020.7.17    1-20</p>
<p>2020.7.18    20-34</p>
<p>2020.7.19    34-54</p>
<p>2020.7.20    54-60（没有效率的一天）</p>
<p>2020.7.21    60-75</p>
<p>20207.22    75-88</p>
<p>2020.7.24    109-122</p>
<p>2020.7.25    122-136</p>
<p>2020.7.26    136-149</p>
<p>2020.7.27    149-164</p>
<p>2020.7.28    164-176</p>
<p>2020.7.29    176-216（第3章结束）</p>
<p>2020.7.30    243-259</p>
<p>2020.8.1    259-277</p>
<p>2020.8.2    277-280</p>
<p>2020.8.3    280-300（流水线部分看得我难受）</p>
<p>2020.8.4    300-309 399-411 (流水线部分跳过了，先看存储器)</p>
<p>2020.8.5    411-421</p>
<p>2020.8.6    421-433</p>
<p>2020.8.7    433-451</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序</title>
    <url>/2020/07/16/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Bubble_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	for(p &#x3D; N-1;p&gt;&#x3D;0;p--)&#123;</span><br><span class="line">		flag &#x3D; 0;</span><br><span class="line">		for(i &#x3D; 0;i&lt;p;i++)&#123;	&#x2F;&#x2F;一趟冒泡</span><br><span class="line">			if(A[i]&gt;A[i+1])&#123;</span><br><span class="line">				Swap(A[i],A[i+1]);</span><br><span class="line">				flag &#x3D; 1;&#x2F;&#x2F;标识发生了交换</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag &#x3D;&#x3D; 0) break;&#x2F;&#x2F;全程无交换</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好情况：顺序T=O（N）</p>
<p>最欢情况：逆序T=O（N2）</p>
<p>稳定，也可以应用于链表</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Insertion_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	for(p &#x3D; 1;p&lt;N;p++)&#123;</span><br><span class="line">		Tmp &#x3D; A[p];</span><br><span class="line">		for(i &#x3D; p;i&gt;&#x3D;0&amp;&amp;tmp&lt;A[i-1];i--)</span><br><span class="line">			A[i] &#x3D; A[i-1];</span><br><span class="line">		A[i] &#x3D; Tmp;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好情况：顺序T=O（N）；</p>
<p>最坏情况: 逆序T=O(N2);</p>
<h1 id="时间复杂度下界"><a href="#时间复杂度下界" class="headerlink" title="时间复杂度下界"></a>时间复杂度下界</h1><p>对于i&lt;j,如果A[i]&gt;A[j],则称（i,j）是一对逆序对（inversion）</p>
<p>对于简单排序，都是相邻元素交换，每交换一次正好消去1个逆序对！</p>
<p>插入排序：T（N,I）= O（N+I），如果序列基本有序，则插入排序简单高效</p>
<p>定理:任意N个不同元素组成的序列平均具有<strong>N（N-1）/4</strong>个逆序对。</p>
<p>定理:任何交换相邻元素排序的算法，其平均时间为<strong>Ω（N2）</strong>。</p>
<p>这意味着，想提高效率，必须:</p>
<ul>
<li>每次消去不止1个逆序对</li>
<li>每次交换相隔较远的2个元素</li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>cmu csapp lecture 02 Bits,Bytes,and Integer</title>
    <url>/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/</url>
    <content><![CDATA[<p><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/02-03-bits-ints.pdf" target="_blank" rel="noopener">讲义地址</a></p>
<h1 id="Representing-amp-Manipulating-Sets"><a href="#Representing-amp-Manipulating-Sets" class="headerlink" title="Representing &amp; Manipulating Sets"></a>Representing &amp; Manipulating Sets</h1><h2 id="Representing"><a href="#Representing" class="headerlink" title="Representing"></a>Representing</h2><p>01101001{0,3,5,6}</p>
<p>01010101{0,2,4,6}</p>
<h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><p>&amp; Intersection {0,6}</p>
<p>|  Union            {0,2,3,4,5,6}</p>
<p>^  Symmetric difference {2,3,4,5}</p>
<p>~ Complement {1,3,5,7}</p>
<p>上面的布尔代数运算，是从集合的角度来看。</p>
<p>watch out for &amp;&amp; vs &amp;(and || vs |)..(Bit-level Operations and logic Operations)</p>
<h1 id="shift-Operations"><a href="#shift-Operations" class="headerlink" title="shift Operations"></a>shift Operations</h1><h2 id="Left-Shift-x-lt-lt-y"><a href="#Left-Shift-x-lt-lt-y" class="headerlink" title="Left Shift : x &lt;&lt; y"></a>Left Shift : x &lt;&lt; y</h2><h2 id="Right-Shift-x-gt-gt-y"><a href="#Right-Shift-x-gt-gt-y" class="headerlink" title="Right Shift: x&gt;&gt;y"></a>Right Shift: x&gt;&gt;y</h2><h3 id="Logical-shift-Fill-with-0’s-on-left"><a href="#Logical-shift-Fill-with-0’s-on-left" class="headerlink" title="Logical shift:Fill with 0’s on left"></a>Logical shift:Fill with 0’s on left</h3><h3 id="Arithmetic-shift-Replicate-most-significant-bit-on-letf"><a href="#Arithmetic-shift-Replicate-most-significant-bit-on-letf" class="headerlink" title="Arithmetic shift: Replicate most significant bit on letf"></a>Arithmetic shift: Replicate most significant bit on letf</h3><h1 id="Conversion-Visualized"><a href="#Conversion-Visualized" class="headerlink" title="Conversion Visualized"></a>Conversion Visualized</h1><p><img src="/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/1.png" alt="Conversion"></p>
<h1 id="Casting-Suprises"><a href="#Casting-Suprises" class="headerlink" title="Casting Suprises"></a>Casting Suprises</h1><p>在单一表达式中混有有符号数和无符号数，有符号数会转换成无符号数</p>
]]></content>
      <categories>
        <category>《深入理解计算机系统》</category>
      </categories>
      <tags>
        <tag>csapp,视频课程</tag>
      </tags>
  </entry>
  <entry>
    <title>三点心得</title>
    <url>/2020/07/14/%E4%B8%89%E7%82%B9%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<ol>
<li>当脑海中浮现不开心的事情后，想开心的事情。</li>
<li>每次结束前，尽量克服难关。</li>
<li>趁热打铁</li>
</ol>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>旅游规划</title>
    <url>/2020/07/13/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>7-9 旅游规划 (25分)</p>
<p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入数据的第1行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0~(<em>N</em>−1)；<em>M</em>是高速公路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。随后的<em>M</em>行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 40</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,S,D;</span><br><span class="line">int visited[505];</span><br><span class="line">int cost[505];</span><br><span class="line">int dist[505];</span><br><span class="line">int costs[505][505];</span><br><span class="line">int graph[505][505];</span><br><span class="line">int t1,t2,t3,t4;</span><br><span class="line">void reset()&#123;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;505;i++)&#123;</span><br><span class="line">		for(int j &#x3D; 0;j&lt;505;j++)&#123;</span><br><span class="line">			if(i!&#x3D;j)&#123;</span><br><span class="line">				costs[i][j] &#x3D; 65535;</span><br><span class="line">				graph[i][j] &#x3D; 65535;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Dijkstra(int s)&#123;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)&#123;	&#x2F;&#x2F;初始化</span><br><span class="line">		cost[i] &#x3D; costs[s][i];</span><br><span class="line">		dist[i] &#x3D; graph[s][i];</span><br><span class="line">	&#125;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		int min &#x3D; 65535;</span><br><span class="line">		int v &#x3D; -1;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">			if((i!&#x3D;s)&amp;&amp;(visited[i] &#x3D;&#x3D; 0)&amp;&amp;(graph[s][i]&lt;min))&#123;</span><br><span class="line">				v &#x3D; i;</span><br><span class="line">				min &#x3D; graph[s][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(v &#x3D;&#x3D; -1) break;</span><br><span class="line">		visited[v] &#x3D; 1;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">			if((visited[i] &#x3D;&#x3D; 0)&amp;&amp;(dist[v]+graph[v][i]&lt;dist[i]))&#123;</span><br><span class="line">				dist[i] &#x3D; dist[v] + graph[v][i];</span><br><span class="line">				cost[i] &#x3D; cost[v]+costs[v][i];</span><br><span class="line">			&#125;else if((dist[v]+graph[v][i] &#x3D;&#x3D; dist[i])&amp;&amp;(cost[v]+costs[v][i]&lt;cost[i]))&#123;</span><br><span class="line">				cost[i] &#x3D; cost[v] + costs[v][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;D;</span><br><span class="line">	reset();	&#x2F;&#x2F;初始化</span><br><span class="line">	for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">		cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3&gt;&gt;t4;</span><br><span class="line">		graph[t1][t2] &#x3D; t3;</span><br><span class="line">		graph[t2][t1] &#x3D; t3;</span><br><span class="line">		costs[t1][t2] &#x3D; t4;</span><br><span class="line">		costs[t2][t1] &#x3D; t4;</span><br><span class="line">	&#125;	</span><br><span class="line">	Dijkstra(S);</span><br><span class="line">	cout&lt;&lt;dist[D]&lt;&lt;&quot; &quot;&lt;&lt;cost[D];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他变型问题"><a href="#其他变型问题" class="headerlink" title="其他变型问题"></a>其他变型问题</h3><p>要求数最短路径有几条</p>
<ol>
<li>初始化起点:count[s] = 1;</li>
<li>如果找到更短路：count[w] = count[v];</li>
<li>如果找到等长路：count[w]+=count[v];</li>
</ol>
<p>要求边数最少的最短路</p>
<pre><code>1. counts[s] = 0;
 2. 如果找到更短路：count[w] = count[v]+1;
 3. 如果找到等长路:  count[w] = count[v] + 1;</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>关键路径</title>
    <url>/2020/07/13/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>AOE（Activity On Edge,与AOV区别）网络</p>
<p>计算整个工期就是 计算最早完成时间</p>
<p>机动时间： D&lt;i,j&gt; = Latest[j] - Earliest[i] - C&lt;i,j&gt;</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>关键路径</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2020/07/13/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="拓扑序定义"><a href="#拓扑序定义" class="headerlink" title="拓扑序定义"></a>拓扑序定义</h1><p>如果图中从v到w有一条有向途径,则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。</p>
<p>获得一个拓扑序的过程就是拓扑排序</p>
<p>Activity On Vertex (AOV) 网络如果有合理的拓扑序，则必定是有向无环图（Directed Acylic Grapg,DAG）</p>
<h1 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void TopSort()&#123;</span><br><span class="line">	for(cnt &#x3D; 0;cnt&lt;v;cnt++)&#123;</span><br><span class="line">		v &#x3D; 未输出的入度为0的顶点；&#x2F;&#x2F;O(V)</span><br><span class="line">		if(这样的v不存在)&#123;</span><br><span class="line">			Error(“图中有回路”);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		输出v，或者记录v的输出序号;</span><br><span class="line">		for(v的每个邻接点)</span><br><span class="line">			Indegree[w]--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(V2)</span><br></pre></td></tr></table></figure>

<h1 id="聪明的算法"><a href="#聪明的算法" class="headerlink" title="聪明的算法"></a>聪明的算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;随时将入度变为0的顶点放到一个容器里</span><br><span class="line">void TopSort()&#123;</span><br><span class="line">	for(图中每个顶点 v)</span><br><span class="line">		if(Indegree[v] &#x3D;&#x3D; 0)</span><br><span class="line">			enqueue(v,q);</span><br><span class="line">	while(!isempty(q))&#123;</span><br><span class="line">		v &#x3D; dequeue(q);</span><br><span class="line">		输出v,或者记录v的输出序号;cnt++</span><br><span class="line">		for(v 的每个邻接点 w)</span><br><span class="line">			if(--Indegree[W] &#x3D;&#x3D; 0)</span><br><span class="line">				enqueue(W,Q);</span><br><span class="line">	&#125;</span><br><span class="line">	if( cnt !&#x3D; v)</span><br><span class="line">		error(“图中有回路”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(V+E)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树问题(Minimum Spanning Tree)</title>
    <url>/2020/07/13/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>最小生成树首先是一棵树</p>
<ol>
<li>无回路</li>
<li>V个顶点一定有V-1条边</li>
</ol>
<p>是生成树</p>
<ol>
<li>包含全部顶点</li>
<li>V-1条边都在图里</li>
</ol>
<p>边的权重和最小</p>
<h1 id="生成最小生成树的算法思想（贪心思想）"><a href="#生成最小生成树的算法思想（贪心思想）" class="headerlink" title="生成最小生成树的算法思想（贪心思想）"></a>生成最小生成树的算法思想（贪心思想）</h1><p>每一步都是选最好的（权重最小的边）</p>
<p>选择过程中的约束：</p>
<ol>
<li>只能用图里的边</li>
<li>只能一种选择v-1条边</li>
<li>不能有回路</li>
</ol>
<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>类似Dijikastra算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		v &#x3D; 未收录顶点中dist最小值;</span><br><span class="line">		if(这样的v不存在)</span><br><span class="line">			break;</span><br><span class="line">		collected[v] &#x3D; true;</span><br><span class="line">		for(v 的每个邻接点 w)&#123;</span><br><span class="line">			if((collected[w] &#x3D;&#x3D; false) &amp;&amp; (dist[v] + E&lt;v,w&gt; &lt; dist[w]))&#123;</span><br><span class="line">				dist[w] &#x3D; dist[v] + E[v,w]l</span><br><span class="line">				path[w] &#x3D; v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Prim()&#123;</span><br><span class="line">	MST &#x3D; &#123;s&#125;;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		v &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">		if(这样v不存在)</span><br><span class="line">			break;</span><br><span class="line">		将v收录进MST: dist[v] &#x3D; 0;</span><br><span class="line">		for(v 的每个邻接点 w)&#123;</span><br><span class="line">			if(dist[w] !&#x3D; 0)&#123;</span><br><span class="line">				if(E&lt;v,w&gt; &lt;dist[w])&#123;</span><br><span class="line">					dist[w] &#x3D; E&lt;v,w&gt;;</span><br><span class="line">					parent[W] &#x3D; v;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(MST中收的顶点不到V个)</span><br><span class="line">		Error(“生成树不存在”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;dist[v] &#x3D; E&lt;s,v&gt; 或 正无穷</span><br><span class="line">&#x2F;&#x2F;parent[s] &#x3D; -1</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(v2) 稠密图合算</span><br></pre></td></tr></table></figure>

<h2 id="Kruskal算法（将森林合并成树）"><a href="#Kruskal算法（将森林合并成树）" class="headerlink" title="Kruskal算法（将森林合并成树）"></a>Kruskal算法（将森林合并成树）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Kruskal (Graph G)&#123;</span><br><span class="line">	MST &#x3D; &#123;&#125;;</span><br><span class="line">	while(MST中不到|V|-1条边 &amp;&amp; E中还有边)&#123;</span><br><span class="line">		从E中取一条权重最小边 &#x2F;*最小堆*&#x2F;</span><br><span class="line">		将E&lt;v,w&gt;从E中删除；</span><br><span class="line">		if(E&lt;v,w&gt;不在MST中构成回路) &#x2F;*并查集*&#x2F;</span><br><span class="line">			 E(V,W) 加入 MST;</span><br><span class="line">		else</span><br><span class="line">			彻底无视 E(V,W);</span><br><span class="line">		&#125;</span><br><span class="line">		if ( MST 中不到 |V|-1 条边 )</span><br><span class="line">			Error ( “生成树不存在” );</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(ElogE)</span><br></pre></td></tr></table></figure>

<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 邻接矩阵存储 - Prim最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">Vertex FindMinDist( MGraph Graph, WeightType dist[] )</span><br><span class="line">&#123; &#x2F;* 返回未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">    Vertex MinV, V;</span><br><span class="line">    WeightType MinDist &#x3D; INFINITY;</span><br><span class="line"> </span><br><span class="line">    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        if ( dist[V]!&#x3D;0 &amp;&amp; dist[V]&lt;MinDist) &#123;</span><br><span class="line">            &#x2F;* 若V未被收录，且dist[V]更小 *&#x2F;</span><br><span class="line">            MinDist &#x3D; dist[V]; &#x2F;* 更新最小距离 *&#x2F;</span><br><span class="line">            MinV &#x3D; V; &#x2F;* 更新对应顶点 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (MinDist &lt; INFINITY) &#x2F;* 若找到最小dist *&#x2F;</span><br><span class="line">        return MinV; &#x2F;* 返回对应的顶点下标 *&#x2F;</span><br><span class="line">    else return ERROR;  &#x2F;* 若这样的顶点不存在，返回-1作为标记 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Prim( MGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType dist[MaxVertexNum], TotalWeight;</span><br><span class="line">    Vertex parent[MaxVertexNum], V, W;</span><br><span class="line">    int VCount;</span><br><span class="line">    Edge E;</span><br><span class="line">     </span><br><span class="line">    &#x2F;* 初始化。默认初始点下标是0 *&#x2F;</span><br><span class="line">       for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        &#x2F;* 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY *&#x2F;</span><br><span class="line">           dist[V] &#x3D; Graph-&gt;G[0][V];</span><br><span class="line">           parent[V] &#x3D; 0; &#x2F;* 暂且定义所有顶点的父结点都是初始点0 *&#x2F; </span><br><span class="line">    &#125;</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    VCount &#x3D; 0;      &#x2F;* 初始化收录的顶点数 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    E &#x3D; (Edge)malloc( sizeof(struct ENode) ); &#x2F;* 建立空的边结点 *&#x2F;</span><br><span class="line">            </span><br><span class="line">    &#x2F;* 将初始点0收录进MST *&#x2F;</span><br><span class="line">    dist[0] &#x3D; 0;</span><br><span class="line">    VCount ++;</span><br><span class="line">    parent[0] &#x3D; -1; &#x2F;* 当前树根是0 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    while (1) &#123;</span><br><span class="line">        V &#x3D; FindMinDist( Graph, dist );</span><br><span class="line">        &#x2F;* V &#x3D; 未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">        if ( V&#x3D;&#x3D;ERROR ) &#x2F;* 若这样的V不存在 *&#x2F;</span><br><span class="line">            break;   &#x2F;* 算法结束 *&#x2F;</span><br><span class="line">             </span><br><span class="line">        &#x2F;* 将V及相应的边&lt;parent[V], V&gt;收录进MST *&#x2F;</span><br><span class="line">        E-&gt;V1 &#x3D; parent[V];</span><br><span class="line">        E-&gt;V2 &#x3D; V;</span><br><span class="line">        E-&gt;Weight &#x3D; dist[V];</span><br><span class="line">        InsertEdge( MST, E );</span><br><span class="line">        TotalWeight +&#x3D; dist[V];</span><br><span class="line">        dist[V] &#x3D; 0;</span><br><span class="line">        VCount++;</span><br><span class="line">         </span><br><span class="line">        for( W&#x3D;0; W&lt;Graph-&gt;Nv; W++ ) &#x2F;* 对图中的每个顶点W *&#x2F;</span><br><span class="line">            if ( dist[W]!&#x3D;0 &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;</span><br><span class="line">            &#x2F;* 若W是V的邻接点并且未被收录 *&#x2F;</span><br><span class="line">                if ( Graph-&gt;G[V][W] &lt; dist[W] ) &#123;</span><br><span class="line">                &#x2F;* 若收录V使得dist[W]变小 *&#x2F;</span><br><span class="line">                    dist[W] &#x3D; Graph-&gt;G[V][W]; &#x2F;* 更新dist[W] *&#x2F;</span><br><span class="line">                    parent[W] &#x3D; V; &#x2F;* 更新树 *&#x2F;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; &#x2F;* while结束*&#x2F;</span><br><span class="line">    if ( VCount &lt; Graph-&gt;Nv ) &#x2F;* MST中收的顶点不到|V|个 *&#x2F;</span><br><span class="line">       TotalWeight &#x3D; ERROR;</span><br><span class="line">    return TotalWeight;   &#x2F;* 算法执行完毕，返回最小权重和或错误标记 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 邻接表存储 - Kruskal最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 顶点并查集定义 --------------------*&#x2F;</span><br><span class="line">typedef Vertex ElementType; &#x2F;* 默认元素可以用非负整数表示 *&#x2F;</span><br><span class="line">typedef Vertex SetName;     &#x2F;* 默认用根结点的下标作为集合名称 *&#x2F;</span><br><span class="line">typedef ElementType SetType[MaxVertexNum]; &#x2F;* 假设集合元素下标从0开始 *&#x2F;</span><br><span class="line"> </span><br><span class="line">void InitializeVSet( SetType S, int N )</span><br><span class="line">&#123; &#x2F;* 初始化并查集 *&#x2F;</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    for ( X&#x3D;0; X&lt;N; X++ ) S[X] &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Union( SetType S, SetName Root1, SetName Root2 )</span><br><span class="line">&#123; &#x2F;* 这里默认Root1和Root2是不同集合的根结点 *&#x2F;</span><br><span class="line">    &#x2F;* 保证小集合并入大集合 *&#x2F;</span><br><span class="line">    if ( S[Root2] &lt; S[Root1] ) &#123; &#x2F;* 如果集合2比较大 *&#x2F;</span><br><span class="line">        S[Root2] +&#x3D; S[Root1];     &#x2F;* 集合1并入集合2  *&#x2F;</span><br><span class="line">        S[Root1] &#x3D; Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;                         &#x2F;* 如果集合1比较大 *&#x2F;</span><br><span class="line">        S[Root1] +&#x3D; S[Root2];     &#x2F;* 集合2并入集合1  *&#x2F;</span><br><span class="line">        S[Root2] &#x3D; Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SetName Find( SetType S, ElementType X )</span><br><span class="line">&#123; &#x2F;* 默认集合元素全部初始化为-1 *&#x2F;</span><br><span class="line">    if ( S[X] &lt; 0 ) &#x2F;* 找到集合的根 *&#x2F;</span><br><span class="line">        return X;</span><br><span class="line">    else</span><br><span class="line">        return S[X] &#x3D; Find( S, S[X] ); &#x2F;* 路径压缩 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )</span><br><span class="line">&#123; &#x2F;* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 *&#x2F;</span><br><span class="line">    Vertex Root1, Root2;</span><br><span class="line"> </span><br><span class="line">    Root1 &#x3D; Find( VSet, V1 ); &#x2F;* 得到V1所属的连通集名称 *&#x2F;</span><br><span class="line">    Root2 &#x3D; Find( VSet, V2 ); &#x2F;* 得到V2所属的连通集名称 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    if( Root1&#x3D;&#x3D;Root2 ) &#x2F;* 若V1和V2已经连通，则该边不能要 *&#x2F;</span><br><span class="line">        return false;</span><br><span class="line">    else &#123; &#x2F;* 否则该边可以被收集，同时将V1和V2并入同一连通集 *&#x2F;</span><br><span class="line">        Union( VSet, Root1, Root2 );</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 并查集定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 边的最小堆定义 --------------------*&#x2F;</span><br><span class="line">void PercDown( Edge ESet, int p, int N )</span><br><span class="line">&#123; &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p )    *&#x2F;</span><br><span class="line">  &#x2F;* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 *&#x2F;</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    struct ENode X;</span><br><span class="line"> </span><br><span class="line">    X &#x3D; ESet[p]; &#x2F;* 取出根结点存放的值 *&#x2F;</span><br><span class="line">    for( Parent&#x3D;p; (Parent*2+1)&lt;N; Parent&#x3D;Child ) &#123;</span><br><span class="line">        Child &#x3D; Parent * 2 + 1;</span><br><span class="line">        if( (Child!&#x3D;N-1) &amp;&amp; (ESet[Child].Weight&gt;ESet[Child+1].Weight) )</span><br><span class="line">            Child++;  &#x2F;* Child指向左右子结点的较小者 *&#x2F;</span><br><span class="line">        if( X.Weight &lt;&#x3D; ESet[Child].Weight ) break; &#x2F;* 找到了合适位置 *&#x2F;</span><br><span class="line">        else  &#x2F;* 下滤X *&#x2F;</span><br><span class="line">            ESet[Parent] &#x3D; ESet[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    ESet[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void InitializeESet( LGraph Graph, Edge ESet )</span><br><span class="line">&#123; &#x2F;* 将图的边存入数组ESet，并且初始化为最小堆 *&#x2F;</span><br><span class="line">    Vertex V;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    int ECount;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将图的边存入数组ESet *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;</span><br><span class="line">    for ( V&#x3D;0; V&lt;Graph-&gt;Nv; V++ )</span><br><span class="line">        for ( W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next )</span><br><span class="line">            if ( V &lt; W-&gt;AdjV ) &#123; &#x2F;* 避免重复录入无向图的边，只收V1&lt;V2的边 *&#x2F;</span><br><span class="line">                ESet[ECount].V1 &#x3D; V;</span><br><span class="line">                ESet[ECount].V2 &#x3D; W-&gt;AdjV;</span><br><span class="line">                ESet[ECount++].Weight &#x3D; W-&gt;Weight;</span><br><span class="line">            &#125;</span><br><span class="line">    &#x2F;* 初始化为最小堆 *&#x2F;</span><br><span class="line">    for ( ECount&#x3D;Graph-&gt;Ne&#x2F;2; ECount&gt;&#x3D;0; ECount-- )</span><br><span class="line">        PercDown( ESet, ECount, Graph-&gt;Ne );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int GetEdge( Edge ESet, int CurrentSize )</span><br><span class="line">&#123; &#x2F;* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将最小边与当前堆的最后一个位置的边交换 *&#x2F;</span><br><span class="line">    Swap( &amp;ESet[0], &amp;ESet[CurrentSize-1]);</span><br><span class="line">    &#x2F;* 将剩下的边继续调整成最小堆 *&#x2F;</span><br><span class="line">    PercDown( ESet, 0, CurrentSize-1 );</span><br><span class="line"> </span><br><span class="line">    return CurrentSize-1; &#x2F;* 返回最小边所在位置 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 最小堆定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int Kruskal( LGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType TotalWeight;</span><br><span class="line">    int ECount, NextEdge;</span><br><span class="line">    SetType VSet; &#x2F;* 顶点数组 *&#x2F;</span><br><span class="line">    Edge ESet;    &#x2F;* 边数组 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    InitializeVSet( VSet, Graph-&gt;Nv ); &#x2F;* 初始化顶点并查集 *&#x2F;</span><br><span class="line">    ESet &#x3D; (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne );</span><br><span class="line">    InitializeESet( Graph, ESet ); &#x2F;* 初始化边的最小堆 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;      &#x2F;* 初始化收录的边数 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    NextEdge &#x3D; Graph-&gt;Ne; &#x2F;* 原始边集的规模 *&#x2F;</span><br><span class="line">    while ( ECount &lt; Graph-&gt;Nv-1 ) &#123;  &#x2F;* 当收集的边不足以构成树时 *&#x2F;</span><br><span class="line">        NextEdge &#x3D; GetEdge( ESet, NextEdge ); &#x2F;* 从边集中得到最小边的位置 *&#x2F;</span><br><span class="line">        if (NextEdge &lt; 0) &#x2F;* 边集已空 *&#x2F;</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;* 如果该边的加入不构成回路，即两端结点不属于同一连通集 *&#x2F;</span><br><span class="line">        if ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )&#x3D;&#x3D;true ) &#123;</span><br><span class="line">            &#x2F;* 将该边插入MST *&#x2F;</span><br><span class="line">            InsertEdge( MST, ESet+NextEdge );</span><br><span class="line">            TotalWeight +&#x3D; ESet[NextEdge].Weight; &#x2F;* 累计权重 *&#x2F;</span><br><span class="line">            ECount++; &#x2F;* 生成树中边数加1 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( ECount &lt; Graph-&gt;Nv-1 )</span><br><span class="line">        TotalWeight &#x3D; -1; &#x2F;* 设置错误标记，表示生成树不存在 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    return TotalWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>哈利·波特的考试</title>
    <url>/2020/07/13/%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<p>7-8 哈利·波特的考试 (25分)</p>
<p>哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。</p>
<p>现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入第1行给出两个正整数<em>N</em> (≤100)和<em>M</em>，其中<em>N</em>是考试涉及的动物总数，<em>M</em>是用于直接变形的魔咒条数。为简单起见，我们将动物按1~<em>N</em>编号。随后<em>M</em>行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 11</span><br><span class="line">3 4 70</span><br><span class="line">1 2 1</span><br><span class="line">5 4 50</span><br><span class="line">2 6 50</span><br><span class="line">5 6 60</span><br><span class="line">1 3 70</span><br><span class="line">4 6 60</span><br><span class="line">3 6 80</span><br><span class="line">5 1 100</span><br><span class="line">2 4 60</span><br><span class="line">5 2 80</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 70</span><br></pre></td></tr></table></figure>



<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int D[105][105];</span><br><span class="line">int N,M;</span><br><span class="line">int t1,t2,t3;</span><br><span class="line">void reset()&#123;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">		for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">			if(i!&#x3D;j)</span><br><span class="line">				D[i][j] &#x3D; 65535; 	&#x2F;&#x2F;floyd算法要求无边就初始化为正无穷</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void floyd()&#123;</span><br><span class="line">	for(int k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">			for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">				if(D[i][k]+D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">					D[i][j] &#x3D; D[i][k]+D[k][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int FindMaxDist(int i)&#123;</span><br><span class="line">	int maxdist &#x3D; 0;</span><br><span class="line">	for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">		if(i!&#x3D;j &amp;&amp; D[i][j]&gt;maxdist)</span><br><span class="line">			maxdist &#x3D; D[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;cout&lt;&lt;maxdist&lt;&lt;&#39;\n&#39;; </span><br><span class="line">	return maxdist;</span><br><span class="line">&#125;</span><br><span class="line">void FindMinDist()&#123;</span><br><span class="line">	int mindist &#x3D; 65535;</span><br><span class="line">	int animal;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">		int maxdist &#x3D; FindMaxDist(i);</span><br><span class="line">		if(maxdist &#x3D;&#x3D; 65535)&#123;</span><br><span class="line">			printf(&quot;0\n&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if(mindist&gt;maxdist)&#123;</span><br><span class="line">			mindist &#x3D; maxdist;</span><br><span class="line">			animal &#x3D; i+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d %d\n&quot;,animal,mindist);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">	reset();</span><br><span class="line">	for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">		cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;</span><br><span class="line">		D[t1-1][t2-1] &#x3D; t3;	&#x2F;&#x2F;位置偏移</span><br><span class="line">		D[t2-1][t1-1] &#x3D; t3;</span><br><span class="line">	&#125;</span><br><span class="line">	floyd();</span><br><span class="line">&#x2F;&#x2F;	for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">&#x2F;&#x2F;		for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">&#x2F;&#x2F;			cout&lt;&lt;D[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">	FindMinDist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最短路径，floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径问题</title>
    <url>/2020/07/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="最短路径问题的抽象"><a href="#最短路径问题的抽象" class="headerlink" title="最短路径问题的抽象"></a>最短路径问题的抽象</h1><p>最短路径就是源点（Source）和终点（Destination）之间权值之和最小的一条路径</p>
<h1 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h1><ol>
<li>单元最短路径问题：一点到其他顶点的最短路径<ol>
<li>（有向）无权图</li>
<li>（有向）有权图</li>
</ol>
</li>
<li>多源最短路径问题：任意两点之间的最短路径</li>
</ol>
<h1 id="无权图的单源最短路算法"><a href="#无权图的单源最短路算法" class="headerlink" title="无权图的单源最短路算法"></a>无权图的单源最短路算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;本质就是BFS的变型</span><br><span class="line">&#x2F;&#x2F;dist[w] &#x3D; S到W的最短距离</span><br><span class="line">&#x2F;&#x2F;dist[S] &#x3D; 0</span><br><span class="line">&#x2F;&#x2F;path[W] &#x3D; S到W的路上经过的某顶点（确切说是上个顶点）</span><br><span class="line">void Unweighted(Vertex S)&#123;</span><br><span class="line">	Enqueue(S,Q);</span><br><span class="line">	while(!IsEpmty(Q)))&#123;</span><br><span class="line">		v &#x3D; Dequeue(Q);</span><br><span class="line">		for(V 的每个邻接点 W)&#123;</span><br><span class="line">			if(dist[W] &#x3D;&#x3D; -1)&#123;</span><br><span class="line">				dist[W] &#x3D; dist[V]+1;</span><br><span class="line">				path[W] &#x3D; V;</span><br><span class="line">				enqueue(W,Q);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="有权图的单源最短路算法"><a href="#有权图的单源最短路算法" class="headerlink" title="有权图的单源最短路算法"></a>有权图的单源最短路算法</h1><p><strong><em>Dijkstra算法(按照递增的顺序找到各个顶点的最短路)</em></strong></p>
<p><strong>前提是不存在负值圈</strong></p>
<ol>
<li>令S={源点s + 已经确定了最短路径的顶点vi}</li>
<li>对不属于集合S的顶点v，定义dist[v]为s到v的最短路径长度，但该路径<em>仅仅经过S中的顶点。</em>即路径{s-&gt;(vi∈S)-&gt;v}的长度</li>
<li>若路径是按照递增的顺序生成的，则<ol>
<li>真正的最短路必须只经过S中的顶点（反证法：若存在另外一个结点，那也应该是这一个结点先被收录）</li>
<li>每次从未收录的顶点中选一个dist最小的收录（贪心）</li>
<li>增加一个v进入S，可能影响另外一个w的dist值（min{dist[w], dist[v] + &lt;v,w&gt;的权重}）</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		V &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">		if(这样v不存在)</span><br><span class="line">			break;</span><br><span class="line">		collected[v] &#x3D; true;</span><br><span class="line">		for(v 的每个邻接点 W)</span><br><span class="line">			if(collected[W] &#x3D;&#x3D; false)&#123;</span><br><span class="line">				if(dist[v]+E&lt;v,w&gt; &lt; dist[W])&#123;</span><br><span class="line">					dist[W] &#x3D; dist[V] + E&lt;v,w&gt;;</span><br><span class="line">					path[W] &#x3D; v;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若将dist的值存在数组和堆中会产生不同的效果：</p>
<ol>
<li>数组中 T=O（V2 + E）适合稠密图</li>
<li>最小堆中<ol>
<li>更新dist[w] = O(logv)</li>
<li>T = O(VlogV + ElogV) = O(Elogv) 适合稀疏图</li>
</ol>
</li>
</ol>
<h1 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h1><ol>
<li>直接将单元最短路径算法调用V遍 T = O（V3 + E*V）</li>
<li>Floyd算法 T = O（V3）</li>
</ol>
<p>Floyd 算法 </p>
<ol>
<li>Dk[i][j] = 路径{i -&gt; {l&lt;=k} -&gt; j}的最小长度</li>
<li>D0,D1,…,DV-1[i][j]即给出了i到j的真正最短距离</li>
<li>最初的D-1（如果ij没边，初始化为正无穷）</li>
<li>Dk-1已经完成，递推到Dk时：<ol>
<li>或者k不∈最短路径{i-&gt;{l&lt;=k}-&gt;j},则Dk = Dk-1</li>
<li>或者k∈最短路径,则该路径由两端最短路径组成：Dk[i][j] = Dk-1[i][k] + Dk-1[k][j]</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Floyd()&#123;</span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">	 	for(j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">	 		D[i][j] &#x3D; G[i][j];</span><br><span class="line">	 		path[i][j] &#x3D; -1;	&#x2F;&#x2F;用来打印路径用</span><br><span class="line">	 	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">		for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">			for(j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">				if(D[i][k]+ D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">					D[i][j] &#x3D; D[i][k] + D[k][j];</span><br><span class="line">					path[i][j] &#x3D; k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-7-9</title>
    <url>/2020/07/09/2020-7-9/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>1064 Complete Binary Search Tree (30分)</title>
    <url>/2020/07/06/1064-Complete-Binary-Search-Tree-30%E5%88%86/</url>
    <content><![CDATA[<p>1064 Complete Binary Search Tree (30分)</p>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p>
<p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3 8 1 5 7 9 0 2 4</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int num[1005];</span><br><span class="line">int ans[1005];</span><br><span class="line">int N;</span><br><span class="line">int getMid(int l,int r)&#123;</span><br><span class="line">	int sum &#x3D; r-l+1;		&#x2F;&#x2F;总数</span><br><span class="line">	int layer &#x3D; floor(log(sum+1)&#x2F;log(2)); &#x2F;&#x2F;除最后一层的层数，</span><br><span class="line">	int lastlayerleaf &#x3D; sum+1-pow(2,layer);	&#x2F;&#x2F;最后一层的节点数</span><br><span class="line">	int leftnum &#x3D; pow(2,layer-1)-1+min(lastlayerleaf,(int)pow(2,layer-1));	&#x2F;&#x2F;左子树结点总数</span><br><span class="line">	return l+leftnum; &#x2F;&#x2F;根位置</span><br><span class="line">&#125; </span><br><span class="line">void solve(int l,int r,int root)&#123;</span><br><span class="line">	if(r-l+1 &#x3D;&#x3D; 0) return;</span><br><span class="line">	int mid &#x3D; getMid(l,r);</span><br><span class="line">	ans[root] &#x3D; num[mid];</span><br><span class="line">	solve(l,mid-1,root*2+1);</span><br><span class="line">	solve(mid+1,r,root*2+2); </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	for(int i&#x3D;0;i&lt;N;i++)</span><br><span class="line">		cin&gt;&gt;num[i];</span><br><span class="line">	sort(num,num+N);</span><br><span class="line">	solve(0,N-1,0);</span><br><span class="line">	cout&lt;&lt;ans[0];</span><br><span class="line">	for(int i &#x3D; 1;i&lt;N;i++)</span><br><span class="line">		cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>树，公式推导</tag>
      </tags>
  </entry>
  <entry>
    <title>1086 Tree Traversals Again (25分)</title>
    <url>/2020/07/06/1086-Tree-Traversals-Again-25%E5%88%86/</url>
    <content><![CDATA[<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>
<p><img src="https://images.ptausercontent.com/30" alt="img"><br>Figure 1</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 2 6 5 1</span><br></pre></td></tr></table></figure>



<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,n,i,j,k;</span><br><span class="line">string s;</span><br><span class="line">int preorder[35];</span><br><span class="line">int inorder[35];</span><br><span class="line">int postorder[35];</span><br><span class="line">void porder(int ileft,int iright,int pleft,int pright)&#123;	&#x2F;&#x2F;核心算法</span><br><span class="line">	if((ileft&gt;iright)||(pleft&gt;pright))</span><br><span class="line">		return;</span><br><span class="line">		</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	postorder[k++] &#x3D; preorder[pleft];</span><br><span class="line">	&#x2F;&#x2F;cout&lt;&lt;postorder[k-1]&lt;&lt;endl;</span><br><span class="line">	for(i &#x3D; ileft;i&lt;&#x3D;iright;i++)&#123;</span><br><span class="line">		if(inorder[i] &#x3D;&#x3D; preorder[pleft])</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	porder(i+1,iright,pleft+1+i-ileft,pright);</span><br><span class="line">	porder(ileft,i-1,pleft+1,pleft+i-ileft);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	int NN &#x3D; 2*N;</span><br><span class="line">	stack&lt;int&gt; ss;</span><br><span class="line">	while(NN--)&#123;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		if(s&#x3D;&#x3D;&quot;Push&quot;)&#123;</span><br><span class="line">			cin&gt;&gt;n;</span><br><span class="line">			ss.push(n);</span><br><span class="line">			preorder[i++] &#x3D; n;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			n &#x3D; ss.top();</span><br><span class="line">			ss.pop();</span><br><span class="line">			inorder[j++] &#x3D; n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	porder(0,N-1,0,N-1);</span><br><span class="line">	cout&lt;&lt;postorder[N-1];</span><br><span class="line">	for(int j &#x3D; N-2;j&gt;&#x3D;0;j--)&#123;</span><br><span class="line">		cout&lt;&lt;&quot; &quot;&lt;&lt;postorder[j];</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>树的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>关于高效学习</title>
    <url>/2020/07/06/%E5%85%B3%E4%BA%8E%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>看完高效学习篇之后，想要进一步将知识缩减，并带入自己的思考。</p>
<h1 id="端正学习态度"><a href="#端正学习态度" class="headerlink" title="端正学习态度"></a>端正学习态度</h1><p><img src="https://dingyue.ws.126.net/d62vefHcMwmSZZFe0RXktPa4DG1hElKx4fjzHitgkZx4v1571967477433.jpg" alt="推荐丨金字塔学习法，输出和实践最能提升学习效率_网易订阅"></p>
<p>在学习知识后，必须有对知识本身有着思考，总结与归纳，不断对这些知识进行应用，对外输出。</p>
<p>更详细得步骤：</p>
<ol>
<li>好的信息源头</li>
<li>将知识连成地图</li>
<li>对于知识本身反思与思辨</li>
<li>举一反三，进行应用</li>
</ol>
<h1 id="源头、原理和知识地图"><a href="#源头、原理和知识地图" class="headerlink" title="源头、原理和知识地图"></a>源头、原理和知识地图</h1><p>好的信息源头有如下特质:</p>
<ol>
<li>第一首资料</li>
<li>有佐证、有数据、有引用</li>
<li>加入了自己经验与思考</li>
</ol>
<p>注重基础和原理</p>
<p>将所有得知识串联起来。</p>
<h1 id="深度归纳和坚持实践"><a href="#深度归纳和坚持实践" class="headerlink" title="深度归纳和坚持实践"></a>深度归纳和坚持实践</h1><p>对于新技术，除了知识图，还需要问自己多个为什么？</p>
<ol>
<li>技术出现得背景、初衷和需要用来解决什么问题</li>
<li>该技术的优势和劣势</li>
<li>适用场景（所谓场景一般分别两个，一个是业务场景，一个是技术场景。）</li>
<li>技术的组成部分和关键点（技术的核心思想和核心组件）</li>
<li>技术的底层原理和关键实现</li>
<li>已有的实现和它之间的对比</li>
</ol>
<p>举一反三的能力：</p>
<ol>
<li>联想能力：对同一个事物的不同看法，联想相关事物</li>
<li>抽象能力：从不同问题中抽象出解的结构</li>
<li>自省能力：自己的不足</li>
</ol>
]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法，左耳朵耗子极客时间</tag>
      </tags>
  </entry>
  <entry>
    <title>7-7 六度空间</title>
    <url>/2020/07/05/7-7-%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p>
<p><img src="https://images.ptausercontent.com/35" alt="img"><br>图1 六度空间示意图</p>
<p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p>
<p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数，分别表示社交网络图的结点数<em>N</em>（1&lt;<em>N</em>≤103，表示人数）、边数<em>M</em>（≤33×<em>N</em>，表示社交关系数）。随后的<em>M</em>行对应<em>M</em>条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到<em>N</em>编号）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: 70.00%</span><br><span class="line">2: 80.00%</span><br><span class="line">3: 90.00%</span><br><span class="line">4: 100.00%</span><br><span class="line">5: 100.00%</span><br><span class="line">6: 100.00%</span><br><span class="line">7: 100.00%</span><br><span class="line">8: 90.00%</span><br><span class="line">9: 80.00%</span><br><span class="line">10: 70.00%</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int v[1005][1005];</span><br><span class="line">int flag[1005];</span><br><span class="line">int t1,t2,sum;</span><br><span class="line">int BFS(int node)&#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	int count &#x3D; 1;</span><br><span class="line">	int level &#x3D; 0;</span><br><span class="line">	int last &#x3D; node;</span><br><span class="line">	int tail;</span><br><span class="line">	flag[node] &#x3D; 1;</span><br><span class="line">	q.push(node);</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		node &#x3D; q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		for(int i &#x3D; 1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">			if((v[node][i] &#x3D;&#x3D; 1) &amp;&amp; (flag[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">				flag[i] &#x3D; 1;</span><br><span class="line">				q.push(i);</span><br><span class="line">				count++;</span><br><span class="line">				tail &#x3D; i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(node &#x3D;&#x3D; last)&#123;</span><br><span class="line">			level++;</span><br><span class="line">			last &#x3D; tail;</span><br><span class="line">		&#125;</span><br><span class="line">		if(level&#x3D;&#x3D;6) break;</span><br><span class="line">	&#125;</span><br><span class="line">	return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset()&#123;</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">		flag[i] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">		cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">		v[t1][t2] &#x3D; 1;</span><br><span class="line">		v[t2][t1] &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i &#x3D; 1 ;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">		sum &#x3D; BFS(i);</span><br><span class="line">		printf(&quot;%d: %.2f%%\n&quot;,i,(double)sum&#x2F;N*100);</span><br><span class="line">		reset();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="该题要点"><a href="#该题要点" class="headerlink" title="该题要点"></a>该题要点</h3><p>这个题目在传统的BFS算法上进行改造，需要在BFS过程中记录当前遍历的层数。</p>
<p>这里再原来的基础上增加了三个变量 tail,last,level;</p>
<p>tail表示下一层的最后一个元素；</p>
<p>last表示当前层的最后一个元素；</p>
<p>level表示当前位于第几层；</p>
<hr>
<p>初始 tail不用设，last = node（第0层最后一个结点就是自己）,level = 0(自己不算）</p>
<hr>
<p>这里关键点是为什么能知道当前node是该层最后一个元素？</p>
<p>while循环中，最后判断时，弹出的当前结点node == last 时，表明：</p>
<p>该层最后一个结点已经被弹出，且下一层所有结点全在队列中了；</p>
<p>这个时候更改新一层的last，将last = tail，并将level++；</p>
<p>level的数值表示，当前i层的所有数据已经被访问完。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>7-10 Saving James Bond - Easy Version</title>
    <url>/2020/07/05/7-10-Saving-James-Bond-Easy-Version/</url>
    <content><![CDATA[<p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p>
<p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if James can escape, or “No” if not.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14 20</span><br><span class="line">25 -15</span><br><span class="line">-25 28</span><br><span class="line">8 49</span><br><span class="line">29 15</span><br><span class="line">-35 -2</span><br><span class="line">5 28</span><br><span class="line">27 -29</span><br><span class="line">-8 -28</span><br><span class="line">-20 -35</span><br><span class="line">-25 -20</span><br><span class="line">-13 29</span><br><span class="line">-30 15</span><br><span class="line">-35 40</span><br><span class="line">12 12</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 13</span><br><span class="line">-12 12</span><br><span class="line">12 12</span><br><span class="line">-12 -12</span><br><span class="line">12 -12</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> struct node&#123;</span><br><span class="line"> 	int x,y;</span><br><span class="line"> &#125;;</span><br><span class="line"> node cro[105];</span><br><span class="line"> int visited[105];</span><br><span class="line"> int N,D;</span><br><span class="line"> int t1,t2;</span><br><span class="line"> bool answer &#x3D; 0;</span><br><span class="line"> double distance(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line"> 	return pow(x2-x1,2)+pow(y2-y1,2);</span><br><span class="line"> &#125; </span><br><span class="line">  bool DFS(int x, int y,int n)&#123;</span><br><span class="line"> 	if((x-D&lt;&#x3D;-50)||(x+D&gt;&#x3D;50)||(y-D&lt;&#x3D;-50)||(y+D&gt;&#x3D;50))&#123;</span><br><span class="line"> 		answer &#x3D; true;	</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		visited[n] &#x3D; 1;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">			if((distance(x,y,cro[i].x,cro[i].y)&lt;&#x3D;pow(D,2)) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">				DFS(cro[i].x,cro[i].y,i);</span><br><span class="line">				if(answer &#x3D;&#x3D; true) break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"> 	return answer;</span><br><span class="line"> &#125;</span><br><span class="line"> void toJump()&#123;</span><br><span class="line"> 	for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line"> 		if((distance(0,0,cro[i].x,cro[i].y)&lt;&#x3D;pow(D+15,2)) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">			answer &#x3D; DFS(cro[i].x,cro[i].y,i);</span><br><span class="line">			if(answer &#x3D;&#x3D; true) break; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(answer) cout&lt;&lt;&quot;Yes&quot;;</span><br><span class="line">	else cout&lt;&lt;&quot;No&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> int main()&#123;</span><br><span class="line"> 	cin&gt;&gt;N&gt;&gt;D;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line"> 		cin&gt;&gt;cro[i].x&gt;&gt;cro[i].y;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		toJump();	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>列出连通集</title>
    <url>/2020/06/21/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</url>
    <content><![CDATA[<p>7-6 列出连通集 (25分)</p>
<p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照”{ <em>v</em>1 <em>v</em>2 … <em>v**k</em> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure>



<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int g[10][10];</span><br><span class="line">int visited[10];</span><br><span class="line">int n,m,t1,t2;</span><br><span class="line">void BFS(int v)&#123;</span><br><span class="line">	int vt;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	visited[v] &#x3D; 1;</span><br><span class="line">	cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">	q.push(v);</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		vt &#x3D; q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">			if((g[vt][i] &#x3D;&#x3D; 1) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">				visited[i] &#x3D; 1;</span><br><span class="line">				cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">				q.push(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int v)&#123;</span><br><span class="line">	visited[v] &#x3D; 1;</span><br><span class="line">	cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">		if((g[v][i] &#x3D;&#x3D; 1) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">			DFS(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">		g[t1][t2] &#x3D; 1;</span><br><span class="line">		g[t2][t1] &#x3D; 1;</span><br><span class="line">	&#125; </span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">		if(visited[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">			DFS(i);</span><br><span class="line">			cout&lt;&lt;&quot;&#125;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)</span><br><span class="line">		visited[i] &#x3D; 0;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">		if(visited[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">			BFS(i);</span><br><span class="line">			cout&lt;&lt;&quot;&#125;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/06/20/%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图定义"><a href="#图定义" class="headerlink" title="图定义"></a>图定义</h1><p>由V（Vertex）表示有限顶点集合和E（Edge）表示有限边的集合组成</p>
<p><strong><em>不考虑重边和自回路</em></strong></p>
<p><strong><em>V不能为空，E能为空</em></strong></p>
<p>图又可分为好几种类型，比如：</p>
<p>有向图与无向图</p>
<p>网络与非网络图（边是否有权重）</p>
<h1 id="在程序中表示一个图"><a href="#在程序中表示一个图" class="headerlink" title="在程序中表示一个图"></a>在程序中表示一个图</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><h3 id="无向图用一维矩阵代替二维矩阵"><a href="#无向图用一维矩阵代替二维矩阵" class="headerlink" title="无向图用一维矩阵代替二维矩阵"></a>无向图用一维矩阵代替二维矩阵</h3><p>假定G [N] [N] 矩阵，可以用一个长度为N(N+1)/2的一维矩阵A存储，则Gij在A中对应的下标是：<strong>i（i+1）/2+j</strong></p>
<h3 id="邻接矩阵的优势"><a href="#邻接矩阵的优势" class="headerlink" title="邻接矩阵的优势"></a>邻接矩阵的优势</h3><ol>
<li>直观，好理解</li>
<li>方便查找两个顶点之间是否存在边</li>
<li>方便查找一个顶点的邻接点（对于无向图，只需要查找一行，有向图要查找一行一列）</li>
<li>方便计算度</li>
</ol>
<h3 id="邻接矩阵的劣势"><a href="#邻接矩阵的劣势" class="headerlink" title="邻接矩阵的劣势"></a>邻接矩阵的劣势</h3><ol>
<li>对于稀疏图（点多边少）</li>
<li>若要统计图中边的数量，只能遍历完整个矩阵</li>
</ol>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>设置G[N]为指针数组，数组中每个单元都存放着一个链表（存放G[i]的临接点）</p>
<h3 id="邻接表的优势"><a href="#邻接表的优势" class="headerlink" title="邻接表的优势"></a>邻接表的优势</h3><ol>
<li>方便查找任一结点的所有“邻接点”</li>
<li>对于稀疏图节约空间：N个头指针+2E个结点（每个结点两个域）</li>
<li>对于无向图方便计算顶点的度</li>
</ol>
<h3 id="邻接表的劣势"><a href="#邻接表的劣势" class="headerlink" title="邻接表的劣势"></a>邻接表的劣势</h3><ol>
<li>对于边多点少的稠密图就不划算</li>
<li>对于有向图，只能计算出度；对于入度，需要构造逆邻接表（存指向自己的边）来方便计算入度</li>
<li>对于查找一对顶点间是否存在边很不方便</li>
</ol>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深搜（Depth-First-Search-DFS）"><a href="#深搜（Depth-First-Search-DFS）" class="headerlink" title="深搜（Depth First Search ,DFS）"></a>深搜（Depth First Search ,DFS）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void DFS(Vertex X)&#123;</span><br><span class="line">	visited[X] &#x3D; true;</span><br><span class="line">	for(V的每个临接点 W)</span><br><span class="line">		if(visited[W] &#x3D;&#x3D; false)</span><br><span class="line">			DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若有N个顶点，E条边，时间复杂度</p>
<ul>
<li>邻接表，O（N+E）</li>
<li>邻接矩阵，O(N2)</li>
</ul>
<h2 id="广搜（Breadth-First-Search）"><a href="#广搜（Breadth-First-Search）" class="headerlink" title="广搜（Breadth First Search）"></a>广搜（Breadth First Search）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Void BFS(Vertex V)&#123;</span><br><span class="line">	visited[V] &#x3D; true;</span><br><span class="line">	Enqueue(V,Q);</span><br><span class="line">	while(!IsEmpty(Q))&#123;</span><br><span class="line">		V &#x3D; Dequeue(Q);</span><br><span class="line">		for(V 的每个邻接点 W)</span><br><span class="line">			if(!visited[w])&#123;</span><br><span class="line">				visited[W] &#x3D; true;</span><br><span class="line">				Enqueue(W,Q);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若有N个顶点，E条边，时间复杂度</p>
<ul>
<li>邻接表，O（N+E）</li>
<li>邻接矩阵，O(N2)</li>
</ul>
<h1 id="图论的一些概念"><a href="#图论的一些概念" class="headerlink" title="图论的一些概念"></a>图论的一些概念</h1><p>连通 ：V到W存在一条路径，则称V和W是连通的</p>
<p>连通图: 图中任意两顶点均连通</p>
<p>连通分量： <strong><em>无向图</em></strong>的极大连通子图</p>
<p>​     极大顶点数</p>
<pre><code>极大边数</code></pre><p>强连通： <strong><em>有向图</em></strong>中顶点V和W之间存在双向路径</p>
<p>强连通图:  <strong><em>有向图</em></strong>中任意两顶点均强连通</p>
<p>强连通分量：有向图的极大连通子图</p>
<p>简单路径：V到W之间的所有顶点都不同</p>
<p>回路：起点等于终点的路径</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>File Transfer</title>
    <url>/2020/06/19/File-Transfer/</url>
    <content><![CDATA[<p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains <em>N</em> (2≤<em>N</em>≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and <em>N</em>. Then in the following lines, the input is given in the format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I c1 c2</span><br></pre></td></tr></table></figure>

<p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C c1 c2</span><br></pre></td></tr></table></figure>

<p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure>

<p>where <code>S</code> stands for stopping this case.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each <code>C</code> case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are <code>k</code> components.” where <code>k</code> is the number of connected components in this network.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">There are 2 components.</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">I 1 3</span><br><span class="line">C 1 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">The network is connected.</span><br></pre></td></tr></table></figure>



<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char c;</span><br><span class="line">int N;</span><br><span class="line">int pc[10005];</span><br><span class="line">int find(int a)&#123;</span><br><span class="line">	if(pc[a]&lt;0) return a;</span><br><span class="line">	else return pc[a] &#x3D; find(pc[a]);</span><br><span class="line">&#125;</span><br><span class="line">void input()&#123;</span><br><span class="line">	int t1,t2;</span><br><span class="line">	scanf(&quot;%d %d\n&quot;,&amp;t1,&amp;t2);</span><br><span class="line">	int root1,root2;</span><br><span class="line">	root1 &#x3D; find(t1);</span><br><span class="line">	root2 &#x3D; find(t2);</span><br><span class="line">	pc[root1] &#x3D; root2;</span><br><span class="line">&#125;</span><br><span class="line">void check()&#123;</span><br><span class="line">	int t1,t2;</span><br><span class="line">	scanf(&quot;%d %d\n&quot;,&amp;t1,&amp;t2);</span><br><span class="line">	if(find(t1) &#x3D;&#x3D; find(t2)) cout&lt;&lt;&quot;yes\n&quot;;</span><br><span class="line">	else cout&lt;&lt;&quot;no\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">void sum()&#123;</span><br><span class="line">	int a &#x3D; 0;</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">		if(pc[i] &#x3D;&#x3D; -1) a++;</span><br><span class="line">	if(a &#x3D;&#x3D; 1) cout&lt;&lt;&quot;The network is connected.\n&quot;;</span><br><span class="line">	else printf(&quot;There are %d components.\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d\n&quot;,&amp;N);</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">		pc[i] &#x3D; -1;</span><br><span class="line">	do&#123;</span><br><span class="line">		scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">		switch(c)&#123;</span><br><span class="line">			case &#39;I&#39;: input(); break;</span><br><span class="line">			case &#39;C&#39;: check(); break;</span><br><span class="line">			case &#39;S&#39;: sum(); break;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;while(c!&#x3D;&#39;S&#39;); 	&#x2F;&#x2F;不要忘了；</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>集合及运算</title>
    <url>/2020/06/19/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>定义：集合<strong><em>并，查</em></strong>某元素属于什么集合</p>
<p><em>双亲表示法：孩子指向双亲(与普通树的指针刚好相反)</em></p>
<h1 id="并查集存储"><a href="#并查集存储" class="headerlink" title="并查集存储"></a>并查集存储</h1><p>typedef struct{</p>
<p>​    ElementType Data;</p>
<p>​    int parent;</p>
<p>} SetType;</p>
<h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><h2 id="查找某个元素所在集合"><a href="#查找某个元素所在集合" class="headerlink" title="查找某个元素所在集合"></a>查找某个元素所在集合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Find(SetType S[],ElementType X)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i &#x3D; 0;i&lt;MaxSize &amp;&amp; S[i].data !&#x3D; X; i++);</span><br><span class="line">	if(i &gt;&#x3D; MaxSize) return -1; 	&#x2F;&#x2F;未找到X，返回-1</span><br><span class="line">	for(;S[i].parent &gt;&#x3D; 0; i &#x3D; S[i].Parent);</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合的并运算"><a href="#集合的并运算" class="headerlink" title="集合的并运算"></a>集合的并运算</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Union(SetType S[], ElementType X1, ElementType X2)&#123;</span><br><span class="line">	int root1, root2;</span><br><span class="line">	root1 &#x3D; Find(S,X1);</span><br><span class="line">	root2 &#x3D; Find(S,X2);</span><br><span class="line">	if(root1!&#x3D;root2) S[root2].parent &#x3D; Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>改写Find方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Find(SetType S[], ElementType X)&#123;</span><br><span class="line">	if(S[X]&lt;0)</span><br><span class="line">		return x;</span><br><span class="line">	else return S[X] &#x3D; Find(S,S[X]);	&#x2F;&#x2F;尾递归不用担心爆内存，编译器编译时会优化成循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树与哈夫曼编码</title>
    <url>/2020/06/18/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h1><p>哈夫曼树又称为最优二叉树，是WPL最小的二叉树</p>
<h1 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct TreeNode *HuffmanTree;</span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">	int Weight;</span><br><span class="line">	HuffmanTree Left,Right;</span><br><span class="line">&#125;</span><br><span class="line">HuffmanTree Huffman(MinHeap H)&#123;</span><br><span class="line">	int i; HuffmanTree T;</span><br><span class="line">	BuildMinHeap(H)	&#x2F;&#x2F;调整为最小堆</span><br><span class="line">	for(i &#x3D; 1;i&lt; H-&gt;Size;i++)&#123;	&#x2F;&#x2F;做H-&gt;size-1次合并</span><br><span class="line">		T &#x3D; malloc(sizeof(struct TreeNode));</span><br><span class="line">		T-&gt;Left &#x3D; DeleteMin(H);</span><br><span class="line">		T-&gt;Right &#x3D; DeleteMin(H);</span><br><span class="line">		T-&gt;Weight &#x3D; T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;</span><br><span class="line">		Insert(H,T);</span><br><span class="line">	&#125;</span><br><span class="line">	T &#x3D; DeleteMin(H);</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体复杂度NlogN。</p>
<h1 id="哈夫曼树特点"><a href="#哈夫曼树特点" class="headerlink" title="哈夫曼树特点"></a>哈夫曼树特点</h1><h2 id="没有度为1的节点"><a href="#没有度为1的节点" class="headerlink" title="没有度为1的节点"></a>没有度为1的节点</h2><h2 id="n个叶子结点的哈夫曼树共有2n-1个结点（n2-n0-1）"><a href="#n个叶子结点的哈夫曼树共有2n-1个结点（n2-n0-1）" class="headerlink" title="n个叶子结点的哈夫曼树共有2n-1个结点（n2 = n0-1）"></a>n个叶子结点的哈夫曼树共有2n-1个结点（n2 = n0-1）</h2><h2 id="任意非叶结点的左右子树交换仍是哈夫曼树"><a href="#任意非叶结点的左右子树交换仍是哈夫曼树" class="headerlink" title="任意非叶结点的左右子树交换仍是哈夫曼树"></a>任意非叶结点的左右子树交换仍是哈夫曼树</h2><h2 id="对于同一组权值，存在着不同构的两棵哈夫曼树-1-2-3-3"><a href="#对于同一组权值，存在着不同构的两棵哈夫曼树-1-2-3-3" class="headerlink" title="对于同一组权值，存在着不同构的两棵哈夫曼树({1,2,3,3})"></a>对于同一组权值，存在着不同构的两棵哈夫曼树({1,2,3,3})</h2><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>不等长编码，且可以避免二义性。</p>
<p>就是一种前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>哈夫曼</tag>
      </tags>
  </entry>
  <entry>
    <title>堆中的路径</title>
    <url>/2020/06/18/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每组测试第1行包含2个正整数<em>N</em>和<em>M</em>(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的<em>N</em>个要被插入一个初始为空的小顶堆的整数。最后一行给出<em>M</em>个下标。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure>

<hr>
<p>一开始解这道题的时候思路是先将这N个数字存储下来，再从最后一个具有子节点的节点开始向下调整。</p>
<p>但是这样解错了。</p>
<h3 id="自己的解法（错误）"><a href="#自己的解法（错误）" class="headerlink" title="自己的解法（错误）"></a>自己的解法（错误）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int a[1005],b[1005];</span><br><span class="line">void ajust(int index)&#123;</span><br><span class="line">	int parent;</span><br><span class="line">	int child;</span><br><span class="line">	int temp &#x3D; a[index];</span><br><span class="line">	for(parent &#x3D; index; parent*2&lt;&#x3D;N;parent &#x3D; child)&#123;</span><br><span class="line">		child &#x3D; 2*parent;</span><br><span class="line">		if((child!&#x3D;N) &amp;&amp; (a[child]&gt;a[child+1]))</span><br><span class="line">			child++;</span><br><span class="line">		if(temp&lt;&#x3D;a[child]) break;</span><br><span class="line">		else a[parent] &#x3D; a[child];</span><br><span class="line">	&#125;</span><br><span class="line">	a[parent] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void buildHeap()&#123;</span><br><span class="line">	for(int i &#x3D; N&#x2F;2 ;i&gt;0;i--)&#123;</span><br><span class="line">		ajust(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void printPath(int index)&#123;</span><br><span class="line">	int flag &#x3D; 1;</span><br><span class="line">	for(int i &#x3D; index;i&gt;0;i&#x3D;i&#x2F;2)&#123;</span><br><span class="line">		if(flag)&#123;</span><br><span class="line">			printf(&quot;%d&quot;,a[i]);</span><br><span class="line">			flag &#x3D; 0;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			printf(&quot; %d&quot;,a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">	a[0] &#x3D; -10001;</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;M;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	buildHeap();</span><br><span class="line">&#x2F;&#x2F;	for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">&#x2F;&#x2F;		cout&lt;&lt; a[i];</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;M;i++)&#123;</span><br><span class="line">		printPath(b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="正确的解法"><a href="#正确的解法" class="headerlink" title="正确的解法"></a>正确的解法</h3><p>该题目采用建立小顶堆的方式是逐个插入，逐个调整。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M;</span><br><span class="line">int a[1005];</span><br><span class="line">int size &#x3D; 0;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">	a[0] &#x3D; -10001;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">		int temp;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">		int j;</span><br><span class="line">		for(j &#x3D; ++size;a[j&#x2F;2]&gt;temp;j &#x3D; j&#x2F;2)&#123;</span><br><span class="line">			a[j] &#x3D; a[j&#x2F;2];</span><br><span class="line">		&#125;</span><br><span class="line">		a[j] &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">		int temp;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">		cout&lt;&lt;a[temp];</span><br><span class="line">		while(temp!&#x3D;1)&#123;</span><br><span class="line">			temp &#x3D; temp&#x2F;2;</span><br><span class="line">			cout&lt;&lt;&quot; &quot;&lt;&lt;a[temp];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;\n&quot;; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以发现，分别采用这两种方式构建小顶堆，结果是不一样的。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2020/06/17/%E5%A0%86/</url>
    <content><![CDATA[<h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><p>优先队列（Priority Queue）: 取出元素的顺序按优先权大小，而不是元素进入队列的先后顺序。</p>
<p>若堆可以用二叉搜索树来实现，插入操作时间效率就是对数级，删除操作也是对数级，但如果不断删除最大或最小的，树会歪掉，树的高度就不再是对数级别了。</p>
<h1 id="堆的两个特性"><a href="#堆的两个特性" class="headerlink" title="堆的两个特性"></a>堆的两个特性</h1><p>结构性：用数组表示的完全二叉树。</p>
<p>有序性：任一节点的关键字是其子树所有结点的最大值（或最小值）</p>
<h1 id="堆的操作集"><a href="#堆的操作集" class="headerlink" title="堆的操作集"></a>堆的操作集</h1> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct HeapStruct *MaxHeap;</span><br><span class="line">struct HeapStruct&#123;</span><br><span class="line">	ElementType *Elements;&#x2F;&#x2F; 存储堆元素的数组</span><br><span class="line">	int Size;&#x2F;&#x2F;堆当前元素个数</span><br><span class="line">	int Capacity;&#x2F;&#x2F;堆最大容量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MaxHeap Create(int MaxSize)&#123;</span><br><span class="line">	MaxHeap H &#x3D; malloc(sizeof(struct HeapStruct));</span><br><span class="line">	H-&gt;Elements &#x3D; malloc((MaxSize+1)*sizeof(ElementType));</span><br><span class="line">	H-&gt;Size &#x3D; 0;</span><br><span class="line">	H-&gt;Capacity &#x3D; MaxSize;</span><br><span class="line">	H-&gt;Elements[0] &#x3D; MaxData;&#x2F;&#x2F;作为哨兵，便于以后更快操作</span><br><span class="line">	return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Insert(MaxHeap H,ElementType item)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	if(isFull(H))&#123;</span><br><span class="line">		printf(&quot;最大堆已满&quot;)；</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	i &#x3D; ++H-&gt;Size;</span><br><span class="line">	for(;H-&gt;Elements[i&#x2F;2] &lt; item; i&#x2F;&#x3D;2)</span><br><span class="line">		H-&gt;Elements[i] &#x3D; H-&gt;Elements[i&#x2F;2];</span><br><span class="line">	H-&gt;Elements[i] &#x3D; item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ElementType DeleteMax(MaxHeap H)&#123;</span><br><span class="line">	&#x2F;&#x2F;取出键值最大的元素，并删除有一个节点</span><br><span class="line">	int Parent,Child;</span><br><span class="line">	ElementType MaxItem,temp;</span><br><span class="line">	if(isEmpty(H))&#123;</span><br><span class="line">		printf(&quot;最大堆已为空&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	MaxItem &#x3D; H-&gt;Elements[1];</span><br><span class="line">	for(Parent &#x3D; 1; Parent*2&lt;&#x3D;H-&gt;Size; Parent &#x3D; Child)&#123;</span><br><span class="line">		Child &#x3D; Parent * 2;</span><br><span class="line">		if((Child!&#x3D; H-&gt;Size) &amp;&amp; (H-&gt;Element[Child]&lt;H-&gt;Element[Child+1]))</span><br><span class="line">			Child++;</span><br><span class="line">		if( temp &gt;&#x3D; H-&gt;Elements[Child]) break;</span><br><span class="line">		else H-&gt;Elements[Parent] &#x3D; H-&gt;Elements[Child];</span><br><span class="line">	&#125;    </span><br><span class="line">	H-&gt;Elements[Parent] &#x3D; temp;</span><br><span class="line">	return MaxItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大堆的建立"><a href="#最大堆的建立" class="headerlink" title="最大堆的建立"></a>最大堆的建立</h2><p>将已经存在的N个元素按最大堆的要求放在一个一维数组中。</p>
<p>方法1：将N个元素一个个相继插入到一个初始为空的堆中去，时间代价为NlogN。</p>
<p>方法2：（1）将N个元素顺序存入，先满足完全二叉树的结构特性。（2）调节各节点位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void PercDown(MaxHeap H,int p)&#123;</span><br><span class="line">	int Parent,Child;</span><br><span class="line">	ElementType X;</span><br><span class="line">	X &#x3D; H-&gt;Data[p];</span><br><span class="line">	for(Parent &#x3D; p; Parent*2&lt;&#x3D;H-&gt;Size; Parent &#x3D; Child)&#123;</span><br><span class="line">		Child &#x3D; Parent*2;</span><br><span class="line">		if((Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]))</span><br><span class="line">			Child++;</span><br><span class="line">		if(X&gt;&#x3D;H-&gt;Data[Child]) break;</span><br><span class="line">		else H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];</span><br><span class="line">	&#125;</span><br><span class="line">	H-&gt;Data[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line">void BuildHeap(MaxHeap H)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i &#x3D; H-&gt;Size&#x2F;2;i&gt;0;i--)</span><br><span class="line">		PercDown(H,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>Root of AVL Tree</title>
    <url>/2020/06/08/Root-of-AVL-Tree/</url>
    <content><![CDATA[<p>1066 Root of AVL Tree (25分)</p>
<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p>
<p><img src="https://images.ptausercontent.com/31" alt="img"> <img src="https://images.ptausercontent.com/32" alt="img"></p>
<p><img src="https://images.ptausercontent.com/33" alt="img"> <img src="https://images.ptausercontent.com/34" alt="img"></p>
<p>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤20) which is the total number of keys to be inserted. Then <em>N</em> distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure>



<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N;</span><br><span class="line">struct Node&#123;</span><br><span class="line">	Node* l;</span><br><span class="line">	Node* r;</span><br><span class="line">	int data;</span><br><span class="line">	int height;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int getHeight(Node* root)&#123;</span><br><span class="line">	if(!root) return 0;</span><br><span class="line">	return root-&gt;height; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void updateHeight(Node* root)&#123;</span><br><span class="line">	root-&gt;height &#x3D; max(getHeight(root-&gt;l),getHeight(root-&gt;r))+1; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void R(Node* &amp;root)&#123;</span><br><span class="line">	Node* temp &#x3D; root-&gt;l;</span><br><span class="line">	root-&gt;l &#x3D; root-&gt;l-&gt;r;</span><br><span class="line">	temp-&gt;r &#x3D; root;</span><br><span class="line">	updateHeight(root);</span><br><span class="line">	updateHeight(temp);</span><br><span class="line">	root &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void L(Node* &amp;root)&#123;</span><br><span class="line">	Node* temp &#x3D; root-&gt;r;</span><br><span class="line">	root-&gt;r &#x3D; root-&gt;r-&gt;l;</span><br><span class="line">	temp-&gt;l &#x3D; root;</span><br><span class="line">	updateHeight(root);</span><br><span class="line">	updateHeight(temp);</span><br><span class="line">	root &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">Node* newNode(int t)&#123;</span><br><span class="line">	Node* node &#x3D; new Node();</span><br><span class="line">	node-&gt;l &#x3D; node-&gt;r &#x3D; NULL;</span><br><span class="line">	node-&gt;data &#x3D; t;</span><br><span class="line">	node-&gt;height &#x3D; 1;</span><br><span class="line">	return node; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int getBalanceFactor(Node* root)&#123;</span><br><span class="line">	return getHeight(root-&gt;l) - getHeight(root-&gt;r);</span><br><span class="line">&#125; </span><br><span class="line">void insert(int t,Node* &amp;node)&#123;</span><br><span class="line">	if(!node)&#123;</span><br><span class="line">		node &#x3D; newNode(t);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(node-&gt;data&lt;t)&#123;</span><br><span class="line">		insert(t,node-&gt;r);</span><br><span class="line">		updateHeight(node);</span><br><span class="line">		if(getBalanceFactor(node) &#x3D;&#x3D; -2)&#123;</span><br><span class="line">			if(getBalanceFactor(node-&gt;r) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">				L(node);</span><br><span class="line">			&#125;else if(getBalanceFactor(node-&gt;r) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">				R(node-&gt;r);</span><br><span class="line">				L(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		insert(t,node-&gt;l);</span><br><span class="line">		updateHeight(node);</span><br><span class="line">		if(getBalanceFactor(node) &#x3D;&#x3D; 2)&#123;</span><br><span class="line">			if(getBalanceFactor(node-&gt;l) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">				R(node);</span><br><span class="line">			&#125;else if(getBalanceFactor(node-&gt;l) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">				L(node-&gt;l);</span><br><span class="line">				R(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	Node* node &#x3D; NULL; </span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">		int temp &#x3D; 0;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		insert(temp,node);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;node-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>是否同一棵二叉搜索树</title>
    <url>/2020/06/08/%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数<em>N</em> (≤10)和<em>L</em>，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出<em>N</em>个以空格分隔的正整数，作为初始插入序列。最后<em>L</em>行，每行给出<em>N</em>个插入的元素，属于<em>L</em>个需要检查的序列。</p>
<p>简单起见，我们保证每个插入序列都是1到<em>N</em>的一个排列。当读到<em>N</em>为0时，标志输入结束，这组数据不要处理。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,L;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int v;</span><br><span class="line">	node* l;</span><br><span class="line">	node* r;</span><br><span class="line">	int flag;</span><br><span class="line">&#125;;</span><br><span class="line">node* addNode(int value,node* root)&#123;</span><br><span class="line">	if(!root)&#123;</span><br><span class="line">		node* temp &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">		temp-&gt;l &#x3D; NULL;</span><br><span class="line">		temp-&gt;r &#x3D; NULL;</span><br><span class="line">		temp-&gt;v &#x3D; value;</span><br><span class="line">		temp-&gt;flag &#x3D; 0;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125; </span><br><span class="line">	if(value&lt;root-&gt;v) root-&gt;l &#x3D; addNode(value,root-&gt;l);</span><br><span class="line">	else root-&gt;r &#x3D; addNode(value,root-&gt;r);</span><br><span class="line">	return root; </span><br><span class="line">&#125;</span><br><span class="line">int check(node* root,int temp)&#123;</span><br><span class="line">	if(!root) return 0;</span><br><span class="line">	if((root-&gt;flag &#x3D;&#x3D; 0)&amp;&amp;(root-&gt;v!&#x3D;temp)) return 0;</span><br><span class="line">	if((root-&gt;flag &#x3D;&#x3D; 0)&amp;&amp;(root-&gt;v&#x3D;&#x3D;temp))&#123;</span><br><span class="line">		root-&gt;flag &#x3D; 1;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	if((root-&gt;flag &#x3D;&#x3D; 1)&amp;&amp;(root-&gt;v!&#x3D;temp))&#123;</span><br><span class="line">		if(root-&gt;v&gt;temp) return check(root-&gt;l,temp);</span><br><span class="line">		else return check(root-&gt;r,temp);</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">void reset(node* root)&#123;</span><br><span class="line">	if(!root) return;</span><br><span class="line">	root-&gt;flag &#x3D; 0;</span><br><span class="line">	reset(root-&gt;l);</span><br><span class="line">	reset(root-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	 while(true)&#123;</span><br><span class="line">	 	scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">	 	if(N&#x3D;&#x3D;0) break;</span><br><span class="line">	 	scanf(&quot;%d&quot;,&amp;L);</span><br><span class="line">	 	node* root &#x3D; NULL; </span><br><span class="line">	 	for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">	 		int temp;</span><br><span class="line">	 		scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">	 		root &#x3D; addNode(temp,root);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;0;i&lt;L;i++)&#123;</span><br><span class="line">			int temp,flag &#x3D; 1,flag2 &#x3D; 1;</span><br><span class="line">			for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">				flag &#x3D; check(root,temp);</span><br><span class="line">				if((flag &#x3D;&#x3D; 0)&amp;&amp;(flag2 &#x3D;&#x3D; 1))&#123;</span><br><span class="line">					cout&lt;&lt;&quot;No\n&quot;;</span><br><span class="line">					flag &#x3D; 0;</span><br><span class="line">					flag2 &#x3D; 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flag2 &#x3D;&#x3D; 1) cout&lt;&lt;&quot;Yes\n&quot;;</span><br><span class="line">			reset(root);</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的操作集</title>
    <url>/2020/06/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86/</url>
    <content><![CDATA[<p>6-12 二叉搜索树的操作集 (30分)</p>
<p>本题要求实现给定二叉搜索树的5种常用操作。</p>
<h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>BinTree</code>结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li>
<li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li>
<li>函数<code>Find</code>在二叉搜索树<code>BST</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li>
<li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li>
<li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li>
</ul>
<h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">( BinTree BT )</span></span>; <span class="comment">/* 先序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">( BinTree BT )</span></span>;  <span class="comment">/* 中序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="keyword">int</span> N, i;</span><br><span class="line"></span><br><span class="line">    BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        BST = Insert(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Preorder:"</span>); PreorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    MinP = FindMin(BST);</span><br><span class="line">    MaxP = FindMax(BST);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        Tmp = Find(BST, X);</span><br><span class="line">        <span class="keyword">if</span> (Tmp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">"%d is not found\n"</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is found\n"</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MinP) <span class="built_in">printf</span>(<span class="string">"%d is the smallest key\n"</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MaxP) <span class="built_in">printf</span>(<span class="string">"%d is the largest key\n"</span>, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        BST = Delete(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Inorder:"</span>); InorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>

<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">5 8 6 2 4 1 0 10 9 7</span><br><span class="line">5</span><br><span class="line">6 3 10 0 5</span><br><span class="line">5</span><br><span class="line">5 7 0 10 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preorder: 5 2 1 0 4 8 6 7 10 9</span><br><span class="line">6 is found</span><br><span class="line">3 is not found</span><br><span class="line">10 is found</span><br><span class="line">10 is the largest key</span><br><span class="line">0 is found</span><br><span class="line">0 is the smallest key</span><br><span class="line">5 is found</span><br><span class="line">Not Found</span><br><span class="line">Inorder: 1 2 4 6 8 9</span><br></pre></td></tr></table></figure>



<h3 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BinTree Insert( BinTree BST, ElementType X )&#123;</span><br><span class="line">	if(!BST)&#123;</span><br><span class="line">		BST &#x3D; (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">		BST-&gt;Data &#x3D; X;</span><br><span class="line">		BST-&gt;Left &#x3D; NULL;</span><br><span class="line">		BST-&gt;Right &#x3D; NULL;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		if(X&lt;BST-&gt;Data) BST-&gt;Left &#x3D; Insert(BST-&gt;Left,X); 	&#x2F;&#x2F;插入操作需要先找到插入位置，但函数一到达插入位置， </span><br><span class="line">		else BST-&gt;Right &#x3D; Insert(BST-&gt;Right,X);				&#x2F;&#x2F;就无法记住父亲节点位置，所以采用递归方式，返回插入位置的地址给上一层。 </span><br><span class="line">	&#125;</span><br><span class="line">	return BST;</span><br><span class="line">&#125;</span><br><span class="line">Position Find( BinTree BST, ElementType X )&#123;</span><br><span class="line">	if(!BST)&#123;</span><br><span class="line">		return BST;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		if(BST-&gt;Data &#x3D;&#x3D; X) return BST;</span><br><span class="line">		else if(BST-&gt;Data &lt; X) Find(BST-&gt;Right,X);</span><br><span class="line">		else Find(BST-&gt;Left,X);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Position FindMin( BinTree BST )&#123;</span><br><span class="line">	if(!BST) return BST;</span><br><span class="line">	if(!BST-&gt;Left) return BST;</span><br><span class="line">	else FindMin(BST-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line">Position FindMax( BinTree BST )&#123;</span><br><span class="line">	if(!BST) return BST;</span><br><span class="line">	if(!BST-&gt;Right) return BST;</span><br><span class="line">	else FindMax(BST-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line">BinTree Delete( BinTree BST, ElementType X )&#123;</span><br><span class="line">	if(!BST)&#123;</span><br><span class="line">		printf(&quot;Not Found\n&quot;);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		if(BST-&gt;Data &lt; X)&#123;</span><br><span class="line">			BST-&gt;Right &#x3D; Delete(BST-&gt;Right,X);</span><br><span class="line">		&#125;else if(BST-&gt;Data &gt; X)&#123;</span><br><span class="line">			BST-&gt;Left &#x3D; Delete(BST-&gt;Left,X);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			BinTree temp &#x3D; BST;</span><br><span class="line">			if(!BST-&gt;Left)&#123;</span><br><span class="line">				BST &#x3D; BST-&gt;Right;</span><br><span class="line">				free(temp);</span><br><span class="line">			&#125;else if(!BST-&gt;Right)&#123;</span><br><span class="line">				BST &#x3D; BST-&gt;Left;</span><br><span class="line">				free(temp);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				temp &#x3D; FindMin(BST-&gt;Right);</span><br><span class="line">				BST-&gt;Data &#x3D; temp-&gt;Data;</span><br><span class="line">				BST-&gt;Right &#x3D; Delete(BST-&gt;Right,BST-&gt;Data);</span><br><span class="line">			&#125; 	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	 return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>AVL树</title>
    <url>/2020/06/07/AVL%E6%A0%91/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​    AVL树是一种特殊的二叉查找树，但对AVL树来说，左子树和右子树的高度差的绝对值不超过1，高度之差被称为<strong><em>平衡因子</em></strong>。</p>
<p>​    AVL树能使每次插入元素后树高度仍能保持O（logn）的级别（也就是查找时间也为O(logn)）</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void search(node* root,int x)&#123;</span><br><span class="line">	if(root &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">		printf(&quot;search failed\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(x &#x3D;&#x3D; root-&gt;data)&#123;</span><br><span class="line">		printf(&quot;success&quot;);</span><br><span class="line">	&#125;else if(x &lt; root-&gt;data)&#123;</span><br><span class="line">		search(root-&gt;left,x)</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		search(root-&gt;right,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void L(node* &amp;root)&#123;</span><br><span class="line">	node* temp &#x3D; root-&gt;rchild;</span><br><span class="line">	root-&gt;rchild &#x3D; temp-&gt;lchild;</span><br><span class="line">	temp-&gt;lchild &#x3D; root;</span><br><span class="line">	root &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void R(node* &amp;root)&#123;</span><br><span class="line">	node* temp &#x3D; root-&gt;lchild;</span><br><span class="line">	root-&gt;lchild &#x3D; temp-&gt;rchild;</span><br><span class="line">	tmep-&gt;rchild &#x3D; root;</span><br><span class="line">	root &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LL型旋转"><a href="#LL型旋转" class="headerlink" title="LL型旋转"></a>LL型旋转</h3><p><a href="/1.png">LL</a></p>
<p>4,6看成整体，以1为根右旋</p>
<h3 id="LR型旋转"><a href="#LR型旋转" class="headerlink" title="LR型旋转"></a>LR型旋转</h3><p><a href="/2.png">LR</a></p>
<p>先以2为根左旋，旋转结束后变为LL型，再以1节点为跟右旋。</p>
<h3 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">	int v,height;</span><br><span class="line">	node* lchild,node* rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node* newNode(int v)&#123;</span><br><span class="line">	node* Node &#x3D; new node;</span><br><span class="line">	Node-&gt;v &#x3D; v;</span><br><span class="line">	Node-&gt;height &#x3D; 1;</span><br><span class="line">	Node-&gt;lchild &#x3D; Node-&gt;rchild &#x3D; NULL;</span><br><span class="line">	return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getHeight(node* root)&#123;</span><br><span class="line">	if(root &#x3D;&#x3D; NULL) return 0;</span><br><span class="line">	return root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getBalanceFactor(node* root)&#123;</span><br><span class="line">	return getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void updateHeight(node* root)&#123;</span><br><span class="line">	root-&gt;hegith &#x3D; max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(node* &amp;root,int v)&#123;</span><br><span class="line">	if(root &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">		root &#x3D; newNode(v);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(v&lt;root-&gt;v)&#123;</span><br><span class="line">		insert(root-&gt;lchild,v);</span><br><span class="line">		uodateHeight(root);</span><br><span class="line">		if(getBalanceFactor(root) &#x3D;&#x3D; 2)&#123;</span><br><span class="line">			if(getBalanceFactor(root-&gt;lchild) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">				R(root);</span><br><span class="line">			&#125;else if(getBalanceFactor(root-&gt;lchild) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">				L(root-&gt;lchild);</span><br><span class="line">				R(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		insert(root-&gt;child,v);</span><br><span class="line">		updateHeight(root);</span><br><span class="line">		if(getBalanceFactor(root) &#x3D;&#x3D; -2)&#123;</span><br><span class="line">			if(getBalanceFactor(root) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">				L(root);</span><br><span class="line">			&#125;else if(getBalanceFactor(root-&gt;rchild) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">				R(root-&gt;rchild);</span><br><span class="line">				L(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AVL树的建立"><a href="#AVL树的建立" class="headerlink" title="AVL树的建立"></a>AVL树的建立</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node* Create(int data[],int n)&#123;</span><br><span class="line">	node* root &#x3D; NULL;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">		insert(root,data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title>List Leaves</title>
    <url>/2020/06/02/List-Leaves/</url>
    <content><![CDATA[<p>Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to <em>N</em>−1. Then <em>N</em> lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">1 -</span><br><span class="line">- -</span><br><span class="line">0 -</span><br><span class="line">2 7</span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line">5 -</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1 5</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">	int b,c;</span><br><span class="line">&#125;;</span><br><span class="line">node n[12];</span><br><span class="line">int check[12];</span><br><span class="line">int find(node n[])&#123;</span><br><span class="line">	int N,i;</span><br><span class="line">	char l,r;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">	getchar();</span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">		scanf(&quot;%c %c&quot;,&amp;l,&amp;r);</span><br><span class="line">		getchar();</span><br><span class="line">		if(l!&#x3D;&#39;-&#39;)&#123;</span><br><span class="line">			n[i].b &#x3D; l-&#39;0&#39;;</span><br><span class="line">			check[n[i].b] &#x3D; 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			n[i].b &#x3D; -1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(r!&#x3D;&#39;-&#39;)&#123;</span><br><span class="line">			n[i].c &#x3D; r-&#39;0&#39;;</span><br><span class="line">			check[n[i].c] &#x3D; 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			n[i].c &#x3D; -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">		if(check[i] &#x3D;&#x3D; 0)</span><br><span class="line">			break;</span><br><span class="line">	return i;</span><br><span class="line">&#125; </span><br><span class="line">int flag &#x3D; 0;</span><br><span class="line">void print(int root)&#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	int flag &#x3D; 0;</span><br><span class="line">	if(root!&#x3D;-1)&#123;</span><br><span class="line">		q.push(root);</span><br><span class="line">		while(!q.empty())&#123;</span><br><span class="line">			int top &#x3D; q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			if((n[top].b &#x3D;&#x3D; -1)&amp;&amp;(n[top].c &#x3D;&#x3D; -1))&#123;</span><br><span class="line">				if(flag)</span><br><span class="line">					printf(&quot; %d&quot;,top);</span><br><span class="line">				else&#123;</span><br><span class="line">					printf(&quot;%d&quot;,top);</span><br><span class="line">					flag &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				if(n[top].b!&#x3D;-1)</span><br><span class="line">					q.push(n[top].b);</span><br><span class="line">				if(n[top].c!&#x3D;-1)</span><br><span class="line">					q.push(n[top].c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int root &#x3D; find(n); </span><br><span class="line">	print(root);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>层级遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>Pop Sequence</title>
    <url>/2020/05/28/Pop-Sequence/</url>
    <content><![CDATA[<p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>

<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944" target="_blank" rel="noopener">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int M,N,K;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;M&gt;&gt;N&gt;&gt;K;</span><br><span class="line">	vector&lt;int&gt; v(N+1);</span><br><span class="line">	while(K--)&#123;</span><br><span class="line">		stack&lt;int&gt; s;</span><br><span class="line">		for(int i &#x3D; 1;i &lt;&#x3D; N;i++)</span><br><span class="line">			cin&gt;&gt;v[i];</span><br><span class="line">		int current &#x3D; 1;</span><br><span class="line">		for(int i &#x3D; 1;i &lt;&#x3D; N;i++)&#123;</span><br><span class="line">			s.push(i);</span><br><span class="line">			if(s.size()&gt;M) break;</span><br><span class="line">			while(!s.empty()&amp;&amp;s.top()&#x3D;&#x3D;v[current])&#123;</span><br><span class="line">				s.pop();</span><br><span class="line">				current++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(current &#x3D;&#x3D; N+1) cout&lt;&lt;&quot;YES\n&quot;;</span><br><span class="line">		else cout&lt;&lt;&quot;NO\n&quot;;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>current确定当前扫描到第几个位置。</p>
<p>栈只需要从1顺序进，每进一个就while循环，判断栈顶和current当前位置，只要对上了，current往后走，栈不停弹出。</p>
<p>判断成功的方法：current最后到了N+1，也就是前面都通过检验。</p>
<p>这里就相当于一个证明题：对于一个命题，错与对哪个好证明，就证明哪个，最后用反证法。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Reversing Linked List</title>
    <url>/2020/05/28/Reversing-Linked-List/</url>
    <content><![CDATA[<p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure>

<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure>

<p><a href="https://pintia.cn/problem-sets/1211841066264109056/problems/1231458941036285954" target="_blank" rel="noopener">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int temp,data[100005],nex[100005],lis[100005],ans[100005];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int first,k,n,sum &#x3D; 0;</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		cin&gt;&gt;data[temp]&gt;&gt;nex[temp];</span><br><span class="line">	&#125;</span><br><span class="line">	while(first!&#x3D;-1)&#123;</span><br><span class="line">		lis[sum++] &#x3D; first;</span><br><span class="line">		first &#x3D; nex[first];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i &#x3D; 0;i&lt;sum;i++) ans[i] &#x3D; lis[i];</span><br><span class="line">	for(int i &#x3D; 0;i&lt;(sum-sum%k);i++)&#123;&#x2F;&#x2F;反转范围为前k的整数倍,后面剩余部分不动</span><br><span class="line">		ans[i] &#x3D; lis[i&#x2F;k*k+k-1-i%k];&#x2F;&#x2F;i&#x2F;k*k确定第几组反转的起步位置，k-1-i%k控制组内的顺序移动</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;sum-1;i++)</span><br><span class="line">		printf(&quot;%05d %d %05d\n&quot;,ans[i],data[ans[i]],ans[i+1]);</span><br><span class="line">	printf(&quot;%05d %d -1\n&quot;,ans[sum-1],data[ans[sum-1]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里采用数组模拟链表</p>
<p>对于节点元素：value,next；</p>
<p>分别用两个数组模拟,数组下标为节点地址，只要有节点地址，就能通过访问两个数组获取相应的值；</p>
<p>对于翻转，只要关注节点排列的顺序就行了。</p>
<p>lis数组存储链表上节点的顺序依次地址。</p>
<p>ans来存储lis按照一定k值重写排列的地址。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>一元多项式的乘法与加法运算</title>
    <url>/2020/05/28/%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>设计函数分别求两个一元多项式的乘积与和。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure>



<p><a href="https://pintia.cn/problem-sets/434/problems/5865" target="_blank" rel="noopener">链接</a></p>
<p>解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">	int co;</span><br><span class="line">	int ex;</span><br><span class="line">	node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void attach(node** rear,int a,int b)&#123;</span><br><span class="line">	node* temp &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">	temp-&gt;co &#x3D; a;</span><br><span class="line">	temp-&gt;ex &#x3D; b;</span><br><span class="line">	temp-&gt;next &#x3D; NULL;</span><br><span class="line">	(*rear)-&gt;next &#x3D; temp;</span><br><span class="line">	(*rear) &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">node* read()&#123;</span><br><span class="line">	int c;</span><br><span class="line">	cin&gt;&gt;c;</span><br><span class="line">	node* p &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">	p-&gt;next &#x3D; NULL;</span><br><span class="line">	node* rear &#x3D; p;</span><br><span class="line">	while(c--)&#123;</span><br><span class="line">		int a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		attach(&amp;rear,a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	node* t &#x3D; p-&gt;next;</span><br><span class="line">	free(p);</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">node* plu(node* a,node* b)&#123;</span><br><span class="line">	node* p &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">	node* rear &#x3D; p;</span><br><span class="line">	p-&gt;next &#x3D; NULL;</span><br><span class="line">	while(a&amp;&amp;b)&#123;</span><br><span class="line">		if(a-&gt;ex&gt;b-&gt;ex)&#123;</span><br><span class="line">			attach(&amp;rear,a-&gt;co,a-&gt;ex);</span><br><span class="line">			a &#x3D; a-&gt;next;</span><br><span class="line">		&#125;else if(a-&gt;ex&lt;b-&gt;ex)&#123;</span><br><span class="line">			attach(&amp;rear,b-&gt;co,b-&gt;ex);</span><br><span class="line">			b &#x3D; b-&gt;next;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			if(a-&gt;co+b-&gt;co !&#x3D; 0)&#123;</span><br><span class="line">				attach(&amp;rear,a-&gt;co+b-&gt;co,a-&gt;ex);	</span><br><span class="line">			&#125; </span><br><span class="line">			a &#x3D; a-&gt;next;</span><br><span class="line">			b &#x3D; b-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(a)&#123;</span><br><span class="line">		attach(&amp;rear,a-&gt;co,a-&gt;ex);</span><br><span class="line">		a &#x3D; a-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	while(b)&#123;</span><br><span class="line">		attach(&amp;rear,b-&gt;co,b-&gt;ex);</span><br><span class="line">		b &#x3D; b-&gt;next; </span><br><span class="line">	&#125; </span><br><span class="line">	node* t &#x3D; p-&gt;next;</span><br><span class="line">	free(p);</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">void print(node* a)&#123;</span><br><span class="line">	if(!a) printf(&quot;0 0&quot;);</span><br><span class="line">	else&#123;</span><br><span class="line">		bool flag &#x3D; false;</span><br><span class="line">		while(a)&#123;</span><br><span class="line">			if(!flag)&#123;</span><br><span class="line">				cout&lt;&lt;a-&gt;co&lt;&lt;&quot; &quot;&lt;&lt;a-&gt;ex;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				cout&lt;&lt;&quot; &quot;&lt;&lt;a-&gt;co&lt;&lt;&quot; &quot;&lt;&lt;a-&gt;ex;</span><br><span class="line">			&#125;</span><br><span class="line">			a &#x3D; a-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">node* muti(node* a,node* b)&#123;</span><br><span class="line">	node* p &#x3D; NULL;</span><br><span class="line">	if(!a||!b) return NULL;</span><br><span class="line">	while(a)&#123;</span><br><span class="line">		node* temp &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">		temp-&gt;next &#x3D; NULL;</span><br><span class="line">		node* bp &#x3D; b;</span><br><span class="line">		node* rear &#x3D; temp; </span><br><span class="line">		while(bp)&#123;</span><br><span class="line">			attach(&amp;rear,a-&gt;co*bp-&gt;co,a-&gt;ex+bp-&gt;ex);</span><br><span class="line">			bp &#x3D; bp-&gt;next;</span><br><span class="line">		&#125; </span><br><span class="line">		node* t &#x3D; temp-&gt;next;</span><br><span class="line">		free(temp);</span><br><span class="line">		p &#x3D; plu(p,t);</span><br><span class="line">		a &#x3D; a-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	node* a &#x3D; read();</span><br><span class="line">	node* b &#x3D; read();</span><br><span class="line">	node* c &#x3D; muti(a,b);</span><br><span class="line">	print(c);</span><br><span class="line">	cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">	c &#x3D; plu(a,b);</span><br><span class="line">	print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>1、在用malloc创建节点时，不要忘了对里面的指针初始化。</p>
<p>2、attach函数参数为node**，这是指针的指针，目的是更改指向节点的指针的值（需要不断更改rear的位置）</p>
<p>node** a（b的内存地址）</p>
<p>-&gt;node* b(c的内存地址)</p>
<p>-&gt;node c</p>
<p>更改c的属性值： b-&gt;value = xxx;（*a）-&gt;value = xxx;</p>
<p>更改b的值： (*a) = xxx;</p>
<p>3、注意代码的可重用性，这里的乘法就可以用到加法。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>Maximum Subsequence Sum</title>
    <url>/2020/05/26/Maximum-Subsequence-Sum/</url>
    <content><![CDATA[<p><a href="https://pintia.cn/problem-sets/1211841066264109056/problems/1211848231062290433" target="_blank" rel="noopener">链接</a></p>
<p>Given a sequence of <em>K</em> integers { <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }. A continuous subsequence is defined to be { <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>
<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure>



<p>解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int k,arr[100000];</span><br><span class="line">int cmax,rmax &#x3D; -1;</span><br><span class="line">int l,r,temp;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    for(int i &#x3D; 0;i&lt;k;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 0;i&lt;k;i++)&#123;</span><br><span class="line">        cmax+&#x3D;arr[i];</span><br><span class="line">        if(rmax&lt;cmax)&#123;</span><br><span class="line">            r &#x3D; i;</span><br><span class="line">            l &#x3D; temp;</span><br><span class="line">            rmax &#x3D; cmax;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cmax&lt;0)&#123;</span><br><span class="line">            cmax &#x3D; 0;</span><br><span class="line">            temp &#x3D; i+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(rmax &lt; 0 )</span><br><span class="line">        cout &lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;arr[0]&lt;&lt;&quot; &quot;&lt;&lt;arr[k-1];</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt; rmax&lt;&lt;&quot; &quot;&lt;&lt;arr[l]&lt;&lt;&quot; &quot;&lt;&lt;arr[r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、设置左边界的时机，需要通过temp临时存储，当cmax&lt;0,可以肯定的是左边界在后面一个，但此时不能直接修改l，例如：3 -4 -5，直接修改会产生错误。所以需要在cmax&gt;rmax时修改。</p>
<p>2、rmax初值需要设置为负数，如果默认0，例如 0,0,0,0。结果会输出第一个和最后一个，导致错误。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
        <tag>动态规划，最⼤大连续⼦子序列列和</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.5.13</title>
    <url>/2020/05/13/2020-5-13/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
  </entry>
  <entry>
    <title>王阳明心学及其现代意义</title>
    <url>/2020/05/09/%E7%8E%8B%E9%98%B3%E6%98%8E%E5%BF%83%E5%AD%A6%E5%8F%8A%E5%85%B6%E7%8E%B0%E4%BB%A3%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>王阳明心学就是中国人生哲学的最高成果。</p>
<p>在自己的成长过程中形成自己的精神家园。</p>
<p>安心立命。</p>
<p>人生富贵穷通，莫非命也。</p>
<p>生活的阅历积累道一定程度，每个人都有自己的命。</p>
<p>出生于怎样家庭，怎样父母成了我，这些事情不容我选择。</p>
<p>孟子说：人生总要有所求</p>
<p>求有两种：</p>
<p>求则得之，舍则失之；是求有益于得也，求在我者也。</p>
<p>求之有道，得之有命，是求无益于得也，求在外者也。</p>
<p>为何要重温阳明心学？</p>
<p>今日之中国，重欲汹汹，各种的欲望。</p>
<p>改革开放30年，中华名族形成这样一个民风：各释其能，各谋其力，纷争交给法律，前途交给偶然。</p>
<p>当然这无可厚非。</p>
<p>但这民风伴随重功利，清道义。名族将内不能安，外不能立。</p>
<p>GDP增长极快，有大量资本。一个名族不能因为货币，成为一个名族安身立命之根本。</p>
<p>社会信任的普遍危机是当代中国最基本的品质。</p>
<p>什么是心？</p>
<p>烦恼来自于心</p>
<p>能生出烦恼的心最难对付。</p>
<p>孔子论语中说：“不仁者（心没有安顿的人），不可以久处约（贫贱的生活处境），不可以长处乐（富贵的生活环境）。</p>
<p>我们有无限心，人在每一个瞬间筹划着未来，这是我们心得无限面，心超越事实，在筹划不存在的未来。烦恼与精彩都从中来。</p>
<p>无限心无法安顿在有限事物上。</p>
<p>如何安顿?</p>
<p>第一步 处世（超越现实世界）</p>
<p>第二步 入世</p>
<p>以出世的精神做入世的事情</p>
<p>中国哲学的境界有三条出世的路</p>
<p>儒：无所为而为</p>
<p>没有失败的人生，做一件事情就为了自己的价值</p>
<p>知己不可为而为之。</p>
<p>道：无为而无不为</p>
<p>人的幸福来自天，苦恼来自自己。</p>
<p>不为：不造作的事情</p>
<p>为道日损，损之又损。</p>
<p>生非贵之，所能存。生非爱之，所能厚。</p>
<p>了解天道，就是减去人为的东西。顺应去做。</p>
<p>做减法的方法在老庄的著作里。</p>
<p>佛家：无心而为</p>
<p>认真做，不求结果，除人心，不除事。</p>
<p>中国哲学就是人生哲学，如何安排最难安排的生命?</p>
<p>欧洲基督教</p>
<p>阿拉伯伊斯兰教</p>
<p>这些地区的出世路为宗教</p>
<p>生有涯，知无涯，以有涯随无涯，殆己！</p>
<p>什么是心学?</p>
<p>孟子：善端（根源）</p>
<p>孔子论道为仁</p>
<p>荀子：生物来自本能，人生来就恶。</p>
<p>孟子：避免利益纠纷而有道德，避免社会解体。</p>
<p>荀子认为智力高于动物，人发明道德。</p>
<p>孟子认为道德来自于心</p>
<p>恻隐</p>
<p>羞恶</p>
<p>辞让</p>
<p>是非</p>
<p>heart 生物学</p>
<p>mind 心理学</p>
<p>GEMUTE</p>
<p>良知乃是天理昭明灵觉处，故良知即是天理。</p>
<p>“心即理”（阳明学第一命题）</p>
<p>万物皆备于我，反心而诚善莫大焉。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学导论第5课</title>
    <url>/2020/05/03/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E7%AC%AC5%E8%AF%BE/</url>
    <content><![CDATA[<p>一个名族的思想境界如果不能提升，就没办法寻找真理，理解面临困境的根源。</p>
<p>哲学上的自由，是一种能力来终止自然规律在我们身上的作用。</p>
<p>荀子试图对道德现象作科学的解释。</p>
<p>法律的前提，每个人都有责任能力，责任能力对自然规律有一种超越的能力（超越生物性），这种认定必须是形而上学的假定。</p>
<p>理性有两种含义：</p>
<p>1、科学范畴，选择最优方式，避免利益冲突（understanding）</p>
<p>2、一种绝对、无条件对事物认知的能力，用法在于实践，创建社会关系（reason）</p>
<p>建立社会关系的礼非知性（1）</p>
<p>人心有限：理性规律</p>
<p>人心无限：比如构造上帝</p>
<p>因为世界历史已经形成。资本生产方式本质是超越国界，掠夺别人的资源，要无穷无尽的资源，无尽无尽的市场。在这个历史背景下，宋明心学不能盛行（来不及转变）</p>
<p>宋明心学不能盛行原因之一：中国的政治发送巨大变化，取消宰相制度。中断了中国文人，天下关怀的现实可能性。</p>
<p>这样就不能实现名族生命实践的道统。后果就是清朝的腐败。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学导论第4课</title>
    <url>/2020/05/02/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E8%AF%BE/</url>
    <content><![CDATA[<p>一个名族文化生命衰弱需要其他名族的思想和智慧的启发。</p>
<p>古希腊晚期道德秩序败坏，社会混乱，从东方犹太思想进入古希腊世界，刺激了古希腊，为后来的基督教形成建立了基础，造成了后来的中世纪。</p>
<p>隋唐时期引入佛教的经典，慢慢吸收思想的养料，完成文化的自我拯救。</p>
<p>玄奘 唯识宗</p>
<p>虚无的思想（般若）</p>
<p>8识：眼、耳、鼻、舌、身</p>
<p>第6识：意识。统摄前五种感觉。</p>
<p>第7识：末那识。感性世界在流变，但对同一个东西，都存在一个小我，就是心。</p>
<p>第8识：阿赖耶识（藏识/种子识）。</p>
<p>孟子：万物皆备于我，反身而诚乐莫大焉。真理本在心中。（孟子为中国心学的萌芽）</p>
<p>心有4个善端 : 修过、是非、慈让、恻隐。</p>
<p>建立礼，礼就是道德规则。</p>
<p>为了符合个人利益，通过礼来正名分，为防止免于大家利益纷争。</p>
<p>前提是人性本恶。</p>
<p>这是荀子的思想。荀子讲的心是自然性nature</p>
<p>孟子讲心是人性</p>
<p>心乃是哲学题材，非脏器。</p>
<p>善恶是人的社会存在，人的社会存在根据在于心（非mind 心智）。</p>
<p>7识从8识种子库里来，8识是超越小我的大我。任何思维都在一个思维范畴里，在大我里。</p>
<p>就好比speak和language。</p>
<p>引入佛学后，挽救文化生命，重建了对真理的了解。</p>
<p>进入宋明儒学，迎来中国第二次思想高峰。</p>
<p>佛教中国化禅宗。</p>
<p>金刚经:应无所往，而生其心。</p>
<p>宋明儒学有两个流派：</p>
<p>程朱理学。通过佛教的启发建立一种形而上的哲学体系，把天理讲清楚，并遵守它，存天理，灭人欲。</p>
<p>陆王心学：进行反驳，认为程朱理学违背心学原则，真理在心之内。</p>
<p>陆象山讲：吾心即宇宙，宇宙便是吾心。此心非小我。</p>
<p>王阳明说：心外无物。（与康德西方的心学很像）</p>
<p>启蒙是指让道德成为个人的自律而不是外部伦理权威的威力。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学导论第3课</title>
    <url>/2020/04/30/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E7%AC%AC3%E8%AF%BE/</url>
    <content><![CDATA[<p>发现很多事情都是站在西方哲学概念体系来解释中方哲学概念体系。</p>
<p>中国人讲国家，是不是等同于西方的概念? 这需要哲学的考察。</p>
<p>名词就是名器。</p>
<p>对于中，国家是感性的，motherland。</p>
<p>对于西，真正公民具有独立人格，市民生活。政治国家为我服务。</p>
<p>中国思想不能发展出超验。</p>
<p>中国近传统精神：儒道互补。</p>
<p>道是儒的反面。对于文明和理想的目标，总有道家思想来消解儒家思想。</p>
<p>一方坚持执着，一方去掉执着。</p>
<p>儒家具有家国天下的情怀，伦理政治的思想。</p>
<p>对于官，首先是教化，树立道德榜样，然后才是利益纷争的摆明。</p>
<p>这与西方不同，对于中方，伦理政治是不分开的，而西方分开。</p>
<p>西方有一基调就是人都是自私的，所以需要政治制约，解决纷争。</p>
<p>中国几千年文明但却没有宗教。</p>
<p>西方哲学搞理论。中方哲学讲究为人与做学问统一，比如孔子。</p>
<p>通过道德榜样，通过修养成为圣贤，然后治理天下。这是中国哲学治理天下的前提。</p>
<p>然后这里有一个很大的缺陷，如果当官的人并不是圣贤，而是伪善的（乡愿，孔子云：“乡愿，德之贼也”）</p>
<p>从历史来讲，其实这种情况一直都是在循环。所以每一代文人都有忧患意识。</p>
<p>所谓上梁不正下梁歪，如果没有一个好的榜样，就会影响下面的人。</p>
<p>西方是一个制度，一个宗教。制度制约管理者，宗教教导普通人。这和中方不同。</p>
<p>所以历史上，康有为曾想把儒家变为宗教。</p>
<p>儒家的原则和目标，到家的自在奸猾。</p>
<p>老子的《道德经》从一个角度看就是一本权术书。</p>
<p>讲经又讲权，讲原则又讲权变。就是如今的高度原则性与高度灵活性的统一。</p>
<p>以权变经，圆滑是中国文化传统的一个特征，早就中国的国民性格。</p>
<p>我们在这样的文化环境成长，虽然没有读过儒道两加经典，但也是受影响了。</p>
<p>这是一种对理解这个世界基本的态度。</p>
<p>不能救市，就能隐匿，追求个人的自在去吧。</p>
<p>不把原则坚持到底，中华名族成为世界众多名族中，最呼吁和平的名族。</p>
<p>这里讲究内方外圆，处事圆滑，不锋芒毕露，执着放在内心。儒道互补。</p>
<p>圆滑，不会保持旺盛的创造力，和生命的理想。从历史上来看，中华名族也遇到很多危险。</p>
<p>中国思想基本进程</p>
<p>（1）百家争鸣</p>
<p>由夏商周三朝的生命实践，体会了非常多种道，这就是百家。这是道统为立，中国文化发展还没有统一方向。</p>
<p>（2）两汉道统确定</p>
<p>通过对道的体会制作名器</p>
<p>（3）魏晋时期</p>
<p>发现使用之后千疮百孔，导致该时期，放浪形骸，藐视礼教。魏晋时期跟随道家态度。</p>
<p>这是中国文化衰落的征兆。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis generator</title>
    <url>/2020/04/29/mybatis-generator/</url>
    <content><![CDATA[<p>使用mybatis generator来自动生成mapper和model。</p>
<p>发现自动生成的数据，应该是int却变为long，暂时不知道什么原因。</p>
<p>然后暂时解决方案如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table tableName&#x3D;&quot;question&quot; domainObjectName&#x3D;&quot;Question&quot;&gt;</span><br><span class="line">&lt;columnOverride column&#x3D;&quot;ID&quot; javaType&#x3D;&quot;java.lang.Integer&quot; jdbcType&#x3D;&quot;INTEGER&quot;&gt;&lt;&#x2F;columnOverride&gt;</span><br><span class="line">&lt;columnOverride column&#x3D;&quot;creator&quot; javaType&#x3D;&quot;java.lang.Integer&quot; jdbcType&#x3D;&quot;INTEGER&quot;&gt;&lt;&#x2F;columnOverride&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>





<p>这搞了挺久。。。出去散步<del>~</del></p>
]]></content>
      <categories>
        <category>mybatis generator</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Spring Boot</tag>
        <tag>mybatis generator</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学导论第2课</title>
    <url>/2020/04/29/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E7%AC%AC2%E8%AF%BE/</url>
    <content><![CDATA[<p>国民性与典章制度皆为器，是名族文化精神的载体。</p>
<h1 id="中西文化精神的根基差别"><a href="#中西文化精神的根基差别" class="headerlink" title="中西文化精神的根基差别"></a>中西文化精神的根基差别</h1><p>中西方都有着私有财产的历史。</p>
<p>司马迁写史记，有一篇叫货殖列传描述先秦商人。</p>
<p>古希腊就有着频繁商业活动。</p>
<h2 id="西方理解"><a href="#西方理解" class="headerlink" title="西方理解"></a>西方理解</h2><p>例如我有一块表，如何证明这块表属于我？</p>
<p>不是肉体器官占有了这块表，而是人格的存在，人格占有了外物。人格与物之间具有占有和被占有的关系。</p>
<p>人格是超感性存在，是超验，不在感性世界中。</p>
<p>当一位老者逝去，将遗产分给儿子时，这里就有着人格的存在。</p>
<p>也可看出法律也有形而上学原理。</p>
<p>钱本质上是智思体/意会体（noumenon，思想领会，人格真实比感性更真实），超感性，代表社会权利/</p>
<p>工程师、工人、资本家看机器各不相同。</p>
<p>上述都是康德阐发，可见私有财产和西方人格的存在联系到了一起。</p>
<h2 id="中方理解"><a href="#中方理解" class="headerlink" title="中方理解"></a>中方理解</h2><p>中国人要亲身感受，精神与肉体不缺分。</p>
<p>就好像中西方都有着灵魂的概念。</p>
<p>西方认为，人的肉体只会带来欲望，使得灵魂不存粹，当死去，进入天国可以与上帝一起，实现永恒的沉思。这里就构建了超越感性的世界。</p>
<p>中方认为死去，这辈子命不好，下辈子想要有一个好的开始。这里面具有感性。</p>
<p>中华名族还是讲究生命情感。</p>
<h1 id="感性能不能遵守超验规则的真实性？"><a href="#感性能不能遵守超验规则的真实性？" class="headerlink" title="感性能不能遵守超验规则的真实性？"></a>感性能不能遵守超验规则的真实性？</h1><p>规则是超验的。因为不是感性的，所有会感觉不自由。</p>
<p>例如一个学生高考离分数线差两分。</p>
<p>家长第一时间不会想说你差这个分数线两分，应该遵守这个规则。会想办法破坏规则。而是拿好贡品找菩萨或是谁谁谁帮忙。</p>
<p>对于没权没势的家庭会看着别人是否破坏规则，然后举报那个破坏规则的人。</p>
<p><strong><em>每一个名族的道统对于这个世界的领会都是不一样的。</em></strong></p>
<p>写到这里就觉得其实在这里从小所受教育其实受西方思想挺大的。从历史上讲，若中华名族的思想远播海外，那或许就是另一个局面了。</p>
<h1 id="中西方名族形成最初的智慧根源"><a href="#中西方名族形成最初的智慧根源" class="headerlink" title="中西方名族形成最初的智慧根源"></a>中西方名族形成最初的智慧根源</h1><p>名族形成最初的智慧的差异来自于最初路径的选择。</p>
<p>四个名族：中华名族（老子、孔子）、古希腊名族（柏拉图）、古印度（释迦摩尼）、古以色列</p>
<p>四大名族的思想开启了轴心时代。</p>
<p>思想不会新的，新的是指思潮。</p>
<h1 id="思想形成受最初受地理环境影响"><a href="#思想形成受最初受地理环境影响" class="headerlink" title="思想形成受最初受地理环境影响"></a>思想形成受最初受地理环境影响</h1><p>古希腊爱琴海，多岛屿，海上移民频繁。在同一个岛上会有不同部落。这里不能靠血缘关系，而是契约。但契约本身不可靠，所以在这之前就出现了原始宗教，通过诸神的伦理关系，将人与神产生关联，使得人间的契约神圣化。</p>
<p>religion 宗教-&gt;契约。</p>
<p>应中华民族生活位置是大陆，所以单靠学院关系，并不靠契约。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学导论第1课</title>
    <url>/2020/04/28/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E7%AC%AC1%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="何为哲学"><a href="#何为哲学" class="headerlink" title="何为哲学"></a>何为哲学</h1><p>哲学是论道学问。</p>
<p>道无法言说，而哲学就是研究无法言说的道。</p>
<h1 id="何为道"><a href="#何为道" class="headerlink" title="何为道"></a>何为道</h1><p>《周易》有云：“形而上者谓之道，形而下者谓之器”</p>
<p>形指的是感性，经验。</p>
<p>形而上指超越经验。</p>
<p>民族德社会典章制度是一种器（具体科学）。</p>
<p>举个例子：中国茶道所用工具是一种器，规则也是器。但一起体现了道。</p>
<p>无道就是没有文化生命，哲学论道就是把一个名族文化生命，发展方向德领会说出来。达到对文化生命德自觉这就是论道。</p>
<h1 id="道的领会不同"><a href="#道的领会不同" class="headerlink" title="道的领会不同"></a>道的领会不同</h1><p>中西方对道的领会不一样。因为名族不同。</p>
<p>西方讲究逻辑，区分了理性与非理性</p>
<p>中方没有区分，中华名族的哲学是以生命感受为基础。</p>
<p>西方哲学是范畴逻辑演绎。西方哲学是在超感性。<br>中国哲学是生命情感的体验，真理在生命情感的体验之中。</p>
<h1 id="哲学真理与科学真理有什么却别？"><a href="#哲学真理与科学真理有什么却别？" class="headerlink" title="哲学真理与科学真理有什么却别？"></a>哲学真理与科学真理有什么却别？</h1><p>科学真理无民族姓。</p>
<p>科学真理是对事物规律变化的描绘。非自发本身体现真理。</p>
<p>哲学真理里需要人的生命奋斗来体现。</p>
<p>哲学真理以民族生活实践为根基。</p>
<h1 id="哲学为何不能统一"><a href="#哲学为何不能统一" class="headerlink" title="哲学为何不能统一"></a>哲学为何不能统一</h1><p>中西方哲学都有真理的因素。了解真理然后需要实践。这是生命奋斗的体现，生命奋斗有名族性。</p>
<p>当开始实践时必定受当地规则制约。</p>
<p>从古到今出现危机时，都是由不同名族智慧的启发。</p>
<p>例如受到印度佛教启发后宋明中国思想第二次高潮。</p>
<p>欧洲没有犹太思想启发古希腊就没有欧洲中世纪。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>计划2</title>
    <url>/2020/04/28/%E8%AE%A1%E5%88%922/</url>
    <content><![CDATA[<p>论文修改交上去了。</p>
<p>29，30号。全力冲击，看看能做多少事。</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>计划1</title>
    <url>/2020/04/17/%E8%AE%A1%E5%88%921/</url>
    <content><![CDATA[<p>18号开始，7天。</p>
<p>冥想 15分钟</p>
<p>看专业之外的资料45分钟。</p>
<table>
<thead>
<tr>
<th>4.18</th>
<th>4.19</th>
<th>4.20</th>
<th>4.21</th>
<th>4.22</th>
<th>4.23</th>
<th>4.24</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.3.3</title>
    <url>/2020/03/03/2020-3-3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p>距离考研结束已经很久了，我想是时候写一篇日记作为总结了。</p>
<p>这一次考研过程中，由于数学考试过程中心态过于紧张，导致最后选择题忘记填上去，最后因单科线过不了而结束。现在想来还是挺难受的。数学考场上的紧张和几个夜晚的悲伤将那段时间的效用达到了顶峰。这次失败打断了未来的计划。</p>
<p>自己对于考研这件事情挺执着的，再加上这此失败的原因，因为会去二战。一开始很担心时间浪费了，然后今天下午跟老师做心理咨询的时候相通了，我想每个人的进度都是不一样的，对于整个人生来说，这一年又算得了什么呢?将这一年过得充实就行了。</p>
<p>zk，不能和你一起实现我们的梦想，真的挺遗憾的。回想起我们一起学习的日子，每天很晚从鄞州图书馆走出来，一边走过公园一边聊着各种话题，然后坐公交车离开，那段时间真正地改变了我们的人生。无论如何，后面也要加油啊。</p>
<hr>
<p>先这样吧。</p>
]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>《睡眠革命》</title>
    <url>/2020/02/26/%E3%80%8A%E7%9D%A1%E7%9C%A0%E9%9D%A9%E5%91%BD%E3%80%8B/</url>
    <content><![CDATA[<h1 id="了解昼夜节律"><a href="#了解昼夜节律" class="headerlink" title="了解昼夜节律"></a>了解昼夜节律</h1><p><img src="/2020/02/26/%E3%80%8A%E7%9D%A1%E7%9C%A0%E9%9D%A9%E5%91%BD%E3%80%8B/a.png" alt></p>
<p>1．走到户外！让⽇光调整你的⽣物钟，⽽不是人工光线。 </p>
<p>2．了解你的各项⾼峰和低⾕数值，监控那些会在你⾝上⾃然⽽然发⽣的变化。使⽤穿戴式健⾝追踪器进⾏测量。 </p>
<p>3．早上放慢速度。醒来之后⽴⻢陷⼊⼀团忙乱之中，早晚会毁了你的⾝体。睡眠质量和我们早上醒来之后的所作所为息息相 关。 </p>
<h1 id="了解睡眠类型"><a href="#了解睡眠类型" class="headerlink" title="了解睡眠类型"></a>了解睡眠类型</h1><p>谷歌 慕尼黑大学睡觉类型调查问卷。</p>
<h1 id="90分钟睡眠法"><a href="#90分钟睡眠法" class="headerlink" title="90分钟睡眠法"></a>90分钟睡眠法</h1><p>设定必须起床的最早时间，必须比上学、上班或做其他事情的时间早至少90分钟。</p>
<p>根据起床时间和90分钟时长的睡眠周期，回过头算入睡时间。</p>
<p> 以90分钟为一个周期，五个睡眠周期，早上七点半起来，就在午夜12点睡（需要提前躺下15分钟，取决于多久能睡着）。</p>
<p>如果错过理想入睡时间，就要下一个周期开始的时间。</p>
<p>最好合计每周的睡眠周期，一天为五个睡眠周期的话，那就将每周获得35个睡眠周期设为目标，不要被其中一天的糟糕睡眠影响，每周至少有4个晚上拥有完美的时间安排，就没问题了。</p>
<p>先从每晚5个睡眠周期开始，看看7天之后感觉如何，之后再做调整。</p>
<p>尽量避免连续三个晚上睡眠不足的情况发生。</p>
]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>集成MyBatis实现数据持久化保存</title>
    <url>/2020/02/13/%E9%9B%86%E6%88%90MyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%BF%9D%E5%AD%98/</url>
    <content><![CDATA[<h1 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h1><p>对应SpringBoot需要使用MyBatis-Spring-Boot-Starter来连接数据库，这里我使用H2数据库。</p>
<p>官方文档：</p>
<p><a href="http://www.h2database.com/html/main.html" target="_blank" rel="noopener">H2</a></p>
<p><a href="https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">MyBatis-Spring-Boot-Starter</a></p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.0.0.RC1/reference/htmlsingle/#boot-features-embedded-database-support" target="_blank" rel="noopener">配置文件文档</a></p>
<p>整体思路：</p>
<p>1、添加H2的maven依赖，这种数据库可以内置在里面，直接idea直接来创建数据库</p>
<p>2、MyBatis-Spring-Boot-Starter的maven依赖</p>
<p>3、写对应配置文件</p>
<p>4、写mapper</p>
<hr>
<a id="more"></a>

<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>对应配置文件添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:h2:路径</span><br><span class="line">spring.datasource.username&#x3D;用户名</span><br><span class="line">spring.datasource.password&#x3D;密码</span><br><span class="line">spring.datasource.driver-class-name&#x3D;org.h2.Driver</span><br></pre></td></tr></table></figure>



<h1 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h1><p>mapper:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> life.cj.community.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> life.cj.community.model.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user (name,account_id,token,gmt_create,gmt_modified) values (#&#123;name&#125;,#&#123;accountId&#125;,#&#123;token&#125;,#&#123;gmtCreate&#125;,#&#123;gmtModified&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="User数据结构"><a href="#User数据结构" class="headerlink" title="User数据结构"></a>User数据结构</h1><p>对于存储在服务器内部的数据结构，创建model包（区别与dto）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> life.cj.community.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String accountId;</span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line">    <span class="keyword">private</span> Long gmtCreate;</span><br><span class="line">    <span class="keyword">private</span> Long gmtModified;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountId</span><span class="params">(String accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountId = accountId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.token = token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getGmtCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gmtCreate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGmtCreate</span><span class="params">(Long gmtCreate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gmtCreate = gmtCreate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getGmtModified</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gmtModified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGmtModified</span><span class="params">(Long gmtModified)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gmtModified = gmtModified;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>H2</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>关于SpringBoot下的Session和Cookies</title>
    <url>/2020/02/13/%E5%85%B3%E4%BA%8ESpringBoot%E4%B8%8B%E7%9A%84session%E5%92%8CCookies/</url>
    <content><![CDATA[<p>简要描述：</p>
<p>服务器就是一家银行。</p>
<p>Session就是在该银行下开通的户口。</p>
<p>Cookies就是给该户口办理的银行卡。</p>
<p>用户可以拿着银行卡给该银行，银行可以凭借该银行卡找到该户口，知道了用户的身份。</p>
<p>给用户开户：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getSession().setAttribute(<span class="string">"user"</span>,githubUser);</span><br></pre></td></tr></table></figure>

<p>SpringBoot有这种机制，直接返回时，会自动加入对应的Cookies(银行卡)给用户，只是这是随机，不能指定。</p>
<hr>
<p>thymeleaf的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">th:if&#x3D;&quot;$&#123;session.user!&#x3D; null&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">th:text&#x3D;&quot;$&#123;session.user.getName()&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Cookies，Session</tag>
      </tags>
  </entry>
  <entry>
    <title>调用github接口实现登录功能</title>
    <url>/2020/02/12/%E8%B0%83%E7%94%A8github%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>本文讲述如何调用Github的接口，实现IT社区的登录功能。</p>
<a id="more"></a>

<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p><a href="https://developer.github.com/apps/building-oauth-apps/" target="_blank" rel="noopener">参考文档</a></p>
<h1 id="第一步：创建并注册OAuth-App（对应步骤1-2）"><a href="#第一步：创建并注册OAuth-App（对应步骤1-2）" class="headerlink" title="第一步：创建并注册OAuth App（对应步骤1,2）"></a>第一步：创建并注册OAuth App（对应步骤1,2）</h1><h1 id="第二部-用户授权将github上的个人信息给我的应用"><a href="#第二部-用户授权将github上的个人信息给我的应用" class="headerlink" title="第二部 : 用户授权将github上的个人信息给我的应用"></a>第二部 : 用户授权将github上的个人信息给我的应用</h1><p><img src="/2020/02/12/%E8%B0%83%E7%94%A8github%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/1.jpg" alt="流程图"></p>
<p><a href="https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/" target="_blank" rel="noopener">对应链接</a></p>
<h2 id="调用github的authorize接口"><a href="#调用github的authorize接口" class="headerlink" title="调用github的authorize接口"></a>调用github的authorize接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;authorize?client_id&#x3D;5f60243f732e3787b680&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8887&#x2F;callback&amp;scope&#x3D;user&amp;state&#x3D;1&quot;&gt;登录&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>上面向接口发送了三个参数</p>
<ul>
<li>client_id：这个就是步骤1注册时，提供给你的一个id，就相当于一个github给应用注册者的一个标识符</li>
<li>redirect_uri： 当授权完成时，返回的地址</li>
<li>scope：目前网站设计只要向github获取用户的个人信息就够了</li>
<li>state ：这里应该随机调入一个数，并在本地保存下来，后面github又会返回这个数，这主要是保护作用，防止第三方伪装。（这里为了简便，随便填入1）</li>
</ul>
<p>当github返回时，会另外携带<strong><em>code</em></strong>和<strong><em>state</em></strong>两个参数。</p>
<p>上述就完成了流程图中的1.2和1.2.1两个步骤。</p>
<h2 id="调用github的access-token接口"><a href="#调用github的access-token接口" class="headerlink" title="调用github的access_token接口"></a>调用github的access_token接口</h2><p>这里不是由用户发出，而是由服务器本身发出，所以写一个程序用来接受之前github发给我的两个参数，并再带上必要的参数，向github发出HTTP请求，然后获取access_token。</p>
<p>程序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> life.cj.community.Controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> life.cj.community.dto.AccessTokenDTO;</span><br><span class="line"><span class="keyword">import</span> life.cj.community.dto.GithubUser;</span><br><span class="line"><span class="keyword">import</span> life.cj.community.provider.GithubProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GithubProvider githubProvider; 	<span class="comment">//该类使用了OkHttp来发出请求，所以按程序组织习惯，该类放在了用Controller同级的Provider包中。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;github.client.id&#125;"</span>) 	<span class="comment">//作为此类数据，应当放在配置文件中</span></span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;github.client.secret&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String clientSecret;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;github.redirect.uri&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String redirectUri;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/callback"</span>)<span class="comment">//流程图中1.2.1步返回时，接受code和state两个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">callback</span><span class="params">(@RequestParam(name=<span class="string">"code"</span>)</span>String code,</span></span><br><span class="line"><span class="function">                           @<span class="title">RequestParam</span><span class="params">(name=<span class="string">"state"</span>)</span>String state)</span>&#123;</span><br><span class="line">        AccessTokenDTO accessTokenDTO = <span class="keyword">new</span> AccessTokenDTO();<span class="comment">//参数超过了2个，创AccessTokenDTO</span></span><br><span class="line">		accessTokenDTO.setClient_id(clientId);</span><br><span class="line">        accessTokenDTO.setClient_secret(clientSecret);</span><br><span class="line">        accessTokenDTO.setCode(code);</span><br><span class="line">        accessTokenDTO.setRedirect_uri(redirectUri);</span><br><span class="line">        accessTokenDTO.setState(state);</span><br><span class="line">        String aceessToken = githubProvider.getAceessToken(accessTokenDTO);</span><br><span class="line">        GithubUser user = githubProvider.getUser(aceessToken);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> life.cj.community.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> life.cj.community.dto.AccessTokenDTO;</span><br><span class="line"><span class="keyword">import</span> life.cj.community.dto.GithubUser;</span><br><span class="line"><span class="keyword">import</span> okhttp3.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GithubProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAceessToken</span><span class="params">(AccessTokenDTO accessTokenDTO)</span></span>&#123; <span class="comment">//获取1.2.1.2返回时的token</span></span><br><span class="line">        MediaType mediaType = MediaType.get(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        RequestBody body = RequestBody.create(mediaType, JSON.toJSONString(accessTokenDTO));</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"https://github.com/login/oauth/access_token"</span>)</span><br><span class="line">                .post(body)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">            String string = response.body().string();</span><br><span class="line">            String token = string.split(<span class="string">"&amp;"</span>)[<span class="number">0</span>].split(<span class="string">"="</span>)[<span class="number">1</span>];<span class="comment">//根据返回数据形式，获取信息</span></span><br><span class="line">            <span class="keyword">return</span>  token;</span><br><span class="line">            <span class="comment">//System.out.println(string);</span></span><br><span class="line">            <span class="comment">//return response.body().string();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成了1.2.1.1和1.2.1.2步骤</p>
<h2 id="调用github的user接口"><a href="#调用github的user接口" class="headerlink" title="调用github的user接口"></a>调用github的user接口</h2><p>获取user信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GithubUser <span class="title">getUser</span><span class="params">(String accessToken)</span></span>&#123;</span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"https://api.github.com/user?access_token="</span>+ accessToken)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Response response = client.newCall(request).execute();</span><br><span class="line">            String string = response.body().string();</span><br><span class="line">            <span class="comment">//使用fastjson将string的json对象解析成java的类对象</span></span><br><span class="line">            GithubUser githubUser = JSON.parseObject(string, GithubUser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">return</span> githubUser;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h1 id="附加工具"><a href="#附加工具" class="headerlink" title="附加工具"></a>附加工具</h1><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><h2 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h2><h2 id="mvnrepository"><a href="#mvnrepository" class="headerlink" title="mvnrepository"></a>mvnrepository</h2><h1 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h1><p>这种机制是如何设计出来的？</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">Oauth设计机制</a></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Github</tag>
        <tag>OAuth Apps</tag>
        <tag>Fastjson</tag>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone加速</title>
    <url>/2020/02/11/git-clone%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<p><strong><em>解决方案</em></strong></p>
<a id="more"></a>

<p>设置代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>取消代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<p>查看git全局设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>

<p>只对github</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080 </span><br><span class="line">git config --global --unset http.https:&#x2F;&#x2F;github.com.proxy</span><br></pre></td></tr></table></figure>



<p><strong><em>此方案前提需要代理</em></strong></p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/10/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>用了几天的时间把博客搭建起来了，此博客打算用于记录生活和学习过程。</p>
<p>此博客还需要不断完善，目前先总结一下搭建过程。</p>
<a id="more"></a>

<h1 id="1-域名和解析"><a href="#1-域名和解析" class="headerlink" title="1.域名和解析"></a>1.域名和解析</h1><h2 id="1-1-域名购买"><a href="#1-1-域名购买" class="headerlink" title="1.1 域名购买"></a>1.1 域名购买</h2><p>这是<a href="https://www.namesilo.com/" target="_blank" rel="noopener">域名购买地址</a>，这个域名提供商免费提供whois信息保护，所以就选择了这家。</p>
<h2 id="1-2-DNS解析设置"><a href="#1-2-DNS解析设置" class="headerlink" title="1.2 DNS解析设置"></a>1.2 DNS解析设置</h2><p>因为我的博客是同时部署到了Github pages和coding page，所以dns服务设置了阿里云的dns服务，将国内流量导向coding，将国外的流量导向github，同时将github和coding设置为强制开始https。<br><img src="/2020/02/10/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1.jpg" alt="域名解析"></p>
<h1 id="2-博客搭建"><a href="#2-博客搭建" class="headerlink" title="2.博客搭建"></a>2.博客搭建</h1><h2 id="2-1-环境配置"><a href="#2-1-环境配置" class="headerlink" title="2.1 环境配置"></a>2.1 环境配置</h2><p>本博客基于Hexo NexT主题，所以要先安装<a href="https://nodejs.org" target="_blank" rel="noopener">Node.js</a>和<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>。配置完成后，在git bash中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>hexo就安装完成了，接着在指定文件夹（blog搭建的地方）打开git bash输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>这样就搭建起了一个初始的blog，所以非常便捷。</p>
<h2 id="2-2-常用操作"><a href="#2-2-常用操作" class="headerlink" title="2.2 常用操作"></a>2.2 常用操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;&quot;&#x2F;&#x2F;新文章，&quot;&quot;里面是文章名&#96;</span><br><span class="line">hexo g&#x2F;&#x2F;生成静态文件&#96;</span><br><span class="line">hexo clean &#x2F;&#x2F;清除缓存</span><br><span class="line">hexo s&#x2F;&#x2F;启动服务器</span><br><span class="line">hexo d&#x2F;&#x2F;部署</span><br></pre></td></tr></table></figure>
<h2 id="2-3-更改博客主题"><a href="#2-3-更改博客主题" class="headerlink" title="2.3 更改博客主题"></a>2.3 更改博客主题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &lt;blog-path&gt;  #定位到 Hexo 博客目录</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next &#x2F;themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>然后修改博客根目录_config.yml配置文件,将theme对应的值改为nexT即可。</p>
<h2 id="2-4更多详细配置"><a href="#2-4更多详细配置" class="headerlink" title="2.4更多详细配置"></a>2.4更多详细配置</h2><p>可参看:</p>
<ul>
<li><p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo文档</a></p>
</li>
<li><p><a href="https://theme-next.org/docs/" target="_blank" rel="noopener">NexT文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
