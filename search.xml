<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>排序算法的比较</title>
    <url>/2020/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p><img src="https://pic2.zhimg.com/80/v2-88e47948380615b5adb6e7c313a916e5_1440w.jpg" alt="浙江大学-数据结构-算法排序的比较-10.4.1 - 知乎"></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序</title>
    <url>/2020/07/21/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>假设我们有N个学生，他们的成绩是0到100之间的整数（于是有M=101个不同的成绩值）。如何在线性时间内将学生按成绩排序?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Bucket_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">	count[]初始化;</span><br><span class="line">	while(读入1个学生成绩grade)</span><br><span class="line">		将该生插入count[grade]链表;</span><br><span class="line">	for(i&#x3D;0;i&lt;M;i++)&#123;</span><br><span class="line">		if(count[i])</span><br><span class="line">			输出整个count[i]链表;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;T(N,M) &#x3D; O(M+N)</span><br></pre></td></tr></table></figure>

<p>若M&gt;&gt;N该怎么办?</p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>假设我们有N=10个整数，而M = 1000个不同的值。还有可能在线性时间内排序吗？</p>
<p>这里M已经等于了，N的三次方了。</p>
<p>可以采用“次位优先”(Least Significant Dighit),T = O(P(N+B)) (P为趟数，B等价于上面的B)</p>
<h1 id="多关键字的排序"><a href="#多关键字的排序" class="headerlink" title="多关键字的排序"></a>多关键字的排序</h1><p>例如扑克牌排序问题，用主位优先（Most Signficant Digit）排序：为花色建4个桶。</p>
<p>在每个桶内分别排序，最后合并结果。</p>
<p>若用次位优先排序:为面值建13个桶，将结果合并，然后再为花色建四个桶。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>表排序</title>
    <url>/2020/07/19/%E8%A1%A8%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><ul>
<li>简介排序</li>
</ul>
<p>定义一个指针数组作为”表”（table)</p>
<p>如果要求按顺序输出，则输出：</p>
<p>A[table[0]],A[table[1]]…A[table[N]]</p>
<h1 id="物理排序"><a href="#物理排序" class="headerlink" title="物理排序"></a>物理排序</h1><p>N个数字的排序由由若干个独立的环组成</p>
<p>Temp = f</p>
<p>如何判断一个环的结束？</p>
<p>if（table[i]== i）(前提是每移动一本书，将就table改为A下标)</p>
<h1 id="物理排序复杂度分析"><a href="#物理排序复杂度分析" class="headerlink" title="物理排序复杂度分析"></a>物理排序复杂度分析</h1><p>最好情况：初始即有序</p>
<p>最坏情况：</p>
<ul>
<li>有N/2个环，每个环2个元素</li>
<li>需要3*（N/2）次元素移动(a-&gt;tmp,b-&gt;a,b-&gt;tmp）</li>
</ul>
<p>T = O(mN),m是每个A元素的复制时间</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/07/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>什么是快速排序算法的最好情况？</p>
<p>每次正好中分    T(N) = O(NlogN)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Quicksort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	pivot &#x3D; 从A[]中选一个主元;</span><br><span class="line">	将S &#x3D; &#123;A[]\pivot&#125; 分成2个独立子集:</span><br><span class="line">	A1 &#x3D; &#123;a∈S | a ≤ pivot&#125; 和 A2 &#x3D; &#123;a∈S | a ≥ pivot&#125;;</span><br><span class="line">	A[] &#x3D; Quicksort(A1,N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2,N2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="选主元"><a href="#选主元" class="headerlink" title="选主元"></a>选主元</h1><p>若选主元每次选择A[0]?</p>
<p>可能会产生下列情况：</p>
<p>1 2 3 4 5 6 … N</p>
<p>   2 3 4 5 6 … N</p>
<p>​      3 4 5 6 … N</p>
<p>T(N) = O(N) + T(N-1)</p>
<p>​        = O(N) + O(N-1) + T(N-2)</p>
<p>​        = O(N2)</p>
<p>这里距离一种选主元的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ElementType Median3	(ElementType A[],int Left,int Right)</span><br><span class="line">&#123;</span><br><span class="line">	int Center &#x3D; ([Left+Right)&#x2F;2;</span><br><span class="line">	if(A[Left] &gt; A[Center])</span><br><span class="line">		Swap(&amp;A[Left],&amp;A[Center]);</span><br><span class="line">	if(A[Left] &gt; A[Right])</span><br><span class="line">		Swap(&amp;A[Left],&amp;A[Right]);</span><br><span class="line">	if(A[Center]&gt;A[Right])</span><br><span class="line">		Swap(&amp;A[Center],&amp;A[Right]);</span><br><span class="line">	</span><br><span class="line">	Swap(&amp;A[Center],&amp;A[Right-1]);	&#x2F;&#x2F;将pivot藏到右边</span><br><span class="line">	&#x2F;&#x2F;接下来只需要考虑A[left+1]...A[Right-2]</span><br><span class="line">	return A[Right-1]	&#x2F;&#x2F;返回pivot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子集划分"><a href="#子集划分" class="headerlink" title="子集划分"></a>子集划分</h1><p>如果有元素正好等于pivot怎么办？</p>
<ul>
<li>停下来交换</li>
<li>不理它，继续移动指针</li>
</ul>
<p>第一种方式，优势是最后位置会被移动到靠中的位置，劣势是会有无用的交换</p>
<p>第二种方式，优势是不用进行无用交换，但劣势会移动到一端去。</p>
<p>综合起来，还是第一种方式比较好</p>
<h1 id="小规模数据的处理"><a href="#小规模数据的处理" class="headerlink" title="小规模数据的处理"></a>小规模数据的处理</h1><p>因为快速排序采用递归，所以需要不断压栈出栈，对于N不到100的情况，可能还不如插入排序快。</p>
<p>解决方案：当数据规模充分小，直接简单排序（比如插入排序)</p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Quicksort(ElementType A[],int Left,int Right)&#123;</span><br><span class="line">	if(Cutoff &lt;&#x3D; Right-Left)&#123;</span><br><span class="line">		Pivot &#x3D; Median3(A,Left,Right);</span><br><span class="line">		i &#x3D; Left; j &#x3D; Right-1;</span><br><span class="line">		for(;;)&#123;</span><br><span class="line">			while(A[++i]&lt;Pivot)&#123;&#125;</span><br><span class="line">			while(A[--j]&gt;Pivot)&#123;&#125;</span><br><span class="line">			if(i&lt;j)</span><br><span class="line">				Swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		Swap(&amp;A[i],&amp;A[Right-1]);</span><br><span class="line">		Quicksort(A,Left,i-1);</span><br><span class="line">		Quicksort(A,i+1,Right);</span><br><span class="line">	&#125;</span><br><span class="line">	else </span><br><span class="line">		Insertion_Sort(A+Left,Right-Left+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2020/07/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="核心-有序子列的归并"><a href="#核心-有序子列的归并" class="headerlink" title="核心: 有序子列的归并"></a>核心: 有序子列的归并</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;L &#x3D; 左边起始位置，R &#x3D; 右边起始位置，RightEnd &#x3D; 右边终点位置</span><br><span class="line">void Merge(ElementType A[],ElementType TmpA[],int L,int R,int RightEnd)</span><br><span class="line">&#123;</span><br><span class="line">	LeftEnd &#x3D; R-1;	&#x2F;&#x2F;左边终点位置</span><br><span class="line">	Tmp &#x3D; L;	&#x2F;&#x2F;存放数组的起始位置</span><br><span class="line">	NumElements &#x3D; RightEnd - L + 1;</span><br><span class="line">	while(L&lt;&#x3D;LeftEnd &amp;&amp; R&lt;&#x3D;RightEnd)&#123;</span><br><span class="line">		if(A[L]&lt;&#x3D;A[R]) TmpA[Tmp++] &#x3D; A[L++];</span><br><span class="line">		else	TmpA[Tmp++] &#x3D; A[R++];</span><br><span class="line">	&#125;</span><br><span class="line">	while(L&lt;&#x3D;LeftEnd)	TmpA[Tmp++] &#x3D; A[L++];</span><br><span class="line">	while(R&lt;&#x3D;RightEnd)	TmpA[Tmp++] &#x3D; A[R++];</span><br><span class="line">	for(i &#x3D; 0;i&lt;NumElements;i++,RightEnd--)</span><br><span class="line">		A[RightEnd]	&#x3D; TmpA[RightEnd];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><ul>
<li>分而治之</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;T(N) &#x3D; O(NlogN)</span><br><span class="line">void Msort(ElementType A[],ElementType TmpA[],int L,int RightEnd)&#123;</span><br><span class="line">	itn center;</span><br><span class="line">	if(L&lt;RightEnd)&#123;</span><br><span class="line">		center &#x3D; (L+RightEnd)&#x2F;2;</span><br><span class="line">		Msort(A,TmpA,L,center);</span><br><span class="line">		Msort(A,TmpA,center+1,RightEnd);</span><br><span class="line">		Merge(A,TmpA,L,Center+1,RightEnd);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>统一函数接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Merge_sort(ElementType A[],int N)&#123;</span><br><span class="line">	ElementType *TmpA;</span><br><span class="line">	TmpA &#x3D; malloc(N*sizeof(ElementType)));</span><br><span class="line">	if(Tmp!&#x3D;NULL)&#123;</span><br><span class="line">		MSort(A,TmpA,0,N-1);</span><br><span class="line">		free(TmpA);</span><br><span class="line">	&#125;</span><br><span class="line">	else Error(&quot;空间不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Merge_pass(ElementType A[],ElementType TmpA[],int N,int length)&#123;</span><br><span class="line">	&#x2F;&#x2F;length为当前有序子列的长度</span><br><span class="line">	for(i &#x3D; 0;i&lt;&#x3D;N-2*length;i+&#x3D;2*length)</span><br><span class="line">		merge1(A,TmpA,i,i+length,i+2*length-1);&#x2F;&#x2F;将A中元素归并到TmpA</span><br><span class="line">		if(i+length&lt;N)&#x2F;&#x2F;归并最后两个子序列</span><br><span class="line">			Merge1(A,TmpA,i,i+length,N-1);</span><br><span class="line">		else&#x2F;&#x2F;最后只剩1个子列</span><br><span class="line">			for(j &#x3D; i;j&lt;N;j++)	TmpA[j] &#x3D; A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge_sort(ElementType A[],int N)&#123;</span><br><span class="line">	ElementType *TmpA;</span><br><span class="line">	TmpA &#x3D; malloc(N*sizeof(ElementType));</span><br><span class="line">	if(TmpA !&#x3D; NULL)&#123;</span><br><span class="line">		while(length&lt;N)&#123;&#x2F;&#x2F;这个循环保证了最后TmpA的数据可以回A去</span><br><span class="line">			Merge_pass(A,TmpA,N,length);</span><br><span class="line">			length*&#x3D;2;</span><br><span class="line">			Merge_pass(TmpA,A,N,length);&#x2F;&#x2F;如果上一步length&gt;N也没关系，会倒回A</span><br><span class="line">			legth*&#x3D;2</span><br><span class="line">		&#125;</span><br><span class="line">		free(TmpA);</span><br><span class="line">	&#125;</span><br><span class="line">	else Error(&quot;空间不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该算法稳定，但是需要额外空间，不适用于内排序，适用于外排序。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp第二章:信息的表示和处理</title>
    <url>/2020/07/18/csapp%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h1><p>机器级程序将内存视为字节数组，每一个字节都有一个数字来标识，称它为地址（address）。在机器级程序的视角里，内存被抽象成了一个概念，名为虚拟内存(virtual address space)。而所有地址的集合被称为虚拟地址空间（virtual address space）。</p>
<h2 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h2><p>以16为基数，叫做十六进制（hexadecimal）数。在C语言中，以0x或0X开头的数字常量被认为是十六进制的值。</p>
<p><strong>十六进制转二进制的一个窍门是记住A,C和F对应的十进制的值。（10，12，15）</strong></p>
<h2 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h2><p>每台计算机都有字长（word size），虚拟地址都是用一个字来编码,因此对于字长为w位的机器，虚拟地址范围为0~2的w次-1；程序最多访问2的w次 的字节。</p>
<p>大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。</p>
<h2 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h2><p>对于跨越多字节的数据对象，必须建立两个规则：</p>
<ul>
<li>对象的地址是什么</li>
<li>内存中如何排列这些字节</li>
</ul>
<p>对象的地址为所使用字节中最小的地址</p>
<p>对于排列方式有两种：</p>
<ul>
<li>小端法(little endian)：最低有效字节在最前面</li>
<li>大端法(big endian)：最高有效字节在最前面</li>
</ul>
<p>看下面这段代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">typedef unsigned char *byte_pointer;</span><br><span class="line"></span><br><span class="line">void show_bytes(byte_pointer start,size_t len)&#123;</span><br><span class="line">	size_t i;</span><br><span class="line">	for(i &#x3D; 0;i&lt;len;i++)</span><br><span class="line">		printf(&quot;%.2x&quot;,start[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h2><p>C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都是以某个标准编码来表示，最常见的是ASCII字符码。注意：<strong>strlen()不计算字符结尾，且在使用ASCII码作为字符码的任何系统都得到相同的结果，与字节顺序和字大小规则无关。</strong></p>
<h2 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h2><p>对于指令的编码，因为机器类型、不同的操作系统等因素，会有不同编码规则，因此二进制代码不兼容。</p>
<h2 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h2><p>布尔代数是二元集合{0，1}基础上的定义。用来表示这些运算的符号是与C语言位级运算使用的符号相匹配的。</p>
<p>布尔运算 ~ 对应逻辑运算NOT</p>
<p>​                &amp; 对应逻辑运算AND</p>
<p>​                | 对应逻辑运算OR</p>
<p>​                ^ 对应逻辑运算异或</p>
<p>上面四个运算可以扩展到位向量的运算，位向量就是固定长度w，由0和1组成的串。</p>
<p>&amp;和|互相之间有分配律：a&amp;(b|c) = (a&amp;b)|(a&amp;c)，反之亦然。</p>
<p>位向量一个很有用的应用就是表示有限集合。布尔代数|和&amp;分别对应于集合的并和交哦，而~对应于集合的补。</p>
<h2 id="C语言中的位级运算"><a href="#C语言中的位级运算" class="headerlink" title="C语言中的位级运算"></a>C语言中的位级运算</h2><p>C语言中： ~ 对应逻辑运算NOT</p>
<p>​                &amp; 对应逻辑运算AND</p>
<p>​                | 对应逻辑运算OR</p>
<p>​                ^ 对应逻辑运算异或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个有意思的交换函数，运用a^a &#x3D; 0 这一性质</span><br><span class="line">void inplace_swap(int *x,int *y)&#123;</span><br><span class="line">	*y &#x3D; *x^*y;</span><br><span class="line">	*x &#x3D; *x^*y;</span><br><span class="line">	*y &#x3D; *x^*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>位级运算一个常见用法就是实现掩码运算，例如：</p>
<p>x&amp;0xFF生成一个由x的最低有效字节组成的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例题：</span><br><span class="line">除了x的最低有效字节外，其他的位都取补，最低有效字节保持不变</span><br><span class="line">x^0xFF(这样写就可以忽略字长)</span><br><span class="line">x的最低有效字节设置全1，其他字节保持不变</span><br><span class="line">x||0xFF</span><br></pre></td></tr></table></figure>

<h2 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h2><p>C语言还提供了一组逻辑运算符||、&amp;&amp;和！。<strong>这与位级运算是不同的</strong></p>
<h2 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h2><p>左移只有逻辑左移对应x&lt;&lt;k。</p>
<p>右移分为逻辑右移和算术右移x&gt;&gt;k。在C语言中没有明确表示，但大多数编译器都是算术右移，在java中，x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k做逻辑右移。</p>
<p><strong>若移动k≥w位时，实际移动位数为kmodw</strong></p>
<p><strong>C语言中加减法的优先级比移位运算要高。1&lt;&lt;2+3&lt;&lt;4，其实时（1&lt;&lt;(2+3)）&lt;&lt;4</strong></p>
<h1 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h1><p>编码整数的两种不同的方式：一种只能表示非负数，而另一种能表示负数、零和正数。</p>
<p>《图片》</p>
<h2 id="整型数据类型"><a href="#整型数据类型" class="headerlink" title="整型数据类型"></a>整型数据类型</h2><p>很明显，对于相同的数据类型根据程序编译为32位还是64位而有所不同。</p>
<p><strong>C和C++都支持有符号和无符号数。java只支持有符号数</strong></p>
<h2 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h2><p>无符号数编码，定义一个 函数名为B2U(Binary to Unsigned)来表示。</p>
<p>《图片》</p>
<p>B2U是一个双射，是唯一的。</p>
<h2 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h2><p>最常见的有符号数的计算机表示方式就是补码（two’s-complement）形式。</p>
<p>将字的最高有效位解释为负权（negative weight）。我们用函数B2T来表示</p>
<p>《图片》</p>
<p>补码编码的唯一性</p>
<p>B2T是一个双射。</p>
<p>|TMin| = |TMax| + 1,之所以不对称，因为一半的位模式表示负数，而另一半（符号设置为0）表示非负数，也就意味能表示的整数比负数少一个。第二：UMAX = 2TMAX+1</p>
<p>为了一些程序也能够在大量的机器和编译器移植，C库中的&lt;limits.h&gt;定义了一组常量(消除了可变性)，INT_MAX,INT_MIN等等。</p>
<p>而数据类型的取值范围，java标准是非常明确的。</p>
<h2 id="有符号数和无符号数之间的转换"><a href="#有符号数和无符号数之间的转换" class="headerlink" title="有符号数和无符号数之间的转换"></a>有符号数和无符号数之间的转换</h2><p>C语言允许不同数字类型之间进行强制类型转换。</p>
<p>强制类型转换的本质是，位值不变，只是改变了解释这些位的方式。</p>
<p><strong>原理：补码转化位无符号数</strong></p>
<p><strong>若满足 Tmin≤x≤Tmax的x有</strong></p>
<p>​                        </p>
<p><strong>T2U（x） =   x+2的w次,     x&lt;0</strong></p>
<p>​                       <strong>x,                    x≥0</strong></p>
<p>图片</p>
<p>图片</p>
<p><strong>若满足 0≤u≤Umax的u有</strong></p>
<p>​                        </p>
<p><strong>U2T（x） =  u,                            u≤Tmax</strong></p>
<p>​                       <strong>u-2的w次,                   u&gt;Tmax</strong></p>
<p>图片</p>
<h2 id="C语言中的有符号数与无符号数"><a href="#C语言中的有符号数与无符号数" class="headerlink" title="C语言中的有符号数与无符号数"></a>C语言中的有符号数与无符号数</h2><p>C语言标准没有指定有符号数采用哪种表示，但几乎所有机器都使用补码。</p>
<p>当申明一个常量默认被当作有符号，要创建一个无符号数常量，必须加上后缀字符U</p>
<h2 id="拓展一个数字的位表示"><a href="#拓展一个数字的位表示" class="headerlink" title="拓展一个数字的位表示"></a>拓展一个数字的位表示</h2><ul>
<li>无符号数的零扩展（zero extension）：高位填0就行了</li>
<li>符号宽展（sign extension)：图片</li>
</ul>
<p>当short转换成unsigned时，首先要改变大小，再完成从有符号到无符号之间的转换。也就是说(unsigned)sx等价于(unsigned)(int)sx。这个规则是C语言标准要求的。</p>
<p>对于C语言而言，无符号数移位是逻辑移位，有符号数移位是算术移位。 </p>
<h2 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h2><ul>
<li>截断无符号数：x’ = x mod 2的k次（截断为k位的结果）</li>
<li>截断补码数值：具有相似的属性，只不过要将最高位转换为符号位。</li>
</ul>
<h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><h2 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h2><p>图片</p>
<p>对于两个非负整数，满足0≤x,y≤2的w次。每个数都表示为w位无符号数字，然而计算和，可能范围为0≤x+y≤2的（w+1）次-2。</p>
<p>一般来说，如果x+y＜2的w次，和的w+1位表示中的最高位会等于0，因此不会改变。相反另一种情况会等于1，因此丢弃它相当于从和中减去2的w次。</p>
<p>图片*3</p>
<p>当执行C程序时，不会将溢出作为错误而发信号。所以需要另外检测。</p>
<p>对在范围0≤x,y≤umax中的x和y，令s = x+y，当s&lt;x或s&lt;y时，发生了溢出。另一方面，如果s确实溢出了，我们就有 s = x+y-2的w次。假设 y&lt;2的w次，我们就有 y-2的w次＜0，因此s&lt;x。</p>
<p>无符号数取反</p>
<p>图片</p>
<h2 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h2><p>图片*3</p>
<p>检测补码加法中的溢出：当x&lt;0,y&lt;0,但s≥0,计算s发生了负溢出。负溢出也是同样道理。</p>
<h2 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h2><p>图片</p>
<p>补码非得位级表示：在C语言中，对于任意整数x,计算-x和~x+1结果一样。</p>
<h2 id="无符号数乘法"><a href="#无符号数乘法" class="headerlink" title="无符号数乘法"></a>无符号数乘法</h2><p>范围在0&lt;=x,y&lt;=2w-1内的整数x和y可以被表示为w位的无符号数，但是它们的乘积的取值范围为0到2的2w次-2的（w+1）次+1。这可能需要2w位来表示。不过，C语言中的无符号乘法被定义为产生w位的值，就是2w位的整数乘积的低w位表示的值。</p>
<p>图片</p>
<h2 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h2><p>补码乘法和无符号数乘法具有位级等价性。</p>
<p>图片</p>
<h2 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h2><p>大多数机器，整数乘法指令相当慢，需要10个或者更多的时钟周期，然后其他整数运算只需要1个时钟周期，所以试着用移位和加法运算的组合来代替乘以常数因子的乘法</p>
<p>乘以2的幂：k次就是左移k个0（对于无符号和有符号都一样，最后基本等价性）</p>
<p>需要C语言编译器试图以移位，加法和减法的组合来消除很多整数乘以常数的情况。例如：x*14，编译器将乘法重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)</p>
<p>除以2的幂：整数除法比乘法更慢，需要30个或更多时钟周期。才用右移来实现，无符号数和补码数分别使用逻辑移位和算术移位来达到目的。</p>
<p>整数除法总是舍入到0.对于负数向上，对于正数向下。</p>
<p>对于无符号数。采用逻辑移位。设x’为w-k位[x的w-1,…,w的k]的无符号数，而x’’为k位表示[x的k-1,…,x的0]的无符号数,x = 2的k次*x’+x’’,而0≤x’’&lt;2的k次。因此x’自然向下取整。</p>
<p>对于补码来说。移位执行的是算术移位。对于正数来说，与无符号数一样的。对于负数，普通的算术移位，会导致向下舍入，所以需要配调整。</p>
<p>对于，负数想要向上舍入，如何调整？</p>
<p>在移位之前，“偏置（biasing）”这个值，来修正不适合的舍入。C变量x和k分别有补码值x和无符号数值k，且0≤k&lt;w,则当执行算术移位时，C表达式(x+(1&lt;&lt;k)-1)&gt;&gt;K。根本原理：假设x=qy+r，其中0≤r&lt;y,得到(x+y-1)/y=q+(r+y-1)/y，因此。当r=0时，后面一项等于0，而当r&gt;0时，等于1。也就是说，通过给x增加一个偏量y-1，然后再用除法向下舍入，当y整数x时，我们得到q，否则，就得到q+1。回到y=2k的情况，C表达式X+(1&lt;&lt;K)-1得到数值x+2的k次-1。</p>
<h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><h2 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h2><p>二进制小数点往左移动一位相当于这个数被2除。往右移动一位，相当于将该数乘2。假定我们仅考虑有限从长度的编码，有些小数是不能被精确表示(只能表示: x*2的y次)，只能通过长度不断逼近。</p>
<h2 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h2><p>IEEE浮点标准用<img src="https://img2018.cnblogs.com/blog/1334023/201907/1334023-20190725104536051-398406811.png" alt="img">的形式来表示一个数：</p>
<ul>
<li>符号（sign）s决定是负数（s=1）还是正数（s=0），而对于数值0的符号位解释作为特殊情况处理。</li>
<li>尾数（significand）M是一个二进制小数，它的范围是1<del>2-ε，或者是0</del>1-ε。</li>
<li>阶码（exponent）E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。</li>
</ul>
<p>在单精度浮点数中，s、exp、frac分别1、8、23。双精度1,11,52。</p>
<p>根据exp的值，被编码的值可以分成三种不同的情况（最后的情况有两个变种）。</p>
<p>图片</p>
<ul>
<li>情况1（规格化数）：阶码的值E = e-bias。e为无符号数。尾数具有隐含的1开头（implied leading 1）表示。</li>
<li>情况2 （非规格化数）:E = 1-bias。尾数不包含隐含位1开头。（这里设置1-bias是为了平滑过度到规格化值，具体看下图）</li>
<li>情况3（特殊值）：阶码全为1的时候出现的，当小数域全为0时，根据符号位，得到正负无穷。小数域非0时，结果值称为“NAN”(Not a Number)。例如计算根号-1。</li>
</ul>
<h2 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h2><p>图片*3</p>
<p>可以观潮到最大非规格化数和最小规格化数之间的平滑转变。这是一个有趣的属性，当这些表达式解释为无符号整数时，它们就是按升序排列的。</p>
<h2 id="舍入（rounding）"><a href="#舍入（rounding）" class="headerlink" title="舍入（rounding）"></a>舍入（rounding）</h2><p>向偶数舍入（round-to-even），也被称为向最接近的值舍入（round-to-nearest），是默认的方式。</p>
<p>图片</p>
<h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><p>浮点运算具有交换律，但不具备结合律。对于表达式（3.14+1e10）-1e10求得0，是因为3.14由于太小，被舍入丢失了。另外两个特例（正无穷加负无穷=NAN，x+NAN=NAN）</p>
]]></content>
      <categories>
        <category>《深入理解计算机系统》</category>
      </categories>
      <tags>
        <tag>csapp,视频课程</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序</title>
    <url>/2020/07/18/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Selection_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">		MinPostion &#x3D; ScanForMin(A,i,N-1);&#x2F;&#x2F;找最小元O（N）</span><br><span class="line">		Swap(A[i],A[MinPostion]);&#x2F;&#x2F;将未排序部分的最小元换到有序部分的最后位置</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里看出，虽然元素交换次数变为N-1次，但是寻找最小元的次数固定为N2。</p>
<p>无论如何： T = O（N2）；</p>
<p>这里想提高效率，只能从寻找最小元找突破口。</p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Heap_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	BuildHeap(A);	&#x2F;&#x2F;O(N);</span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">		TmpA[i] &#x3D; DeleteMin(A);	&#x2F;&#x2F;O(logN)</span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">		A[i] &#x3D; TmpA[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T(N) = O(NlogN)</p>
<p>需要额外O（N）空间，并且复制元素需要时间。</p>
<h2 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Heap_Sort(ElemtType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	BuildHeap(A);</span><br><span class="line">	for(i &#x3D; N-1;i&gt;0;i--)&#123;</span><br><span class="line">		Swap(&amp;A[0],&amp;A[i]);&#x2F;&#x2F; DeleteMax</span><br><span class="line">		PercDown(A,0,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定理：堆排序处理N个不同元素的随机排列的平均比较次数是2NlogN-O(NloglogN);</p>
<p>虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。</p>
<h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Swap(ElementType *a,ElementType *b)</span><br><span class="line">&#123;</span><br><span class="line">	ElementType t &#x3D; *a;*a &#x3D; *b;*b &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line">void PercDown(ElementType A[],int p,int N)&#x2F;&#x2F;将N个元素的数组中以A[p]为根的子堆调为最大堆</span><br><span class="line">&#123;</span><br><span class="line">	int Parent,Child;</span><br><span class="line">	ElementType X;</span><br><span class="line">	X &#x3D; A[p];</span><br><span class="line">	for(Parent &#x3D; p;(Parent*2+1)&lt;N;Parent &#x3D; Child)&#123;</span><br><span class="line">		Child &#x3D; Parent*2+1;</span><br><span class="line">		if((Child!&#x3D;N-1)&amp;&amp;(A[Child]&lt;A[Child+1]))</span><br><span class="line">			Child++;&#x2F;&#x2F;取左右子节点中的最大者;</span><br><span class="line">		if(X&gt;&#x3D;A[Child]) break;</span><br><span class="line">		else</span><br><span class="line">			A[parent] &#x3D; A[Child];</span><br><span class="line">	&#125;</span><br><span class="line">	A[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i &#x3D; N&#x2F;2-1;i&gt;&#x3D;0;i--)</span><br><span class="line">		PercDown(A,i,N);</span><br><span class="line">	for(i &#x3D; N-1;i&gt;0;i--)&#123;</span><br><span class="line">		Swap(&amp;A[0],&amp;A[i]);</span><br><span class="line">		PercDown(A,0,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2020/07/18/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>定义增量序列 Dm&gt;Dm-1&gt;…&gt;D1 = 1</p>
<p>对每个Dk进行Dk间隔排序（k = m,m-1,…1）</p>
<p>注意: Dk间隔有序的序列，在执行Dk-1间隔排序后，仍然是Dk间隔有序的</p>
<h1 id="希尔增量序列"><a href="#希尔增量序列" class="headerlink" title="希尔增量序列"></a>希尔增量序列</h1><p>原始希尔排序    Dm =    N/2向下取整,    Dk = Dk+1/2向下取整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Shell_sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	for(D&#x3D;N&#x2F;2;D&gt;0;D&#x2F;&#x3D;2)&#123;&#x2F;&#x2F;希尔增量序列</span><br><span class="line">		for(P&#x3D;D;P&lt;N;P++)&#123;	&#x2F;&#x2F;插入排序</span><br><span class="line">			Tmp &#x3D; A[P];</span><br><span class="line">			for(i&#x3D;P;i&gt;&#x3D;0&amp;&amp;A[i-D]&gt;Tmp;i-&#x3D;D)</span><br><span class="line">				A[i] &#x3D; A[i-D];</span><br><span class="line">			A[i] &#x3D; Tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最坏情况：T &#x3D; 平均时间复杂度（N2），如果增量序列里的元素不互质数，下面的排序都是无用功，直到增量为1才起作用</span><br></pre></td></tr></table></figure>

<h1 id="更多增量序列"><a href="#更多增量序列" class="headerlink" title="更多增量序列"></a>更多增量序列</h1><h2 id="Hibbard增量序列"><a href="#Hibbard增量序列" class="headerlink" title="Hibbard增量序列"></a>Hibbard增量序列</h2><p>Dk = 2的k次-1(相邻元素互质)</p>
<p>最坏情况 T = O（N的3/2次）</p>
<p>猜想: T平均 = O（N的5/4次）</p>
<h2 id="Sedgewick增量序列"><a href="#Sedgewick增量序列" class="headerlink" title="Sedgewick增量序列"></a>Sedgewick增量序列</h2><p>{1，5，19，41，109，。。。}</p>
<p>9*4的i次-9*2的i次+1    或           4的i次-3*2的i次+1</p>
<p>猜想： T平均 = O（N的7/6次)    ,T最差 = O(N的4/3次)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellSort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	int si,D,P,i;</span><br><span class="line">	ElementType Tmp;</span><br><span class="line">	int Sedgewick[] &#x3D; &#123;929,505,209,41,19,5,1,0&#125;&#x2F;&#x2F;一小部分</span><br><span class="line">	for(si &#x3D; 0;Sedgewocl[si]&gt;&#x3D;N;si++)</span><br><span class="line">		;</span><br><span class="line">	for(D &#x3D; Sedgewick[si];D&gt;0;D &#x3D; Sedgewick[++D])&#123;</span><br><span class="line">		for(P &#x3D; D;P&lt;N;p++)&#123;</span><br><span class="line">			Tmp &#x3D; A[p];</span><br><span class="line">			for(i &#x3D; P;i&gt;&#x3D;0&amp;&amp;tmp&lt;A[i];i-&#x3D;D)</span><br><span class="line">				A[i] &#x3D; A[i-D];</span><br><span class="line">			A[i] &#x3D; Tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp第一章：计算机系统漫游</title>
    <url>/2020/07/17/csapp%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</url>
    <content><![CDATA[<p>本书第一章开头通过跟踪hello程序的生命周期对系统进行学习</p>
<a id="more"></a>



<h1 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h1><p>Hello程序在一开始仅仅只是由编辑器创建的文本文件。这些文本文件在本质上都只是比特序列。</p>
<p><strong>比特序列是如何表示成文本字符？</strong></p>
<p><strong>这里采用编码标准，标准有很多，这里已ASCII标准为例：ASCII标准将这些最原始的比特序列，分成以字节（8个bit）为单位来表示每个字符。相当于y = f(x),y是文本字符，x是一个字节的bit串，函数f()是ASCII标准，该函数一一映射</strong></p>
<p><img src="https://i.loli.net/2020/07/17/OKGhCnreoVE1NYX.png" alt></p>
<p><strong>注意：文本中，每个文本行都有看不见的换行符’\n’，对应整数10</strong></p>
<p>所以在计算机中，比特序列是通过<strong>读到数据对象时的上下文</strong>来区分不同的数据对象</p>
<h1 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h1><p>源程序到目标程序（也称为可执行目标文件）转变过程如下：</p>
<p><img src="https://i.loli.net/2020/07/18/kDML9f4TUYNvcIZ.jpg" alt></p>
<ul>
<li>预处理阶段：修改原始C程序，比如将#include&lt;stdio.h&gt;中的stdio.h的内容直接插入程序文本中。最后将扩展名改为.i</li>
<li>编译阶段：通过编译器，转成了汇编语言程序。</li>
<li>汇编阶段：通过汇编器，转成了机器语言指令，把这些指令打包成可重定位目标程序（relocatable object program）的格式，保存到hello.o中</li>
<li>链接阶段：hello程序中调用了printf函数，该阶段就是将hello.o与printf.o以某种方式合并起来</li>
</ul>
<h1 id="处理器读并解释存在内存中的指令"><a href="#处理器读并解释存在内存中的指令" class="headerlink" title="处理器读并解释存在内存中的指令"></a>处理器读并解释存在内存中的指令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux&gt; .&#x2F;hello</span><br><span class="line">hello,world</span><br><span class="line">linux&gt;</span><br></pre></td></tr></table></figure>

<p>上图是通过shell（命令行解释器）运行了hello程序。</p>
<h2 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h2><ol>
<li>总线：总线被设计成传送定长的字节快，也就是字（word）。字长是系统的一个基本参数，每个系统中都不尽相同。大多数系统中要不32位要不64位。</li>
<li>I/O设备：每个I/O设备都通过一个控制器或适配器与I/O总线相连。<ul>
<li>控制器是I/O设备本身或系统的电路板上的芯片组</li>
<li>适配器是插在主板卡槽上的卡</li>
</ul>
</li>
<li>主存：由一组动态随机存取存储器（DRAM）芯片组成的。</li>
<li>处理器：是届时或执行存储在内存中指令的引擎。存储器核心是一个大小为一个字的寄存器，称为程序计数器PC，用于指向内存中某条机器语言指令。</li>
</ol>
<h2 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h2><p>初始时，shell程序执行它的指令，等待我们输入一个命令。当在键盘上输入“./hello”后，shell程序将字符逐一读入寄存器，再把它放到内存中</p>
<p><img src="https://i.loli.net/2020/07/18/ygsBjpQWza2c8mK.png" alt></p>
<p>当输入回车，shell知道我们结束了命令的输入。然后shell执行一系列指令加载并执行hello文件，将这个文件复制到主存。</p>
<p><img src="https://i.loli.net/2020/07/18/sE1g2olaPY3XStk.png" alt></p>
<p>处理器就开始执行这些机器语言指令。“Hello world”字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备。</p>
<p><img src="https://i.loli.net/2020/07/18/req7AfVIOmHBhJl.png" alt></p>
<h2 id="高速缓存至关重要"><a href="#高速缓存至关重要" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><p>高速缓存通过静态随机访问存储器（SRAM）的硬件技术实现。</p>
<h2 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h2><p>主要思想是上一层的存储器作为第一层存储器的高速缓存。</p>
<h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>shell与hello程序都没有直接访问硬件，取而代之是由操作系统提供服务。</p>
<p>操作系统两个基本功能：</p>
<ol>
<li>防止硬件被应用程序滥用</li>
<li>向应用程序提供简单的机制来控制硬件设备</li>
</ol>
<p>操作系统主要采用几个抽象概念来实现上面两个功能：</p>
<ol>
<li>文件对I/O设备的抽象表示</li>
<li>虚拟内存对主存和磁盘I/O设备的抽象表示</li>
<li>进程则是对处理器、主存和I/O设备的抽象表示</li>
</ol>
<p><img src="https://i.loli.net/2020/07/18/IdOl8L1XK7VxJn6.jpg" alt></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是操作系统对一个正在运行的程序一种抽象。有了这种抽象，一个系统上可以并发多个进程。这种并发执行，通过处理器来进程间切换来实现的。操作系统实行这种交错执行的机制称为<strong>上下文切换</strong>。</p>
<p><strong>上下文是指操作系统跟踪进程运行所需要的状态信息，比如PC和寄存器的当前值，以及主存的内容</strong></p>
<p>上下文切换其实就是保存当前进程的上下文，恢复新进程的上下文，然后将控制区传递给新进程。</p>
<p>对于两个并发进程：shell进程和hello进程。刚开始shell进程在运行，即等待命令行输入。</p>
<p>当运行hello程序，shell系统调用-》系统调用将控制权从shell到给操作系统-》操作系统保存shell进程上下文-》创建hello进程上下文并将控制权给hello进程-》hello进程终止-》操作系统恢复shell上下文，并将控制区给shell</p>
<p><img src="https://i.loli.net/2020/07/18/sFRvVEjpfN2KTrX.png" alt></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>现代操作系统中，进程由多个线程的执行单元构成，每个线程运行在进程上下文中，享有同样的代码与数据。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存是一种抽象概念，给进程提供一种假象，即每个进程都在独占使用主存。每个进程看到都是虚拟地址空间</p>
<p><img src="https://i.loli.net/2020/07/18/7vjezVrfUP1kngA.png" alt="Linux进程的虚拟地址空间"></p>
<p>最低地址开始，从上介绍。</p>
<ul>
<li>程序代码和数据：先是代码，接着是数据。</li>
<li>堆：代码与数据在进程开始运行时就被指定了大小。但调用像malloc和free这样C标准库函数时，堆在运行时动态扩展与搜索。</li>
<li>共享库：用来存放C标准库和数学库这样的共享库的代码和数据区域。</li>
<li>栈：编译器用它实现函数调用，调用一个函数，栈增长，一个函数返回时，栈就会收缩。也可以动态扩展和收缩。</li>
<li>内核虚拟内存：为内核保留</li>
</ul>
<p>虚拟内存的运作需要<strong>硬件和操作系统之间交互，包括堆处理器生成的每个地址的硬件翻译</strong></p>
<p>基本思想是进程虚拟内存的内容存在磁盘上，用主存作为磁盘的高速缓存。</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件本质是字节序列。但它向应用程序提供了一个统一的视图来看待各式各样的I/O设备。</p>
<h1 id="系统之间的网络通信"><a href="#系统之间的网络通信" class="headerlink" title="系统之间的网络通信"></a>系统之间的网络通信</h1><p>系统从主存复制一串字到网络适配器时，数据流过网络到达另一台机器。同时，系统也可以从读取其他机器发送过来的数据，并复制到主存。</p>
<p><img src="https://i.loli.net/2020/07/18/8SheWR1Fi7Jp5Ug.png" alt></p>
<h1 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h1><h2 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h2><p>若系统执行某应用程序需要时间Told。假设其中某部分与整体时间的比例为a。</p>
<p>若该部分性能提升k。则新的执行时间为：<strong>Tnew = (1-a)Told+（aTold）/k = Told[(1-a)+a/k]</strong></p>
<p>加速比 <strong>S = Told/Tnew = 1/[(1-a)+a/k];</strong></p>
<p><strong>若k-&gt;∞，则S = 1/（1-a）</strong>，说明想要高的加速比只有通过优化系统大部分组件才行。</p>
<h2 id="并发（concurrency）与并行-parallelism"><a href="#并发（concurrency）与并行-parallelism" class="headerlink" title="并发（concurrency）与并行(parallelism)"></a>并发（concurrency）与并行(parallelism)</h2><ol>
<li>线程级并发：使用线程可以在一个进程中执行多个控制流。想要实现线程级的并发，可以采用以下两个技术<ol>
<li>多核处理器：将多个CPU集成到一个集成电路芯片上。<img src="https://i.loli.net/2020/07/18/RPd5SgyTNUwiVlf.png" alt></li>
<li>超线程（hyperthreading）或称为同时多线程(simultaneous multi-threading)，允许一个CPU通过执行多个CPU。说是一个CPU，其实CPU里的某些硬件变成了多份，比如程序计数器和寄存器文件。平常线程切换大约需要20000个周期，而采用超线程技术后，只要一个周期。</li>
</ol>
</li>
<li>指令集并行：在较低抽象层次上，现代处理器可以同时执行多条指令。采用流水线(Pipelining),将一条指令分成不同步骤，将硬件组织分成一系列阶段。硬件不同部分来处理指令的不同部分。能够达到接近于一个时钟周期的执行效率。而超标量（super-scalar）处理器速度更快。</li>
<li>单指令、多数据并行(SIMD):允许一条指令产生多个可以并行的操作。</li>
</ol>
<h2 id="计算机系统中抽象的重要性"><a href="#计算机系统中抽象的重要性" class="headerlink" title="计算机系统中抽象的重要性"></a>计算机系统中抽象的重要性</h2><p>例如为一组函数规定简单的应用程序接口（API），使程序员无需了解它内部的工作便可使用。</p>
<p>指令集架构就是提供了堆实际处理器硬件的抽象。使用这个抽象，机器代码程序好像运行在一个一次只执行一次指令的处理器上。</p>
<p><img src="https://i.loli.net/2020/07/18/wchIqyM1FjCWVBP.png" alt></p>
]]></content>
      <categories>
        <category>《深入理解计算机系统》</category>
      </categories>
      <tags>
        <tag>csapp,视频课程</tag>
      </tags>
  </entry>
  <entry>
    <title>csapp</title>
    <url>/2020/07/17/csapp/</url>
    <content><![CDATA[<p>计划:阅读CSAPP和看对应CMU课程，看完后，总结笔记。</p>
<hr>
<p>该篇blog用于记录实施进度。</p>
<p>2020.7.17    1-20</p>
<p>2020.7.18    20-34</p>
<p>2020.7.19    34-54</p>
<p>2020.7.20    54-60（没有效率的一天）</p>
<p>2020.7.21    60-75</p>
<p>20207.22    75-88</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序</title>
    <url>/2020/07/16/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Bubble_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	for(p &#x3D; N-1;p&gt;&#x3D;0;p--)&#123;</span><br><span class="line">		flag &#x3D; 0;</span><br><span class="line">		for(i &#x3D; 0;i&lt;p;i++)&#123;	&#x2F;&#x2F;一趟冒泡</span><br><span class="line">			if(A[i]&gt;A[i+1])&#123;</span><br><span class="line">				Swap(A[i],A[i+1]);</span><br><span class="line">				flag &#x3D; 1;&#x2F;&#x2F;标识发生了交换</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag &#x3D;&#x3D; 0) break;&#x2F;&#x2F;全程无交换</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好情况：顺序T=O（N）</p>
<p>最欢情况：逆序T=O（N2）</p>
<p>稳定，也可以应用于链表</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Insertion_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">	for(p &#x3D; 1;p&lt;N;p++)&#123;</span><br><span class="line">		Tmp &#x3D; A[p];</span><br><span class="line">		for(i &#x3D; p;i&gt;&#x3D;0&amp;&amp;tmp&lt;A[i-1];i--)</span><br><span class="line">			A[i] &#x3D; A[i-1];</span><br><span class="line">		A[i] &#x3D; Tmp;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好情况：顺序T=O（N）；</p>
<p>最坏情况: 逆序T=O(N2);</p>
<h1 id="时间复杂度下界"><a href="#时间复杂度下界" class="headerlink" title="时间复杂度下界"></a>时间复杂度下界</h1><p>对于i&lt;j,如果A[i]&gt;A[j],则称（i,j）是一对逆序对（inversion）</p>
<p>对于简单排序，都是相邻元素交换，每交换一次正好消去1个逆序对！</p>
<p>插入排序：T（N,I）= O（N+I），如果序列基本有序，则插入排序简单高效</p>
<p>定理:任意N个不同元素组成的序列平均具有<strong>N（N-1）/4</strong>个逆序对。</p>
<p>定理:任何交换相邻元素排序的算法，其平均时间为<strong>Ω（N2）</strong>。</p>
<p>这意味着，想提高效率，必须:</p>
<ul>
<li>每次消去不止1个逆序对</li>
<li>每次交换相隔较远的2个元素</li>
</ul>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>cmu csapp lecture 02 Bits,Bytes,and Integer</title>
    <url>/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/</url>
    <content><![CDATA[<p><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/02-03-bits-ints.pdf" target="_blank" rel="noopener">讲义地址</a></p>
<h1 id="Representing-amp-Manipulating-Sets"><a href="#Representing-amp-Manipulating-Sets" class="headerlink" title="Representing &amp; Manipulating Sets"></a>Representing &amp; Manipulating Sets</h1><h2 id="Representing"><a href="#Representing" class="headerlink" title="Representing"></a>Representing</h2><p>01101001{0,3,5,6}</p>
<p>01010101{0,2,4,6}</p>
<h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><p>&amp; Intersection {0,6}</p>
<p>|  Union            {0,2,3,4,5,6}</p>
<p>^  Symmetric difference {2,3,4,5}</p>
<p>~ Complement {1,3,5,7}</p>
<p>上面的布尔代数运算，是从集合的角度来看。</p>
<p>watch out for &amp;&amp; vs &amp;(and || vs |)..(Bit-level Operations and logic Operations)</p>
<h1 id="shift-Operations"><a href="#shift-Operations" class="headerlink" title="shift Operations"></a>shift Operations</h1><h2 id="Left-Shift-x-lt-lt-y"><a href="#Left-Shift-x-lt-lt-y" class="headerlink" title="Left Shift : x &lt;&lt; y"></a>Left Shift : x &lt;&lt; y</h2><h2 id="Right-Shift-x-gt-gt-y"><a href="#Right-Shift-x-gt-gt-y" class="headerlink" title="Right Shift: x&gt;&gt;y"></a>Right Shift: x&gt;&gt;y</h2><h3 id="Logical-shift-Fill-with-0’s-on-left"><a href="#Logical-shift-Fill-with-0’s-on-left" class="headerlink" title="Logical shift:Fill with 0’s on left"></a>Logical shift:Fill with 0’s on left</h3><h3 id="Arithmetic-shift-Replicate-most-significant-bit-on-letf"><a href="#Arithmetic-shift-Replicate-most-significant-bit-on-letf" class="headerlink" title="Arithmetic shift: Replicate most significant bit on letf"></a>Arithmetic shift: Replicate most significant bit on letf</h3><h1 id="Conversion-Visualized"><a href="#Conversion-Visualized" class="headerlink" title="Conversion Visualized"></a>Conversion Visualized</h1><p><img src="/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/1.png" alt="Conversion"></p>
<h1 id="Casting-Suprises"><a href="#Casting-Suprises" class="headerlink" title="Casting Suprises"></a>Casting Suprises</h1><p>在单一表达式中混有有符号数和无符号数，有符号数会转换成无符号数</p>
]]></content>
      <categories>
        <category>《深入理解计算机系统》</category>
      </categories>
      <tags>
        <tag>csapp,视频课程</tag>
      </tags>
  </entry>
  <entry>
    <title>三点心得</title>
    <url>/2020/07/14/%E4%B8%89%E7%82%B9%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<ol>
<li>当脑海中浮现不开心的事情后，想开心的事情。</li>
<li>每次结束前，尽量克服难关。</li>
<li>趁热打铁</li>
</ol>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>旅游规划</title>
    <url>/2020/07/13/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>7-9 旅游规划 (25分)</p>
<p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入数据的第1行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0~(<em>N</em>−1)；<em>M</em>是高速公路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。随后的<em>M</em>行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 40</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,S,D;</span><br><span class="line">int visited[505];</span><br><span class="line">int cost[505];</span><br><span class="line">int dist[505];</span><br><span class="line">int costs[505][505];</span><br><span class="line">int graph[505][505];</span><br><span class="line">int t1,t2,t3,t4;</span><br><span class="line">void reset()&#123;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;505;i++)&#123;</span><br><span class="line">		for(int j &#x3D; 0;j&lt;505;j++)&#123;</span><br><span class="line">			if(i!&#x3D;j)&#123;</span><br><span class="line">				costs[i][j] &#x3D; 65535;</span><br><span class="line">				graph[i][j] &#x3D; 65535;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Dijkstra(int s)&#123;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)&#123;	&#x2F;&#x2F;初始化</span><br><span class="line">		cost[i] &#x3D; costs[s][i];</span><br><span class="line">		dist[i] &#x3D; graph[s][i];</span><br><span class="line">	&#125;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		int min &#x3D; 65535;</span><br><span class="line">		int v &#x3D; -1;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">			if((i!&#x3D;s)&amp;&amp;(visited[i] &#x3D;&#x3D; 0)&amp;&amp;(graph[s][i]&lt;min))&#123;</span><br><span class="line">				v &#x3D; i;</span><br><span class="line">				min &#x3D; graph[s][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(v &#x3D;&#x3D; -1) break;</span><br><span class="line">		visited[v] &#x3D; 1;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">			if((visited[i] &#x3D;&#x3D; 0)&amp;&amp;(dist[v]+graph[v][i]&lt;dist[i]))&#123;</span><br><span class="line">				dist[i] &#x3D; dist[v] + graph[v][i];</span><br><span class="line">				cost[i] &#x3D; cost[v]+costs[v][i];</span><br><span class="line">			&#125;else if((dist[v]+graph[v][i] &#x3D;&#x3D; dist[i])&amp;&amp;(cost[v]+costs[v][i]&lt;cost[i]))&#123;</span><br><span class="line">				cost[i] &#x3D; cost[v] + costs[v][i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;D;</span><br><span class="line">	reset();	&#x2F;&#x2F;初始化</span><br><span class="line">	for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">		cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3&gt;&gt;t4;</span><br><span class="line">		graph[t1][t2] &#x3D; t3;</span><br><span class="line">		graph[t2][t1] &#x3D; t3;</span><br><span class="line">		costs[t1][t2] &#x3D; t4;</span><br><span class="line">		costs[t2][t1] &#x3D; t4;</span><br><span class="line">	&#125;	</span><br><span class="line">	Dijkstra(S);</span><br><span class="line">	cout&lt;&lt;dist[D]&lt;&lt;&quot; &quot;&lt;&lt;cost[D];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他变型问题"><a href="#其他变型问题" class="headerlink" title="其他变型问题"></a>其他变型问题</h3><p>要求数最短路径有几条</p>
<ol>
<li>初始化起点:count[s] = 1;</li>
<li>如果找到更短路：count[w] = count[v];</li>
<li>如果找到等长路：count[w]+=count[v];</li>
</ol>
<p>要求边数最少的最短路</p>
<pre><code>1. counts[s] = 0;
 2. 如果找到更短路：count[w] = count[v]+1;
 3. 如果找到等长路:  count[w] = count[v] + 1;</code></pre>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>关键路径</title>
    <url>/2020/07/13/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>AOE（Activity On Edge,与AOV区别）网络</p>
<p>计算整个工期就是 计算最早完成时间</p>
<p>机动时间： D&lt;i,j&gt; = Latest[j] - Earliest[i] - C&lt;i,j&gt;</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>关键路径</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2020/07/13/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="拓扑序定义"><a href="#拓扑序定义" class="headerlink" title="拓扑序定义"></a>拓扑序定义</h1><p>如果图中从v到w有一条有向途径,则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。</p>
<p>获得一个拓扑序的过程就是拓扑排序</p>
<p>Activity On Vertex (AOV) 网络如果有合理的拓扑序，则必定是有向无环图（Directed Acylic Grapg,DAG）</p>
<h1 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void TopSort()&#123;</span><br><span class="line">	for(cnt &#x3D; 0;cnt&lt;v;cnt++)&#123;</span><br><span class="line">		v &#x3D; 未输出的入度为0的顶点；&#x2F;&#x2F;O(V)</span><br><span class="line">		if(这样的v不存在)&#123;</span><br><span class="line">			Error(“图中有回路”);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		输出v，或者记录v的输出序号;</span><br><span class="line">		for(v的每个邻接点)</span><br><span class="line">			Indegree[w]--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(V2)</span><br></pre></td></tr></table></figure>

<h1 id="聪明的算法"><a href="#聪明的算法" class="headerlink" title="聪明的算法"></a>聪明的算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;随时将入度变为0的顶点放到一个容器里</span><br><span class="line">void TopSort()&#123;</span><br><span class="line">	for(图中每个顶点 v)</span><br><span class="line">		if(Indegree[v] &#x3D;&#x3D; 0)</span><br><span class="line">			enqueue(v,q);</span><br><span class="line">	while(!isempty(q))&#123;</span><br><span class="line">		v &#x3D; dequeue(q);</span><br><span class="line">		输出v,或者记录v的输出序号;cnt++</span><br><span class="line">		for(v 的每个邻接点 w)</span><br><span class="line">			if(--Indegree[W] &#x3D;&#x3D; 0)</span><br><span class="line">				enqueue(W,Q);</span><br><span class="line">	&#125;</span><br><span class="line">	if( cnt !&#x3D; v)</span><br><span class="line">		error(“图中有回路”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(V+E)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树问题(Minimum Spanning Tree)</title>
    <url>/2020/07/13/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>最小生成树首先是一棵树</p>
<ol>
<li>无回路</li>
<li>V个顶点一定有V-1条边</li>
</ol>
<p>是生成树</p>
<ol>
<li>包含全部顶点</li>
<li>V-1条边都在图里</li>
</ol>
<p>边的权重和最小</p>
<h1 id="生成最小生成树的算法思想（贪心思想）"><a href="#生成最小生成树的算法思想（贪心思想）" class="headerlink" title="生成最小生成树的算法思想（贪心思想）"></a>生成最小生成树的算法思想（贪心思想）</h1><p>每一步都是选最好的（权重最小的边）</p>
<p>选择过程中的约束：</p>
<ol>
<li>只能用图里的边</li>
<li>只能一种选择v-1条边</li>
<li>不能有回路</li>
</ol>
<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>类似Dijikastra算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		v &#x3D; 未收录顶点中dist最小值;</span><br><span class="line">		if(这样的v不存在)</span><br><span class="line">			break;</span><br><span class="line">		collected[v] &#x3D; true;</span><br><span class="line">		for(v 的每个邻接点 w)&#123;</span><br><span class="line">			if((collected[w] &#x3D;&#x3D; false) &amp;&amp; (dist[v] + E&lt;v,w&gt; &lt; dist[w]))&#123;</span><br><span class="line">				dist[w] &#x3D; dist[v] + E[v,w]l</span><br><span class="line">				path[w] &#x3D; v;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Prim()&#123;</span><br><span class="line">	MST &#x3D; &#123;s&#125;;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		v &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">		if(这样v不存在)</span><br><span class="line">			break;</span><br><span class="line">		将v收录进MST: dist[v] &#x3D; 0;</span><br><span class="line">		for(v 的每个邻接点 w)&#123;</span><br><span class="line">			if(dist[w] !&#x3D; 0)&#123;</span><br><span class="line">				if(E&lt;v,w&gt; &lt;dist[w])&#123;</span><br><span class="line">					dist[w] &#x3D; E&lt;v,w&gt;;</span><br><span class="line">					parent[W] &#x3D; v;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(MST中收的顶点不到V个)</span><br><span class="line">		Error(“生成树不存在”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;dist[v] &#x3D; E&lt;s,v&gt; 或 正无穷</span><br><span class="line">&#x2F;&#x2F;parent[s] &#x3D; -1</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(v2) 稠密图合算</span><br></pre></td></tr></table></figure>

<h2 id="Kruskal算法（将森林合并成树）"><a href="#Kruskal算法（将森林合并成树）" class="headerlink" title="Kruskal算法（将森林合并成树）"></a>Kruskal算法（将森林合并成树）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Kruskal (Graph G)&#123;</span><br><span class="line">	MST &#x3D; &#123;&#125;;</span><br><span class="line">	while(MST中不到|V|-1条边 &amp;&amp; E中还有边)&#123;</span><br><span class="line">		从E中取一条权重最小边 &#x2F;*最小堆*&#x2F;</span><br><span class="line">		将E&lt;v,w&gt;从E中删除；</span><br><span class="line">		if(E&lt;v,w&gt;不在MST中构成回路) &#x2F;*并查集*&#x2F;</span><br><span class="line">			 E(V,W) 加入 MST;</span><br><span class="line">		else</span><br><span class="line">			彻底无视 E(V,W);</span><br><span class="line">		&#125;</span><br><span class="line">		if ( MST 中不到 |V|-1 条边 )</span><br><span class="line">			Error ( “生成树不存在” );</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(ElogE)</span><br></pre></td></tr></table></figure>

<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 邻接矩阵存储 - Prim最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">Vertex FindMinDist( MGraph Graph, WeightType dist[] )</span><br><span class="line">&#123; &#x2F;* 返回未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">    Vertex MinV, V;</span><br><span class="line">    WeightType MinDist &#x3D; INFINITY;</span><br><span class="line"> </span><br><span class="line">    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        if ( dist[V]!&#x3D;0 &amp;&amp; dist[V]&lt;MinDist) &#123;</span><br><span class="line">            &#x2F;* 若V未被收录，且dist[V]更小 *&#x2F;</span><br><span class="line">            MinDist &#x3D; dist[V]; &#x2F;* 更新最小距离 *&#x2F;</span><br><span class="line">            MinV &#x3D; V; &#x2F;* 更新对应顶点 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (MinDist &lt; INFINITY) &#x2F;* 若找到最小dist *&#x2F;</span><br><span class="line">        return MinV; &#x2F;* 返回对应的顶点下标 *&#x2F;</span><br><span class="line">    else return ERROR;  &#x2F;* 若这样的顶点不存在，返回-1作为标记 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Prim( MGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType dist[MaxVertexNum], TotalWeight;</span><br><span class="line">    Vertex parent[MaxVertexNum], V, W;</span><br><span class="line">    int VCount;</span><br><span class="line">    Edge E;</span><br><span class="line">     </span><br><span class="line">    &#x2F;* 初始化。默认初始点下标是0 *&#x2F;</span><br><span class="line">       for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        &#x2F;* 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY *&#x2F;</span><br><span class="line">           dist[V] &#x3D; Graph-&gt;G[0][V];</span><br><span class="line">           parent[V] &#x3D; 0; &#x2F;* 暂且定义所有顶点的父结点都是初始点0 *&#x2F; </span><br><span class="line">    &#125;</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    VCount &#x3D; 0;      &#x2F;* 初始化收录的顶点数 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    E &#x3D; (Edge)malloc( sizeof(struct ENode) ); &#x2F;* 建立空的边结点 *&#x2F;</span><br><span class="line">            </span><br><span class="line">    &#x2F;* 将初始点0收录进MST *&#x2F;</span><br><span class="line">    dist[0] &#x3D; 0;</span><br><span class="line">    VCount ++;</span><br><span class="line">    parent[0] &#x3D; -1; &#x2F;* 当前树根是0 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    while (1) &#123;</span><br><span class="line">        V &#x3D; FindMinDist( Graph, dist );</span><br><span class="line">        &#x2F;* V &#x3D; 未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">        if ( V&#x3D;&#x3D;ERROR ) &#x2F;* 若这样的V不存在 *&#x2F;</span><br><span class="line">            break;   &#x2F;* 算法结束 *&#x2F;</span><br><span class="line">             </span><br><span class="line">        &#x2F;* 将V及相应的边&lt;parent[V], V&gt;收录进MST *&#x2F;</span><br><span class="line">        E-&gt;V1 &#x3D; parent[V];</span><br><span class="line">        E-&gt;V2 &#x3D; V;</span><br><span class="line">        E-&gt;Weight &#x3D; dist[V];</span><br><span class="line">        InsertEdge( MST, E );</span><br><span class="line">        TotalWeight +&#x3D; dist[V];</span><br><span class="line">        dist[V] &#x3D; 0;</span><br><span class="line">        VCount++;</span><br><span class="line">         </span><br><span class="line">        for( W&#x3D;0; W&lt;Graph-&gt;Nv; W++ ) &#x2F;* 对图中的每个顶点W *&#x2F;</span><br><span class="line">            if ( dist[W]!&#x3D;0 &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;</span><br><span class="line">            &#x2F;* 若W是V的邻接点并且未被收录 *&#x2F;</span><br><span class="line">                if ( Graph-&gt;G[V][W] &lt; dist[W] ) &#123;</span><br><span class="line">                &#x2F;* 若收录V使得dist[W]变小 *&#x2F;</span><br><span class="line">                    dist[W] &#x3D; Graph-&gt;G[V][W]; &#x2F;* 更新dist[W] *&#x2F;</span><br><span class="line">                    parent[W] &#x3D; V; &#x2F;* 更新树 *&#x2F;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; &#x2F;* while结束*&#x2F;</span><br><span class="line">    if ( VCount &lt; Graph-&gt;Nv ) &#x2F;* MST中收的顶点不到|V|个 *&#x2F;</span><br><span class="line">       TotalWeight &#x3D; ERROR;</span><br><span class="line">    return TotalWeight;   &#x2F;* 算法执行完毕，返回最小权重和或错误标记 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* 邻接表存储 - Kruskal最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 顶点并查集定义 --------------------*&#x2F;</span><br><span class="line">typedef Vertex ElementType; &#x2F;* 默认元素可以用非负整数表示 *&#x2F;</span><br><span class="line">typedef Vertex SetName;     &#x2F;* 默认用根结点的下标作为集合名称 *&#x2F;</span><br><span class="line">typedef ElementType SetType[MaxVertexNum]; &#x2F;* 假设集合元素下标从0开始 *&#x2F;</span><br><span class="line"> </span><br><span class="line">void InitializeVSet( SetType S, int N )</span><br><span class="line">&#123; &#x2F;* 初始化并查集 *&#x2F;</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    for ( X&#x3D;0; X&lt;N; X++ ) S[X] &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Union( SetType S, SetName Root1, SetName Root2 )</span><br><span class="line">&#123; &#x2F;* 这里默认Root1和Root2是不同集合的根结点 *&#x2F;</span><br><span class="line">    &#x2F;* 保证小集合并入大集合 *&#x2F;</span><br><span class="line">    if ( S[Root2] &lt; S[Root1] ) &#123; &#x2F;* 如果集合2比较大 *&#x2F;</span><br><span class="line">        S[Root2] +&#x3D; S[Root1];     &#x2F;* 集合1并入集合2  *&#x2F;</span><br><span class="line">        S[Root1] &#x3D; Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;                         &#x2F;* 如果集合1比较大 *&#x2F;</span><br><span class="line">        S[Root1] +&#x3D; S[Root2];     &#x2F;* 集合2并入集合1  *&#x2F;</span><br><span class="line">        S[Root2] &#x3D; Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SetName Find( SetType S, ElementType X )</span><br><span class="line">&#123; &#x2F;* 默认集合元素全部初始化为-1 *&#x2F;</span><br><span class="line">    if ( S[X] &lt; 0 ) &#x2F;* 找到集合的根 *&#x2F;</span><br><span class="line">        return X;</span><br><span class="line">    else</span><br><span class="line">        return S[X] &#x3D; Find( S, S[X] ); &#x2F;* 路径压缩 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )</span><br><span class="line">&#123; &#x2F;* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 *&#x2F;</span><br><span class="line">    Vertex Root1, Root2;</span><br><span class="line"> </span><br><span class="line">    Root1 &#x3D; Find( VSet, V1 ); &#x2F;* 得到V1所属的连通集名称 *&#x2F;</span><br><span class="line">    Root2 &#x3D; Find( VSet, V2 ); &#x2F;* 得到V2所属的连通集名称 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    if( Root1&#x3D;&#x3D;Root2 ) &#x2F;* 若V1和V2已经连通，则该边不能要 *&#x2F;</span><br><span class="line">        return false;</span><br><span class="line">    else &#123; &#x2F;* 否则该边可以被收集，同时将V1和V2并入同一连通集 *&#x2F;</span><br><span class="line">        Union( VSet, Root1, Root2 );</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 并查集定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 边的最小堆定义 --------------------*&#x2F;</span><br><span class="line">void PercDown( Edge ESet, int p, int N )</span><br><span class="line">&#123; &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p )    *&#x2F;</span><br><span class="line">  &#x2F;* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 *&#x2F;</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    struct ENode X;</span><br><span class="line"> </span><br><span class="line">    X &#x3D; ESet[p]; &#x2F;* 取出根结点存放的值 *&#x2F;</span><br><span class="line">    for( Parent&#x3D;p; (Parent*2+1)&lt;N; Parent&#x3D;Child ) &#123;</span><br><span class="line">        Child &#x3D; Parent * 2 + 1;</span><br><span class="line">        if( (Child!&#x3D;N-1) &amp;&amp; (ESet[Child].Weight&gt;ESet[Child+1].Weight) )</span><br><span class="line">            Child++;  &#x2F;* Child指向左右子结点的较小者 *&#x2F;</span><br><span class="line">        if( X.Weight &lt;&#x3D; ESet[Child].Weight ) break; &#x2F;* 找到了合适位置 *&#x2F;</span><br><span class="line">        else  &#x2F;* 下滤X *&#x2F;</span><br><span class="line">            ESet[Parent] &#x3D; ESet[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    ESet[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void InitializeESet( LGraph Graph, Edge ESet )</span><br><span class="line">&#123; &#x2F;* 将图的边存入数组ESet，并且初始化为最小堆 *&#x2F;</span><br><span class="line">    Vertex V;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    int ECount;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将图的边存入数组ESet *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;</span><br><span class="line">    for ( V&#x3D;0; V&lt;Graph-&gt;Nv; V++ )</span><br><span class="line">        for ( W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next )</span><br><span class="line">            if ( V &lt; W-&gt;AdjV ) &#123; &#x2F;* 避免重复录入无向图的边，只收V1&lt;V2的边 *&#x2F;</span><br><span class="line">                ESet[ECount].V1 &#x3D; V;</span><br><span class="line">                ESet[ECount].V2 &#x3D; W-&gt;AdjV;</span><br><span class="line">                ESet[ECount++].Weight &#x3D; W-&gt;Weight;</span><br><span class="line">            &#125;</span><br><span class="line">    &#x2F;* 初始化为最小堆 *&#x2F;</span><br><span class="line">    for ( ECount&#x3D;Graph-&gt;Ne&#x2F;2; ECount&gt;&#x3D;0; ECount-- )</span><br><span class="line">        PercDown( ESet, ECount, Graph-&gt;Ne );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int GetEdge( Edge ESet, int CurrentSize )</span><br><span class="line">&#123; &#x2F;* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将最小边与当前堆的最后一个位置的边交换 *&#x2F;</span><br><span class="line">    Swap( &amp;ESet[0], &amp;ESet[CurrentSize-1]);</span><br><span class="line">    &#x2F;* 将剩下的边继续调整成最小堆 *&#x2F;</span><br><span class="line">    PercDown( ESet, 0, CurrentSize-1 );</span><br><span class="line"> </span><br><span class="line">    return CurrentSize-1; &#x2F;* 返回最小边所在位置 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 最小堆定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int Kruskal( LGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType TotalWeight;</span><br><span class="line">    int ECount, NextEdge;</span><br><span class="line">    SetType VSet; &#x2F;* 顶点数组 *&#x2F;</span><br><span class="line">    Edge ESet;    &#x2F;* 边数组 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    InitializeVSet( VSet, Graph-&gt;Nv ); &#x2F;* 初始化顶点并查集 *&#x2F;</span><br><span class="line">    ESet &#x3D; (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne );</span><br><span class="line">    InitializeESet( Graph, ESet ); &#x2F;* 初始化边的最小堆 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;      &#x2F;* 初始化收录的边数 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    NextEdge &#x3D; Graph-&gt;Ne; &#x2F;* 原始边集的规模 *&#x2F;</span><br><span class="line">    while ( ECount &lt; Graph-&gt;Nv-1 ) &#123;  &#x2F;* 当收集的边不足以构成树时 *&#x2F;</span><br><span class="line">        NextEdge &#x3D; GetEdge( ESet, NextEdge ); &#x2F;* 从边集中得到最小边的位置 *&#x2F;</span><br><span class="line">        if (NextEdge &lt; 0) &#x2F;* 边集已空 *&#x2F;</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;* 如果该边的加入不构成回路，即两端结点不属于同一连通集 *&#x2F;</span><br><span class="line">        if ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )&#x3D;&#x3D;true ) &#123;</span><br><span class="line">            &#x2F;* 将该边插入MST *&#x2F;</span><br><span class="line">            InsertEdge( MST, ESet+NextEdge );</span><br><span class="line">            TotalWeight +&#x3D; ESet[NextEdge].Weight; &#x2F;* 累计权重 *&#x2F;</span><br><span class="line">            ECount++; &#x2F;* 生成树中边数加1 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( ECount &lt; Graph-&gt;Nv-1 )</span><br><span class="line">        TotalWeight &#x3D; -1; &#x2F;* 设置错误标记，表示生成树不存在 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    return TotalWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>哈利·波特的考试</title>
    <url>/2020/07/13/%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<p>7-8 哈利·波特的考试 (25分)</p>
<p>哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。</p>
<p>现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入第1行给出两个正整数<em>N</em> (≤100)和<em>M</em>，其中<em>N</em>是考试涉及的动物总数，<em>M</em>是用于直接变形的魔咒条数。为简单起见，我们将动物按1~<em>N</em>编号。随后<em>M</em>行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 11</span><br><span class="line">3 4 70</span><br><span class="line">1 2 1</span><br><span class="line">5 4 50</span><br><span class="line">2 6 50</span><br><span class="line">5 6 60</span><br><span class="line">1 3 70</span><br><span class="line">4 6 60</span><br><span class="line">3 6 80</span><br><span class="line">5 1 100</span><br><span class="line">2 4 60</span><br><span class="line">5 2 80</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 70</span><br></pre></td></tr></table></figure>



<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int D[105][105];</span><br><span class="line">int N,M;</span><br><span class="line">int t1,t2,t3;</span><br><span class="line">void reset()&#123;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">		for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">			if(i!&#x3D;j)</span><br><span class="line">				D[i][j] &#x3D; 65535; 	&#x2F;&#x2F;floyd算法要求无边就初始化为正无穷</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">void floyd()&#123;</span><br><span class="line">	for(int k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">			for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">				if(D[i][k]+D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">					D[i][j] &#x3D; D[i][k]+D[k][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int FindMaxDist(int i)&#123;</span><br><span class="line">	int maxdist &#x3D; 0;</span><br><span class="line">	for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">		if(i!&#x3D;j &amp;&amp; D[i][j]&gt;maxdist)</span><br><span class="line">			maxdist &#x3D; D[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;cout&lt;&lt;maxdist&lt;&lt;&#39;\n&#39;; </span><br><span class="line">	return maxdist;</span><br><span class="line">&#125;</span><br><span class="line">void FindMinDist()&#123;</span><br><span class="line">	int mindist &#x3D; 65535;</span><br><span class="line">	int animal;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">		int maxdist &#x3D; FindMaxDist(i);</span><br><span class="line">		if(maxdist &#x3D;&#x3D; 65535)&#123;</span><br><span class="line">			printf(&quot;0\n&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if(mindist&gt;maxdist)&#123;</span><br><span class="line">			mindist &#x3D; maxdist;</span><br><span class="line">			animal &#x3D; i+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d %d\n&quot;,animal,mindist);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">	reset();</span><br><span class="line">	for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">		cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;</span><br><span class="line">		D[t1-1][t2-1] &#x3D; t3;	&#x2F;&#x2F;位置偏移</span><br><span class="line">		D[t2-1][t1-1] &#x3D; t3;</span><br><span class="line">	&#125;</span><br><span class="line">	floyd();</span><br><span class="line">&#x2F;&#x2F;	for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">&#x2F;&#x2F;		for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">&#x2F;&#x2F;			cout&lt;&lt;D[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">	FindMinDist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最短路径，floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径问题</title>
    <url>/2020/07/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="最短路径问题的抽象"><a href="#最短路径问题的抽象" class="headerlink" title="最短路径问题的抽象"></a>最短路径问题的抽象</h1><p>最短路径就是源点（Source）和终点（Destination）之间权值之和最小的一条路径</p>
<h1 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h1><ol>
<li>单元最短路径问题：一点到其他顶点的最短路径<ol>
<li>（有向）无权图</li>
<li>（有向）有权图</li>
</ol>
</li>
<li>多源最短路径问题：任意两点之间的最短路径</li>
</ol>
<h1 id="无权图的单源最短路算法"><a href="#无权图的单源最短路算法" class="headerlink" title="无权图的单源最短路算法"></a>无权图的单源最短路算法</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;本质就是BFS的变型</span><br><span class="line">&#x2F;&#x2F;dist[w] &#x3D; S到W的最短距离</span><br><span class="line">&#x2F;&#x2F;dist[S] &#x3D; 0</span><br><span class="line">&#x2F;&#x2F;path[W] &#x3D; S到W的路上经过的某顶点（确切说是上个顶点）</span><br><span class="line">void Unweighted(Vertex S)&#123;</span><br><span class="line">	Enqueue(S,Q);</span><br><span class="line">	while(!IsEpmty(Q)))&#123;</span><br><span class="line">		v &#x3D; Dequeue(Q);</span><br><span class="line">		for(V 的每个邻接点 W)&#123;</span><br><span class="line">			if(dist[W] &#x3D;&#x3D; -1)&#123;</span><br><span class="line">				dist[W] &#x3D; dist[V]+1;</span><br><span class="line">				path[W] &#x3D; V;</span><br><span class="line">				enqueue(W,Q);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="有权图的单源最短路算法"><a href="#有权图的单源最短路算法" class="headerlink" title="有权图的单源最短路算法"></a>有权图的单源最短路算法</h1><p><strong><em>Dijkstra算法(按照递增的顺序找到各个顶点的最短路)</em></strong></p>
<p><strong>前提是不存在负值圈</strong></p>
<ol>
<li>令S={源点s + 已经确定了最短路径的顶点vi}</li>
<li>对不属于集合S的顶点v，定义dist[v]为s到v的最短路径长度，但该路径<em>仅仅经过S中的顶点。</em>即路径{s-&gt;(vi∈S)-&gt;v}的长度</li>
<li>若路径是按照递增的顺序生成的，则<ol>
<li>真正的最短路必须只经过S中的顶点（反证法：若存在另外一个结点，那也应该是这一个结点先被收录）</li>
<li>每次从未收录的顶点中选一个dist最小的收录（贪心）</li>
<li>增加一个v进入S，可能影响另外一个w的dist值（min{dist[w], dist[v] + &lt;v,w&gt;的权重}）</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		V &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">		if(这样v不存在)</span><br><span class="line">			break;</span><br><span class="line">		collected[v] &#x3D; true;</span><br><span class="line">		for(v 的每个邻接点 W)</span><br><span class="line">			if(collected[W] &#x3D;&#x3D; false)&#123;</span><br><span class="line">				if(dist[v]+E&lt;v,w&gt; &lt; dist[W])&#123;</span><br><span class="line">					dist[W] &#x3D; dist[V] + E&lt;v,w&gt;;</span><br><span class="line">					path[W] &#x3D; v;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若将dist的值存在数组和堆中会产生不同的效果：</p>
<ol>
<li>数组中 T=O（V2 + E）适合稠密图</li>
<li>最小堆中<ol>
<li>更新dist[w] = O(logv)</li>
<li>T = O(VlogV + ElogV) = O(Elogv) 适合稀疏图</li>
</ol>
</li>
</ol>
<h1 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h1><ol>
<li>直接将单元最短路径算法调用V遍 T = O（V3 + E*V）</li>
<li>Floyd算法 T = O（V3）</li>
</ol>
<p>Floyd 算法 </p>
<ol>
<li>Dk[i][j] = 路径{i -&gt; {l&lt;=k} -&gt; j}的最小长度</li>
<li>D0,D1,…,DV-1[i][j]即给出了i到j的真正最短距离</li>
<li>最初的D-1（如果ij没边，初始化为正无穷）</li>
<li>Dk-1已经完成，递推到Dk时：<ol>
<li>或者k不∈最短路径{i-&gt;{l&lt;=k}-&gt;j},则Dk = Dk-1</li>
<li>或者k∈最短路径,则该路径由两端最短路径组成：Dk[i][j] = Dk-1[i][k] + Dk-1[k][j]</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Floyd()&#123;</span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">	 	for(j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">	 		D[i][j] &#x3D; G[i][j];</span><br><span class="line">	 		path[i][j] &#x3D; -1;	&#x2F;&#x2F;用来打印路径用</span><br><span class="line">	 	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">		for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">			for(j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">				if(D[i][k]+ D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">					D[i][j] &#x3D; D[i][k] + D[k][j];</span><br><span class="line">					path[i][j] &#x3D; k;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-7-9</title>
    <url>/2020/07/09/2020-7-9/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>1064 Complete Binary Search Tree (30分)</title>
    <url>/2020/07/06/1064-Complete-Binary-Search-Tree-30%E5%88%86/</url>
    <content><![CDATA[<p>1064 Complete Binary Search Tree (30分)</p>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys less than the node’s key.</li>
<li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p>
<p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3 8 1 5 7 9 0 2 4</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int num[1005];</span><br><span class="line">int ans[1005];</span><br><span class="line">int N;</span><br><span class="line">int getMid(int l,int r)&#123;</span><br><span class="line">	int sum &#x3D; r-l+1;		&#x2F;&#x2F;总数</span><br><span class="line">	int layer &#x3D; floor(log(sum+1)&#x2F;log(2)); &#x2F;&#x2F;除最后一层的层数，</span><br><span class="line">	int lastlayerleaf &#x3D; sum+1-pow(2,layer);	&#x2F;&#x2F;最后一层的节点数</span><br><span class="line">	int leftnum &#x3D; pow(2,layer-1)-1+min(lastlayerleaf,(int)pow(2,layer-1));	&#x2F;&#x2F;左子树结点总数</span><br><span class="line">	return l+leftnum; &#x2F;&#x2F;根位置</span><br><span class="line">&#125; </span><br><span class="line">void solve(int l,int r,int root)&#123;</span><br><span class="line">	if(r-l+1 &#x3D;&#x3D; 0) return;</span><br><span class="line">	int mid &#x3D; getMid(l,r);</span><br><span class="line">	ans[root] &#x3D; num[mid];</span><br><span class="line">	solve(l,mid-1,root*2+1);</span><br><span class="line">	solve(mid+1,r,root*2+2); </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	for(int i&#x3D;0;i&lt;N;i++)</span><br><span class="line">		cin&gt;&gt;num[i];</span><br><span class="line">	sort(num,num+N);</span><br><span class="line">	solve(0,N-1,0);</span><br><span class="line">	cout&lt;&lt;ans[0];</span><br><span class="line">	for(int i &#x3D; 1;i&lt;N;i++)</span><br><span class="line">		cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>树，公式推导</tag>
      </tags>
  </entry>
  <entry>
    <title>1086 Tree Traversals Again (25分)</title>
    <url>/2020/07/06/1086-Tree-Traversals-Again-25%E5%88%86/</url>
    <content><![CDATA[<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>
<p><img src="https://images.ptausercontent.com/30" alt="img"><br>Figure 1</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 2 6 5 1</span><br></pre></td></tr></table></figure>



<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,n,i,j,k;</span><br><span class="line">string s;</span><br><span class="line">int preorder[35];</span><br><span class="line">int inorder[35];</span><br><span class="line">int postorder[35];</span><br><span class="line">void porder(int ileft,int iright,int pleft,int pright)&#123;	&#x2F;&#x2F;核心算法</span><br><span class="line">	if((ileft&gt;iright)||(pleft&gt;pright))</span><br><span class="line">		return;</span><br><span class="line">		</span><br><span class="line">	int i &#x3D; 0;</span><br><span class="line">	postorder[k++] &#x3D; preorder[pleft];</span><br><span class="line">	&#x2F;&#x2F;cout&lt;&lt;postorder[k-1]&lt;&lt;endl;</span><br><span class="line">	for(i &#x3D; ileft;i&lt;&#x3D;iright;i++)&#123;</span><br><span class="line">		if(inorder[i] &#x3D;&#x3D; preorder[pleft])</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	porder(i+1,iright,pleft+1+i-ileft,pright);</span><br><span class="line">	porder(ileft,i-1,pleft+1,pleft+i-ileft);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	int NN &#x3D; 2*N;</span><br><span class="line">	stack&lt;int&gt; ss;</span><br><span class="line">	while(NN--)&#123;</span><br><span class="line">		cin&gt;&gt;s;</span><br><span class="line">		if(s&#x3D;&#x3D;&quot;Push&quot;)&#123;</span><br><span class="line">			cin&gt;&gt;n;</span><br><span class="line">			ss.push(n);</span><br><span class="line">			preorder[i++] &#x3D; n;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			n &#x3D; ss.top();</span><br><span class="line">			ss.pop();</span><br><span class="line">			inorder[j++] &#x3D; n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	porder(0,N-1,0,N-1);</span><br><span class="line">	cout&lt;&lt;postorder[N-1];</span><br><span class="line">	for(int j &#x3D; N-2;j&gt;&#x3D;0;j--)&#123;</span><br><span class="line">		cout&lt;&lt;&quot; &quot;&lt;&lt;postorder[j];</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>树的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>关于高效学习</title>
    <url>/2020/07/06/%E5%85%B3%E4%BA%8E%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>看完高效学习篇之后，想要进一步将知识缩减，并带入自己的思考。</p>
<h1 id="端正学习态度"><a href="#端正学习态度" class="headerlink" title="端正学习态度"></a>端正学习态度</h1><p><img src="https://dingyue.ws.126.net/d62vefHcMwmSZZFe0RXktPa4DG1hElKx4fjzHitgkZx4v1571967477433.jpg" alt="推荐丨金字塔学习法，输出和实践最能提升学习效率_网易订阅"></p>
<p>在学习知识后，必须有对知识本身有着思考，总结与归纳，不断对这些知识进行应用，对外输出。</p>
<p>更详细得步骤：</p>
<ol>
<li>好的信息源头</li>
<li>将知识连成地图</li>
<li>对于知识本身反思与思辨</li>
<li>举一反三，进行应用</li>
</ol>
<h1 id="源头、原理和知识地图"><a href="#源头、原理和知识地图" class="headerlink" title="源头、原理和知识地图"></a>源头、原理和知识地图</h1><p>好的信息源头有如下特质:</p>
<ol>
<li>第一首资料</li>
<li>有佐证、有数据、有引用</li>
<li>加入了自己经验与思考</li>
</ol>
<p>注重基础和原理</p>
<p>将所有得知识串联起来。</p>
<h1 id="深度归纳和坚持实践"><a href="#深度归纳和坚持实践" class="headerlink" title="深度归纳和坚持实践"></a>深度归纳和坚持实践</h1><p>对于新技术，除了知识图，还需要问自己多个为什么？</p>
<ol>
<li>技术出现得背景、初衷和需要用来解决什么问题</li>
<li>该技术的优势和劣势</li>
<li>适用场景（所谓场景一般分别两个，一个是业务场景，一个是技术场景。）</li>
<li>技术的组成部分和关键点（技术的核心思想和核心组件）</li>
<li>技术的底层原理和关键实现</li>
<li>已有的实现和它之间的对比</li>
</ol>
<p>举一反三的能力：</p>
<ol>
<li>联想能力：对同一个事物的不同看法，联想相关事物</li>
<li>抽象能力：从不同问题中抽象出解的结构</li>
<li>自省能力：自己的不足</li>
</ol>
]]></content>
      <categories>
        <category>学习方法</category>
      </categories>
      <tags>
        <tag>学习方法，左耳朵耗子极客时间</tag>
      </tags>
  </entry>
  <entry>
    <title>7-7 六度空间</title>
    <url>/2020/07/05/7-7-%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p>
<p><img src="https://images.ptausercontent.com/35" alt="img"><br>图1 六度空间示意图</p>
<p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p>
<p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数，分别表示社交网络图的结点数<em>N</em>（1&lt;<em>N</em>≤103，表示人数）、边数<em>M</em>（≤33×<em>N</em>，表示社交关系数）。随后的<em>M</em>行对应<em>M</em>条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到<em>N</em>编号）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1: 70.00%</span><br><span class="line">2: 80.00%</span><br><span class="line">3: 90.00%</span><br><span class="line">4: 100.00%</span><br><span class="line">5: 100.00%</span><br><span class="line">6: 100.00%</span><br><span class="line">7: 100.00%</span><br><span class="line">8: 90.00%</span><br><span class="line">9: 80.00%</span><br><span class="line">10: 70.00%</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int v[1005][1005];</span><br><span class="line">int flag[1005];</span><br><span class="line">int t1,t2,sum;</span><br><span class="line">int BFS(int node)&#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	int count &#x3D; 1;</span><br><span class="line">	int level &#x3D; 0;</span><br><span class="line">	int last &#x3D; node;</span><br><span class="line">	int tail;</span><br><span class="line">	flag[node] &#x3D; 1;</span><br><span class="line">	q.push(node);</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		node &#x3D; q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		for(int i &#x3D; 1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">			if((v[node][i] &#x3D;&#x3D; 1) &amp;&amp; (flag[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">				flag[i] &#x3D; 1;</span><br><span class="line">				q.push(i);</span><br><span class="line">				count++;</span><br><span class="line">				tail &#x3D; i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(node &#x3D;&#x3D; last)&#123;</span><br><span class="line">			level++;</span><br><span class="line">			last &#x3D; tail;</span><br><span class="line">		&#125;</span><br><span class="line">		if(level&#x3D;&#x3D;6) break;</span><br><span class="line">	&#125;</span><br><span class="line">	return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset()&#123;</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">		flag[i] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">		cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">		v[t1][t2] &#x3D; 1;</span><br><span class="line">		v[t2][t1] &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i &#x3D; 1 ;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">		sum &#x3D; BFS(i);</span><br><span class="line">		printf(&quot;%d: %.2f%%\n&quot;,i,(double)sum&#x2F;N*100);</span><br><span class="line">		reset();</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="该题要点"><a href="#该题要点" class="headerlink" title="该题要点"></a>该题要点</h3><p>这个题目在传统的BFS算法上进行改造，需要在BFS过程中记录当前遍历的层数。</p>
<p>这里再原来的基础上增加了三个变量 tail,last,level;</p>
<p>tail表示下一层的最后一个元素；</p>
<p>last表示当前层的最后一个元素；</p>
<p>level表示当前位于第几层；</p>
<hr>
<p>初始 tail不用设，last = node（第0层最后一个结点就是自己）,level = 0(自己不算）</p>
<hr>
<p>这里关键点是为什么能知道当前node是该层最后一个元素？</p>
<p>while循环中，最后判断时，弹出的当前结点node == last 时，表明：</p>
<p>该层最后一个结点已经被弹出，且下一层所有结点全在队列中了；</p>
<p>这个时候更改新一层的last，将last = tail，并将level++；</p>
<p>level的数值表示，当前i层的所有数据已经被访问完。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>7-10 Saving James Bond - Easy Version</title>
    <url>/2020/07/05/7-10-Saving-James-Bond-Easy-Version/</url>
    <content><![CDATA[<p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p>
<p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if James can escape, or “No” if not.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14 20</span><br><span class="line">25 -15</span><br><span class="line">-25 28</span><br><span class="line">8 49</span><br><span class="line">29 15</span><br><span class="line">-35 -2</span><br><span class="line">5 28</span><br><span class="line">27 -29</span><br><span class="line">-8 -28</span><br><span class="line">-20 -35</span><br><span class="line">-25 -20</span><br><span class="line">-13 29</span><br><span class="line">-30 15</span><br><span class="line">-35 40</span><br><span class="line">12 12</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 13</span><br><span class="line">-12 12</span><br><span class="line">12 12</span><br><span class="line">-12 -12</span><br><span class="line">12 -12</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure>

<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> struct node&#123;</span><br><span class="line"> 	int x,y;</span><br><span class="line"> &#125;;</span><br><span class="line"> node cro[105];</span><br><span class="line"> int visited[105];</span><br><span class="line"> int N,D;</span><br><span class="line"> int t1,t2;</span><br><span class="line"> bool answer &#x3D; 0;</span><br><span class="line"> double distance(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line"> 	return pow(x2-x1,2)+pow(y2-y1,2);</span><br><span class="line"> &#125; </span><br><span class="line">  bool DFS(int x, int y,int n)&#123;</span><br><span class="line"> 	if((x-D&lt;&#x3D;-50)||(x+D&gt;&#x3D;50)||(y-D&lt;&#x3D;-50)||(y+D&gt;&#x3D;50))&#123;</span><br><span class="line"> 		answer &#x3D; true;	</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		visited[n] &#x3D; 1;</span><br><span class="line">		for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">			if((distance(x,y,cro[i].x,cro[i].y)&lt;&#x3D;pow(D,2)) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">				DFS(cro[i].x,cro[i].y,i);</span><br><span class="line">				if(answer &#x3D;&#x3D; true) break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line"> 	return answer;</span><br><span class="line"> &#125;</span><br><span class="line"> void toJump()&#123;</span><br><span class="line"> 	for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line"> 		if((distance(0,0,cro[i].x,cro[i].y)&lt;&#x3D;pow(D+15,2)) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">			answer &#x3D; DFS(cro[i].x,cro[i].y,i);</span><br><span class="line">			if(answer &#x3D;&#x3D; true) break; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(answer) cout&lt;&lt;&quot;Yes&quot;;</span><br><span class="line">	else cout&lt;&lt;&quot;No&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> int main()&#123;</span><br><span class="line"> 	cin&gt;&gt;N&gt;&gt;D;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line"> 		cin&gt;&gt;cro[i].x&gt;&gt;cro[i].y;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		toJump();	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>列出连通集</title>
    <url>/2020/06/21/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</url>
    <content><![CDATA[<p>7-6 列出连通集 (25分)</p>
<p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照”{ <em>v</em>1 <em>v</em>2 … <em>v**k</em> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure>



<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int g[10][10];</span><br><span class="line">int visited[10];</span><br><span class="line">int n,m,t1,t2;</span><br><span class="line">void BFS(int v)&#123;</span><br><span class="line">	int vt;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	visited[v] &#x3D; 1;</span><br><span class="line">	cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">	q.push(v);</span><br><span class="line">	while(!q.empty())&#123;</span><br><span class="line">		vt &#x3D; q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">			if((g[vt][i] &#x3D;&#x3D; 1) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">				visited[i] &#x3D; 1;</span><br><span class="line">				cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">				q.push(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int v)&#123;</span><br><span class="line">	visited[v] &#x3D; 1;</span><br><span class="line">	cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">		if((g[v][i] &#x3D;&#x3D; 1) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">			DFS(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;m;i++)&#123;</span><br><span class="line">		cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">		g[t1][t2] &#x3D; 1;</span><br><span class="line">		g[t2][t1] &#x3D; 1;</span><br><span class="line">	&#125; </span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">		if(visited[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">			DFS(i);</span><br><span class="line">			cout&lt;&lt;&quot;&#125;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)</span><br><span class="line">		visited[i] &#x3D; 0;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">		if(visited[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">			BFS(i);</span><br><span class="line">			cout&lt;&lt;&quot;&#125;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/06/20/%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图定义"><a href="#图定义" class="headerlink" title="图定义"></a>图定义</h1><p>由V（Vertex）表示有限顶点集合和E（Edge）表示有限边的集合组成</p>
<p><strong><em>不考虑重边和自回路</em></strong></p>
<p><strong><em>V不能为空，E能为空</em></strong></p>
<p>图又可分为好几种类型，比如：</p>
<p>有向图与无向图</p>
<p>网络与非网络图（边是否有权重）</p>
<h1 id="在程序中表示一个图"><a href="#在程序中表示一个图" class="headerlink" title="在程序中表示一个图"></a>在程序中表示一个图</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><h3 id="无向图用一维矩阵代替二维矩阵"><a href="#无向图用一维矩阵代替二维矩阵" class="headerlink" title="无向图用一维矩阵代替二维矩阵"></a>无向图用一维矩阵代替二维矩阵</h3><p>假定G [N] [N] 矩阵，可以用一个长度为N(N+1)/2的一维矩阵A存储，则Gij在A中对应的下标是：<strong>i（i+1）/2+j</strong></p>
<h3 id="邻接矩阵的优势"><a href="#邻接矩阵的优势" class="headerlink" title="邻接矩阵的优势"></a>邻接矩阵的优势</h3><ol>
<li>直观，好理解</li>
<li>方便查找两个顶点之间是否存在边</li>
<li>方便查找一个顶点的邻接点（对于无向图，只需要查找一行，有向图要查找一行一列）</li>
<li>方便计算度</li>
</ol>
<h3 id="邻接矩阵的劣势"><a href="#邻接矩阵的劣势" class="headerlink" title="邻接矩阵的劣势"></a>邻接矩阵的劣势</h3><ol>
<li>对于稀疏图（点多边少）</li>
<li>若要统计图中边的数量，只能遍历完整个矩阵</li>
</ol>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>设置G[N]为指针数组，数组中每个单元都存放着一个链表（存放G[i]的临接点）</p>
<h3 id="邻接表的优势"><a href="#邻接表的优势" class="headerlink" title="邻接表的优势"></a>邻接表的优势</h3><ol>
<li>方便查找任一结点的所有“邻接点”</li>
<li>对于稀疏图节约空间：N个头指针+2E个结点（每个结点两个域）</li>
<li>对于无向图方便计算顶点的度</li>
</ol>
<h3 id="邻接表的劣势"><a href="#邻接表的劣势" class="headerlink" title="邻接表的劣势"></a>邻接表的劣势</h3><ol>
<li>对于边多点少的稠密图就不划算</li>
<li>对于有向图，只能计算出度；对于入度，需要构造逆邻接表（存指向自己的边）来方便计算入度</li>
<li>对于查找一对顶点间是否存在边很不方便</li>
</ol>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深搜（Depth-First-Search-DFS）"><a href="#深搜（Depth-First-Search-DFS）" class="headerlink" title="深搜（Depth First Search ,DFS）"></a>深搜（Depth First Search ,DFS）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void DFS(Vertex X)&#123;</span><br><span class="line">	visited[X] &#x3D; true;</span><br><span class="line">	for(V的每个临接点 W)</span><br><span class="line">		if(visited[W] &#x3D;&#x3D; false)</span><br><span class="line">			DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若有N个顶点，E条边，时间复杂度</p>
<ul>
<li>邻接表，O（N+E）</li>
<li>邻接矩阵，O(N2)</li>
</ul>
<h2 id="广搜（Breadth-First-Search）"><a href="#广搜（Breadth-First-Search）" class="headerlink" title="广搜（Breadth First Search）"></a>广搜（Breadth First Search）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Void BFS(Vertex V)&#123;</span><br><span class="line">	visited[V] &#x3D; true;</span><br><span class="line">	Enqueue(V,Q);</span><br><span class="line">	while(!IsEmpty(Q))&#123;</span><br><span class="line">		V &#x3D; Dequeue(Q);</span><br><span class="line">		for(V 的每个邻接点 W)</span><br><span class="line">			if(!visited[w])&#123;</span><br><span class="line">				visited[W] &#x3D; true;</span><br><span class="line">				Enqueue(W,Q);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若有N个顶点，E条边，时间复杂度</p>
<ul>
<li>邻接表，O（N+E）</li>
<li>邻接矩阵，O(N2)</li>
</ul>
<h1 id="图论的一些概念"><a href="#图论的一些概念" class="headerlink" title="图论的一些概念"></a>图论的一些概念</h1><p>连通 ：V到W存在一条路径，则称V和W是连通的</p>
<p>连通图: 图中任意两顶点均连通</p>
<p>连通分量： <strong><em>无向图</em></strong>的极大连通子图</p>
<p>​     极大顶点数</p>
<pre><code>极大边数</code></pre><p>强连通： <strong><em>有向图</em></strong>中顶点V和W之间存在双向路径</p>
<p>强连通图:  <strong><em>有向图</em></strong>中任意两顶点均强连通</p>
<p>强连通分量：有向图的极大连通子图</p>
<p>简单路径：V到W之间的所有顶点都不同</p>
<p>回路：起点等于终点的路径</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>File Transfer</title>
    <url>/2020/06/19/File-Transfer/</url>
    <content><![CDATA[<p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains <em>N</em> (2≤<em>N</em>≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and <em>N</em>. Then in the following lines, the input is given in the format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I c1 c2</span><br></pre></td></tr></table></figure>

<p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C c1 c2</span><br></pre></td></tr></table></figure>

<p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure>

<p>where <code>S</code> stands for stopping this case.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each <code>C</code> case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are <code>k</code> components.” where <code>k</code> is the number of connected components in this network.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">There are 2 components.</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">I 1 3</span><br><span class="line">C 1 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">The network is connected.</span><br></pre></td></tr></table></figure>



<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char c;</span><br><span class="line">int N;</span><br><span class="line">int pc[10005];</span><br><span class="line">int find(int a)&#123;</span><br><span class="line">	if(pc[a]&lt;0) return a;</span><br><span class="line">	else return pc[a] &#x3D; find(pc[a]);</span><br><span class="line">&#125;</span><br><span class="line">void input()&#123;</span><br><span class="line">	int t1,t2;</span><br><span class="line">	scanf(&quot;%d %d\n&quot;,&amp;t1,&amp;t2);</span><br><span class="line">	int root1,root2;</span><br><span class="line">	root1 &#x3D; find(t1);</span><br><span class="line">	root2 &#x3D; find(t2);</span><br><span class="line">	pc[root1] &#x3D; root2;</span><br><span class="line">&#125;</span><br><span class="line">void check()&#123;</span><br><span class="line">	int t1,t2;</span><br><span class="line">	scanf(&quot;%d %d\n&quot;,&amp;t1,&amp;t2);</span><br><span class="line">	if(find(t1) &#x3D;&#x3D; find(t2)) cout&lt;&lt;&quot;yes\n&quot;;</span><br><span class="line">	else cout&lt;&lt;&quot;no\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">void sum()&#123;</span><br><span class="line">	int a &#x3D; 0;</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">		if(pc[i] &#x3D;&#x3D; -1) a++;</span><br><span class="line">	if(a &#x3D;&#x3D; 1) cout&lt;&lt;&quot;The network is connected.\n&quot;;</span><br><span class="line">	else printf(&quot;There are %d components.\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d\n&quot;,&amp;N);</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">		pc[i] &#x3D; -1;</span><br><span class="line">	do&#123;</span><br><span class="line">		scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">		switch(c)&#123;</span><br><span class="line">			case &#39;I&#39;: input(); break;</span><br><span class="line">			case &#39;C&#39;: check(); break;</span><br><span class="line">			case &#39;S&#39;: sum(); break;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;while(c!&#x3D;&#39;S&#39;); 	&#x2F;&#x2F;不要忘了；</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>集合及运算</title>
    <url>/2020/06/19/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>定义：集合<strong><em>并，查</em></strong>某元素属于什么集合</p>
<p><em>双亲表示法：孩子指向双亲(与普通树的指针刚好相反)</em></p>
<h1 id="并查集存储"><a href="#并查集存储" class="headerlink" title="并查集存储"></a>并查集存储</h1><p>typedef struct{</p>
<p>​    ElementType Data;</p>
<p>​    int parent;</p>
<p>} SetType;</p>
<h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><h2 id="查找某个元素所在集合"><a href="#查找某个元素所在集合" class="headerlink" title="查找某个元素所在集合"></a>查找某个元素所在集合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Find(SetType S[],ElementType X)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i &#x3D; 0;i&lt;MaxSize &amp;&amp; S[i].data !&#x3D; X; i++);</span><br><span class="line">	if(i &gt;&#x3D; MaxSize) return -1; 	&#x2F;&#x2F;未找到X，返回-1</span><br><span class="line">	for(;S[i].parent &gt;&#x3D; 0; i &#x3D; S[i].Parent);</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合的并运算"><a href="#集合的并运算" class="headerlink" title="集合的并运算"></a>集合的并运算</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Union(SetType S[], ElementType X1, ElementType X2)&#123;</span><br><span class="line">	int root1, root2;</span><br><span class="line">	root1 &#x3D; Find(S,X1);</span><br><span class="line">	root2 &#x3D; Find(S,X2);</span><br><span class="line">	if(root1!&#x3D;root2) S[root2].parent &#x3D; Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>改写Find方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Find(SetType S[], ElementType X)&#123;</span><br><span class="line">	if(S[X]&lt;0)</span><br><span class="line">		return x;</span><br><span class="line">	else return S[X] &#x3D; Find(S,S[X]);	&#x2F;&#x2F;尾递归不用担心爆内存，编译器编译时会优化成循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树与哈夫曼编码</title>
    <url>/2020/06/18/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h1><p>哈夫曼树又称为最优二叉树，是WPL最小的二叉树</p>
<h1 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct TreeNode *HuffmanTree;</span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">	int Weight;</span><br><span class="line">	HuffmanTree Left,Right;</span><br><span class="line">&#125;</span><br><span class="line">HuffmanTree Huffman(MinHeap H)&#123;</span><br><span class="line">	int i; HuffmanTree T;</span><br><span class="line">	BuildMinHeap(H)	&#x2F;&#x2F;调整为最小堆</span><br><span class="line">	for(i &#x3D; 1;i&lt; H-&gt;Size;i++)&#123;	&#x2F;&#x2F;做H-&gt;size-1次合并</span><br><span class="line">		T &#x3D; malloc(sizeof(struct TreeNode));</span><br><span class="line">		T-&gt;Left &#x3D; DeleteMin(H);</span><br><span class="line">		T-&gt;Right &#x3D; DeleteMin(H);</span><br><span class="line">		T-&gt;Weight &#x3D; T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;</span><br><span class="line">		Insert(H,T);</span><br><span class="line">	&#125;</span><br><span class="line">	T &#x3D; DeleteMin(H);</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体复杂度NlogN。</p>
<h1 id="哈夫曼树特点"><a href="#哈夫曼树特点" class="headerlink" title="哈夫曼树特点"></a>哈夫曼树特点</h1><h2 id="没有度为1的节点"><a href="#没有度为1的节点" class="headerlink" title="没有度为1的节点"></a>没有度为1的节点</h2><h2 id="n个叶子结点的哈夫曼树共有2n-1个结点（n2-n0-1）"><a href="#n个叶子结点的哈夫曼树共有2n-1个结点（n2-n0-1）" class="headerlink" title="n个叶子结点的哈夫曼树共有2n-1个结点（n2 = n0-1）"></a>n个叶子结点的哈夫曼树共有2n-1个结点（n2 = n0-1）</h2><h2 id="任意非叶结点的左右子树交换仍是哈夫曼树"><a href="#任意非叶结点的左右子树交换仍是哈夫曼树" class="headerlink" title="任意非叶结点的左右子树交换仍是哈夫曼树"></a>任意非叶结点的左右子树交换仍是哈夫曼树</h2><h2 id="对于同一组权值，存在着不同构的两棵哈夫曼树-1-2-3-3"><a href="#对于同一组权值，存在着不同构的两棵哈夫曼树-1-2-3-3" class="headerlink" title="对于同一组权值，存在着不同构的两棵哈夫曼树({1,2,3,3})"></a>对于同一组权值，存在着不同构的两棵哈夫曼树({1,2,3,3})</h2><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>不等长编码，且可以避免二义性。</p>
<p>就是一种前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>哈夫曼</tag>
      </tags>
  </entry>
  <entry>
    <title>堆中的路径</title>
    <url>/2020/06/18/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每组测试第1行包含2个正整数<em>N</em>和<em>M</em>(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的<em>N</em>个要被插入一个初始为空的小顶堆的整数。最后一行给出<em>M</em>个下标。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure>

<hr>
<p>一开始解这道题的时候思路是先将这N个数字存储下来，再从最后一个具有子节点的节点开始向下调整。</p>
<p>但是这样解错了。</p>
<h3 id="自己的解法（错误）"><a href="#自己的解法（错误）" class="headerlink" title="自己的解法（错误）"></a>自己的解法（错误）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int a[1005],b[1005];</span><br><span class="line">void ajust(int index)&#123;</span><br><span class="line">	int parent;</span><br><span class="line">	int child;</span><br><span class="line">	int temp &#x3D; a[index];</span><br><span class="line">	for(parent &#x3D; index; parent*2&lt;&#x3D;N;parent &#x3D; child)&#123;</span><br><span class="line">		child &#x3D; 2*parent;</span><br><span class="line">		if((child!&#x3D;N) &amp;&amp; (a[child]&gt;a[child+1]))</span><br><span class="line">			child++;</span><br><span class="line">		if(temp&lt;&#x3D;a[child]) break;</span><br><span class="line">		else a[parent] &#x3D; a[child];</span><br><span class="line">	&#125;</span><br><span class="line">	a[parent] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void buildHeap()&#123;</span><br><span class="line">	for(int i &#x3D; N&#x2F;2 ;i&gt;0;i--)&#123;</span><br><span class="line">		ajust(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void printPath(int index)&#123;</span><br><span class="line">	int flag &#x3D; 1;</span><br><span class="line">	for(int i &#x3D; index;i&gt;0;i&#x3D;i&#x2F;2)&#123;</span><br><span class="line">		if(flag)&#123;</span><br><span class="line">			printf(&quot;%d&quot;,a[i]);</span><br><span class="line">			flag &#x3D; 0;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			printf(&quot; %d&quot;,a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">	a[0] &#x3D; -10001;</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;M;i++)&#123;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	buildHeap();</span><br><span class="line">&#x2F;&#x2F;	for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">&#x2F;&#x2F;		cout&lt;&lt; a[i];</span><br><span class="line">	for(int i &#x3D; 1;i&lt;&#x3D;M;i++)&#123;</span><br><span class="line">		printPath(b[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="正确的解法"><a href="#正确的解法" class="headerlink" title="正确的解法"></a>正确的解法</h3><p>该题目采用建立小顶堆的方式是逐个插入，逐个调整。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M;</span><br><span class="line">int a[1005];</span><br><span class="line">int size &#x3D; 0;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">	a[0] &#x3D; -10001;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">		int temp;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">		int j;</span><br><span class="line">		for(j &#x3D; ++size;a[j&#x2F;2]&gt;temp;j &#x3D; j&#x2F;2)&#123;</span><br><span class="line">			a[j] &#x3D; a[j&#x2F;2];</span><br><span class="line">		&#125;</span><br><span class="line">		a[j] &#x3D; temp;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">		int temp;</span><br><span class="line">		scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">		cout&lt;&lt;a[temp];</span><br><span class="line">		while(temp!&#x3D;1)&#123;</span><br><span class="line">			temp &#x3D; temp&#x2F;2;</span><br><span class="line">			cout&lt;&lt;&quot; &quot;&lt;&lt;a[temp];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;\n&quot;; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以发现，分别采用这两种方式构建小顶堆，结果是不一样的。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2020/06/17/%E5%A0%86/</url>
    <content><![CDATA[<h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><p>优先队列（Priority Queue）: 取出元素的顺序按优先权大小，而不是元素进入队列的先后顺序。</p>
<p>若堆可以用二叉搜索树来实现，插入操作时间效率就是对数级，删除操作也是对数级，但如果不断删除最大或最小的，树会歪掉，树的高度就不再是对数级别了。</p>
<h1 id="堆的两个特性"><a href="#堆的两个特性" class="headerlink" title="堆的两个特性"></a>堆的两个特性</h1><p>结构性：用数组表示的完全二叉树。</p>
<p>有序性：任一节点的关键字是其子树所有结点的最大值（或最小值）</p>
<h1 id="堆的操作集"><a href="#堆的操作集" class="headerlink" title="堆的操作集"></a>堆的操作集</h1> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct HeapStruct *MaxHeap;</span><br><span class="line">struct HeapStruct&#123;</span><br><span class="line">	ElementType *Elements;&#x2F;&#x2F; 存储堆元素的数组</span><br><span class="line">	int Size;&#x2F;&#x2F;堆当前元素个数</span><br><span class="line">	int Capacity;&#x2F;&#x2F;堆最大容量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MaxHeap Create(int MaxSize)&#123;</span><br><span class="line">	MaxHeap H &#x3D; malloc(sizeof(struct HeapStruct));</span><br><span class="line">	H-&gt;Elements &#x3D; malloc((MaxSize+1)*sizeof(ElementType));</span><br><span class="line">	H-&gt;Size &#x3D; 0;</span><br><span class="line">	H-&gt;Capacity &#x3D; MaxSize;</span><br><span class="line">	H-&gt;Elements[0] &#x3D; MaxData;&#x2F;&#x2F;作为哨兵，便于以后更快操作</span><br><span class="line">	return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Insert(MaxHeap H,ElementType item)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	if(isFull(H))&#123;</span><br><span class="line">		printf(&quot;最大堆已满&quot;)；</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	i &#x3D; ++H-&gt;Size;</span><br><span class="line">	for(;H-&gt;Elements[i&#x2F;2] &lt; item; i&#x2F;&#x3D;2)</span><br><span class="line">		H-&gt;Elements[i] &#x3D; H-&gt;Elements[i&#x2F;2];</span><br><span class="line">	H-&gt;Elements[i] &#x3D; item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ElementType DeleteMax(MaxHeap H)&#123;</span><br><span class="line">	&#x2F;&#x2F;取出键值最大的元素，并删除有一个节点</span><br><span class="line">	int Parent,Child;</span><br><span class="line">	ElementType MaxItem,temp;</span><br><span class="line">	if(isEmpty(H))&#123;</span><br><span class="line">		printf(&quot;最大堆已为空&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	MaxItem &#x3D; H-&gt;Elements[1];</span><br><span class="line">	for(Parent &#x3D; 1; Parent*2&lt;&#x3D;H-&gt;Size; Parent &#x3D; Child)&#123;</span><br><span class="line">		Child &#x3D; Parent * 2;</span><br><span class="line">		if((Child!&#x3D; H-&gt;Size) &amp;&amp; (H-&gt;Element[Child]&lt;H-&gt;Element[Child+1]))</span><br><span class="line">			Child++;</span><br><span class="line">		if( temp &gt;&#x3D; H-&gt;Elements[Child]) break;</span><br><span class="line">		else H-&gt;Elements[Parent] &#x3D; H-&gt;Elements[Child];</span><br><span class="line">	&#125;    </span><br><span class="line">	H-&gt;Elements[Parent] &#x3D; temp;</span><br><span class="line">	return MaxItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大堆的建立"><a href="#最大堆的建立" class="headerlink" title="最大堆的建立"></a>最大堆的建立</h2><p>将已经存在的N个元素按最大堆的要求放在一个一维数组中。</p>
<p>方法1：将N个元素一个个相继插入到一个初始为空的堆中去，时间代价为NlogN。</p>
<p>方法2：（1）将N个元素顺序存入，先满足完全二叉树的结构特性。（2）调节各节点位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void PercDown(MaxHeap H,int p)&#123;</span><br><span class="line">	int Parent,Child;</span><br><span class="line">	ElementType X;</span><br><span class="line">	X &#x3D; H-&gt;Data[p];</span><br><span class="line">	for(Parent &#x3D; p; Parent*2&lt;&#x3D;H-&gt;Size; Parent &#x3D; Child)&#123;</span><br><span class="line">		Child &#x3D; Parent*2;</span><br><span class="line">		if((Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]))</span><br><span class="line">			Child++;</span><br><span class="line">		if(X&gt;&#x3D;H-&gt;Data[Child]) break;</span><br><span class="line">		else H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];</span><br><span class="line">	&#125;</span><br><span class="line">	H-&gt;Data[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line">void BuildHeap(MaxHeap H)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i &#x3D; H-&gt;Size&#x2F;2;i&gt;0;i--)</span><br><span class="line">		PercDown(H,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>Root of AVL Tree</title>
    <url>/2020/06/08/Root-of-AVL-Tree/</url>
    <content><![CDATA[<p>1066 Root of AVL Tree (25分)</p>
<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p>
<p><img src="https://images.ptausercontent.com/31" alt="img"> <img src="https://images.ptausercontent.com/32" alt="img"></p>
<p><img src="https://images.ptausercontent.com/33" alt="img"> <img src="https://images.ptausercontent.com/34" alt="img"></p>
<p>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤20) which is the total number of keys to be inserted. Then <em>N</em> distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure>



<h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N;</span><br><span class="line">struct Node&#123;</span><br><span class="line">	Node* l;</span><br><span class="line">	Node* r;</span><br><span class="line">	int data;</span><br><span class="line">	int height;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int getHeight(Node* root)&#123;</span><br><span class="line">	if(!root) return 0;</span><br><span class="line">	return root-&gt;height; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void updateHeight(Node* root)&#123;</span><br><span class="line">	root-&gt;height &#x3D; max(getHeight(root-&gt;l),getHeight(root-&gt;r))+1; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void R(Node* &amp;root)&#123;</span><br><span class="line">	Node* temp &#x3D; root-&gt;l;</span><br><span class="line">	root-&gt;l &#x3D; root-&gt;l-&gt;r;</span><br><span class="line">	temp-&gt;r &#x3D; root;</span><br><span class="line">	updateHeight(root);</span><br><span class="line">	updateHeight(temp);</span><br><span class="line">	root &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void L(Node* &amp;root)&#123;</span><br><span class="line">	Node* temp &#x3D; root-&gt;r;</span><br><span class="line">	root-&gt;r &#x3D; root-&gt;r-&gt;l;</span><br><span class="line">	temp-&gt;l &#x3D; root;</span><br><span class="line">	updateHeight(root);</span><br><span class="line">	updateHeight(temp);</span><br><span class="line">	root &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">Node* newNode(int t)&#123;</span><br><span class="line">	Node* node &#x3D; new Node();</span><br><span class="line">	node-&gt;l &#x3D; node-&gt;r &#x3D; NULL;</span><br><span class="line">	node-&gt;data &#x3D; t;</span><br><span class="line">	node-&gt;height &#x3D; 1;</span><br><span class="line">	return node; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int getBalanceFactor(Node* root)&#123;</span><br><span class="line">	return getHeight(root-&gt;l) - getHeight(root-&gt;r);</span><br><span class="line">&#125; </span><br><span class="line">void insert(int t,Node* &amp;node)&#123;</span><br><span class="line">	if(!node)&#123;</span><br><span class="line">		node &#x3D; newNode(t);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(node-&gt;data&lt;t)&#123;</span><br><span class="line">		insert(t,node-&gt;r);</span><br><span class="line">		updateHeight(node);</span><br><span class="line">		if(getBalanceFactor(node) &#x3D;&#x3D; -2)&#123;</span><br><span class="line">			if(getBalanceFactor(node-&gt;r) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">				L(node);</span><br><span class="line">			&#125;else if(getBalanceFactor(node-&gt;r) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">				R(node-&gt;r);</span><br><span class="line">				L(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		insert(t,node-&gt;l);</span><br><span class="line">		updateHeight(node);</span><br><span class="line">		if(getBalanceFactor(node) &#x3D;&#x3D; 2)&#123;</span><br><span class="line">			if(getBalanceFactor(node-&gt;l) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">				R(node);</span><br><span class="line">			&#125;else if(getBalanceFactor(node-&gt;l) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">				L(node-&gt;l);</span><br><span class="line">				R(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	Node* node &#x3D; NULL; </span><br><span class="line">	for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">		int temp &#x3D; 0;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		insert(temp,node);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;node-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>是否同一棵二叉搜索树</title>
    <url>/2020/06/08/%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数<em>N</em> (≤10)和<em>L</em>，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出<em>N</em>个以空格分隔的正整数，作为初始插入序列。最后<em>L</em>行，每行给出<em>N</em>个插入的元素，属于<em>L</em>个需要检查的序列。</p>
<p>简单起见，我们保证每个插入序列都是1到<em>N</em>的一个排列。当读到<em>N</em>为0时，标志输入结束，这组数据不要处理。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,L;</span><br><span class="line">struct node&#123;</span><br><span class="line">	int v;</span><br><span class="line">	node* l;</span><br><span class="line">	node* r;</span><br><span class="line">	int flag;</span><br><span class="line">&#125;;</span><br><span class="line">node* addNode(int value,node* root)&#123;</span><br><span class="line">	if(!root)&#123;</span><br><span class="line">		node* temp &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">		temp-&gt;l &#x3D; NULL;</span><br><span class="line">		temp-&gt;r &#x3D; NULL;</span><br><span class="line">		temp-&gt;v &#x3D; value;</span><br><span class="line">		temp-&gt;flag &#x3D; 0;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125; </span><br><span class="line">	if(value&lt;root-&gt;v) root-&gt;l &#x3D; addNode(value,root-&gt;l);</span><br><span class="line">	else root-&gt;r &#x3D; addNode(value,root-&gt;r);</span><br><span class="line">	return root; </span><br><span class="line">&#125;</span><br><span class="line">int check(node* root,int temp)&#123;</span><br><span class="line">	if(!root) return 0;</span><br><span class="line">	if((root-&gt;flag &#x3D;&#x3D; 0)&amp;&amp;(root-&gt;v!&#x3D;temp)) return 0;</span><br><span class="line">	if((root-&gt;flag &#x3D;&#x3D; 0)&amp;&amp;(root-&gt;v&#x3D;&#x3D;temp))&#123;</span><br><span class="line">		root-&gt;flag &#x3D; 1;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	if((root-&gt;flag &#x3D;&#x3D; 1)&amp;&amp;(root-&gt;v!&#x3D;temp))&#123;</span><br><span class="line">		if(root-&gt;v&gt;temp) return check(root-&gt;l,temp);</span><br><span class="line">		else return check(root-&gt;r,temp);</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">void reset(node* root)&#123;</span><br><span class="line">	if(!root) return;</span><br><span class="line">	root-&gt;flag &#x3D; 0;</span><br><span class="line">	reset(root-&gt;l);</span><br><span class="line">	reset(root-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	 while(true)&#123;</span><br><span class="line">	 	scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">	 	if(N&#x3D;&#x3D;0) break;</span><br><span class="line">	 	scanf(&quot;%d&quot;,&amp;L);</span><br><span class="line">	 	node* root &#x3D; NULL; </span><br><span class="line">	 	for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">	 		int temp;</span><br><span class="line">	 		scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">	 		root &#x3D; addNode(temp,root);</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i&#x3D;0;i&lt;L;i++)&#123;</span><br><span class="line">			int temp,flag &#x3D; 1,flag2 &#x3D; 1;</span><br><span class="line">			for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">				flag &#x3D; check(root,temp);</span><br><span class="line">				if((flag &#x3D;&#x3D; 0)&amp;&amp;(flag2 &#x3D;&#x3D; 1))&#123;</span><br><span class="line">					cout&lt;&lt;&quot;No\n&quot;;</span><br><span class="line">					flag &#x3D; 0;</span><br><span class="line">					flag2 &#x3D; 0;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(flag2 &#x3D;&#x3D; 1) cout&lt;&lt;&quot;Yes\n&quot;;</span><br><span class="line">			reset(root);</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的操作集</title>
    <url>/2020/06/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86/</url>
    <content><![CDATA[<p>6-12 二叉搜索树的操作集 (30分)</p>
<p>本题要求实现给定二叉搜索树的5种常用操作。</p>
<h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中<code>BinTree</code>结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li>
<li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li>
<li>函数<code>Find</code>在二叉搜索树<code>BST</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li>
<li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li>
<li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li>
</ul>
<h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">( BinTree BT )</span></span>; <span class="comment">/* 先序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">( BinTree BT )</span></span>;  <span class="comment">/* 中序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="keyword">int</span> N, i;</span><br><span class="line"></span><br><span class="line">    BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        BST = Insert(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Preorder:"</span>); PreorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    MinP = FindMin(BST);</span><br><span class="line">    MaxP = FindMax(BST);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        Tmp = Find(BST, X);</span><br><span class="line">        <span class="keyword">if</span> (Tmp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">"%d is not found\n"</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is found\n"</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MinP) <span class="built_in">printf</span>(<span class="string">"%d is the smallest key\n"</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MaxP) <span class="built_in">printf</span>(<span class="string">"%d is the largest key\n"</span>, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        BST = Delete(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Inorder:"</span>); InorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure>

<h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">5 8 6 2 4 1 0 10 9 7</span><br><span class="line">5</span><br><span class="line">6 3 10 0 5</span><br><span class="line">5</span><br><span class="line">5 7 0 10 3</span><br></pre></td></tr></table></figure>

<h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Preorder: 5 2 1 0 4 8 6 7 10 9</span><br><span class="line">6 is found</span><br><span class="line">3 is not found</span><br><span class="line">10 is found</span><br><span class="line">10 is the largest key</span><br><span class="line">0 is found</span><br><span class="line">0 is the smallest key</span><br><span class="line">5 is found</span><br><span class="line">Not Found</span><br><span class="line">Inorder: 1 2 4 6 8 9</span><br></pre></td></tr></table></figure>



<h3 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BinTree Insert( BinTree BST, ElementType X )&#123;</span><br><span class="line">	if(!BST)&#123;</span><br><span class="line">		BST &#x3D; (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">		BST-&gt;Data &#x3D; X;</span><br><span class="line">		BST-&gt;Left &#x3D; NULL;</span><br><span class="line">		BST-&gt;Right &#x3D; NULL;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		if(X&lt;BST-&gt;Data) BST-&gt;Left &#x3D; Insert(BST-&gt;Left,X); 	&#x2F;&#x2F;插入操作需要先找到插入位置，但函数一到达插入位置， </span><br><span class="line">		else BST-&gt;Right &#x3D; Insert(BST-&gt;Right,X);				&#x2F;&#x2F;就无法记住父亲节点位置，所以采用递归方式，返回插入位置的地址给上一层。 </span><br><span class="line">	&#125;</span><br><span class="line">	return BST;</span><br><span class="line">&#125;</span><br><span class="line">Position Find( BinTree BST, ElementType X )&#123;</span><br><span class="line">	if(!BST)&#123;</span><br><span class="line">		return BST;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		if(BST-&gt;Data &#x3D;&#x3D; X) return BST;</span><br><span class="line">		else if(BST-&gt;Data &lt; X) Find(BST-&gt;Right,X);</span><br><span class="line">		else Find(BST-&gt;Left,X);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Position FindMin( BinTree BST )&#123;</span><br><span class="line">	if(!BST) return BST;</span><br><span class="line">	if(!BST-&gt;Left) return BST;</span><br><span class="line">	else FindMin(BST-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line">Position FindMax( BinTree BST )&#123;</span><br><span class="line">	if(!BST) return BST;</span><br><span class="line">	if(!BST-&gt;Right) return BST;</span><br><span class="line">	else FindMax(BST-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line">BinTree Delete( BinTree BST, ElementType X )&#123;</span><br><span class="line">	if(!BST)&#123;</span><br><span class="line">		printf(&quot;Not Found\n&quot;);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		if(BST-&gt;Data &lt; X)&#123;</span><br><span class="line">			BST-&gt;Right &#x3D; Delete(BST-&gt;Right,X);</span><br><span class="line">		&#125;else if(BST-&gt;Data &gt; X)&#123;</span><br><span class="line">			BST-&gt;Left &#x3D; Delete(BST-&gt;Left,X);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			BinTree temp &#x3D; BST;</span><br><span class="line">			if(!BST-&gt;Left)&#123;</span><br><span class="line">				BST &#x3D; BST-&gt;Right;</span><br><span class="line">				free(temp);</span><br><span class="line">			&#125;else if(!BST-&gt;Right)&#123;</span><br><span class="line">				BST &#x3D; BST-&gt;Left;</span><br><span class="line">				free(temp);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				temp &#x3D; FindMin(BST-&gt;Right);</span><br><span class="line">				BST-&gt;Data &#x3D; temp-&gt;Data;</span><br><span class="line">				BST-&gt;Right &#x3D; Delete(BST-&gt;Right,BST-&gt;Data);</span><br><span class="line">			&#125; 	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	 return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>AVL树</title>
    <url>/2020/06/07/AVL%E6%A0%91/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​    AVL树是一种特殊的二叉查找树，但对AVL树来说，左子树和右子树的高度差的绝对值不超过1，高度之差被称为<strong><em>平衡因子</em></strong>。</p>
<p>​    AVL树能使每次插入元素后树高度仍能保持O（logn）的级别（也就是查找时间也为O(logn)）</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void search(node* root,int x)&#123;</span><br><span class="line">	if(root &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">		printf(&quot;search failed\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(x &#x3D;&#x3D; root-&gt;data)&#123;</span><br><span class="line">		printf(&quot;success&quot;);</span><br><span class="line">	&#125;else if(x &lt; root-&gt;data)&#123;</span><br><span class="line">		search(root-&gt;left,x)</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		search(root-&gt;right,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void L(node* &amp;root)&#123;</span><br><span class="line">	node* temp &#x3D; root-&gt;rchild;</span><br><span class="line">	root-&gt;rchild &#x3D; temp-&gt;lchild;</span><br><span class="line">	temp-&gt;lchild &#x3D; root;</span><br><span class="line">	root &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void R(node* &amp;root)&#123;</span><br><span class="line">	node* temp &#x3D; root-&gt;lchild;</span><br><span class="line">	root-&gt;lchild &#x3D; temp-&gt;rchild;</span><br><span class="line">	tmep-&gt;rchild &#x3D; root;</span><br><span class="line">	root &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LL型旋转"><a href="#LL型旋转" class="headerlink" title="LL型旋转"></a>LL型旋转</h3><p><a href="/1.png">LL</a></p>
<p>4,6看成整体，以1为根右旋</p>
<h3 id="LR型旋转"><a href="#LR型旋转" class="headerlink" title="LR型旋转"></a>LR型旋转</h3><p><a href="/2.png">LR</a></p>
<p>先以2为根左旋，旋转结束后变为LL型，再以1节点为跟右旋。</p>
<h3 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">	int v,height;</span><br><span class="line">	node* lchild,node* rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node* newNode(int v)&#123;</span><br><span class="line">	node* Node &#x3D; new node;</span><br><span class="line">	Node-&gt;v &#x3D; v;</span><br><span class="line">	Node-&gt;height &#x3D; 1;</span><br><span class="line">	Node-&gt;lchild &#x3D; Node-&gt;rchild &#x3D; NULL;</span><br><span class="line">	return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getHeight(node* root)&#123;</span><br><span class="line">	if(root &#x3D;&#x3D; NULL) return 0;</span><br><span class="line">	return root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getBalanceFactor(node* root)&#123;</span><br><span class="line">	return getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void updateHeight(node* root)&#123;</span><br><span class="line">	root-&gt;hegith &#x3D; max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(node* &amp;root,int v)&#123;</span><br><span class="line">	if(root &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">		root &#x3D; newNode(v);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	if(v&lt;root-&gt;v)&#123;</span><br><span class="line">		insert(root-&gt;lchild,v);</span><br><span class="line">		uodateHeight(root);</span><br><span class="line">		if(getBalanceFactor(root) &#x3D;&#x3D; 2)&#123;</span><br><span class="line">			if(getBalanceFactor(root-&gt;lchild) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">				R(root);</span><br><span class="line">			&#125;else if(getBalanceFactor(root-&gt;lchild) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">				L(root-&gt;lchild);</span><br><span class="line">				R(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		insert(root-&gt;child,v);</span><br><span class="line">		updateHeight(root);</span><br><span class="line">		if(getBalanceFactor(root) &#x3D;&#x3D; -2)&#123;</span><br><span class="line">			if(getBalanceFactor(root) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">				L(root);</span><br><span class="line">			&#125;else if(getBalanceFactor(root-&gt;rchild) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">				R(root-&gt;rchild);</span><br><span class="line">				L(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AVL树的建立"><a href="#AVL树的建立" class="headerlink" title="AVL树的建立"></a>AVL树的建立</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node* Create(int data[],int n)&#123;</span><br><span class="line">	node* root &#x3D; NULL;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">		insert(root,data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title>List Leaves</title>
    <url>/2020/06/02/List-Leaves/</url>
    <content><![CDATA[<p>Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to <em>N</em>−1. Then <em>N</em> lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">1 -</span><br><span class="line">- -</span><br><span class="line">0 -</span><br><span class="line">2 7</span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line">5 -</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1 5</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">	int b,c;</span><br><span class="line">&#125;;</span><br><span class="line">node n[12];</span><br><span class="line">int check[12];</span><br><span class="line">int find(node n[])&#123;</span><br><span class="line">	int N,i;</span><br><span class="line">	char l,r;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">	getchar();</span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">		scanf(&quot;%c %c&quot;,&amp;l,&amp;r);</span><br><span class="line">		getchar();</span><br><span class="line">		if(l!&#x3D;&#39;-&#39;)&#123;</span><br><span class="line">			n[i].b &#x3D; l-&#39;0&#39;;</span><br><span class="line">			check[n[i].b] &#x3D; 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			n[i].b &#x3D; -1;</span><br><span class="line">		&#125;</span><br><span class="line">		if(r!&#x3D;&#39;-&#39;)&#123;</span><br><span class="line">			n[i].c &#x3D; r-&#39;0&#39;;</span><br><span class="line">			check[n[i].c] &#x3D; 1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			n[i].c &#x3D; -1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">		if(check[i] &#x3D;&#x3D; 0)</span><br><span class="line">			break;</span><br><span class="line">	return i;</span><br><span class="line">&#125; </span><br><span class="line">int flag &#x3D; 0;</span><br><span class="line">void print(int root)&#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	int flag &#x3D; 0;</span><br><span class="line">	if(root!&#x3D;-1)&#123;</span><br><span class="line">		q.push(root);</span><br><span class="line">		while(!q.empty())&#123;</span><br><span class="line">			int top &#x3D; q.front();</span><br><span class="line">			q.pop();</span><br><span class="line">			if((n[top].b &#x3D;&#x3D; -1)&amp;&amp;(n[top].c &#x3D;&#x3D; -1))&#123;</span><br><span class="line">				if(flag)</span><br><span class="line">					printf(&quot; %d&quot;,top);</span><br><span class="line">				else&#123;</span><br><span class="line">					printf(&quot;%d&quot;,top);</span><br><span class="line">					flag &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				if(n[top].b!&#x3D;-1)</span><br><span class="line">					q.push(n[top].b);</span><br><span class="line">				if(n[top].c!&#x3D;-1)</span><br><span class="line">					q.push(n[top].c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int root &#x3D; find(n); </span><br><span class="line">	print(root);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>层级遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>Pop Sequence</title>
    <url>/2020/05/28/Pop-Sequence/</url>
    <content><![CDATA[<p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>

<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944" target="_blank" rel="noopener">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int M,N,K;</span><br><span class="line">int main()&#123;</span><br><span class="line">	cin&gt;&gt;M&gt;&gt;N&gt;&gt;K;</span><br><span class="line">	vector&lt;int&gt; v(N+1);</span><br><span class="line">	while(K--)&#123;</span><br><span class="line">		stack&lt;int&gt; s;</span><br><span class="line">		for(int i &#x3D; 1;i &lt;&#x3D; N;i++)</span><br><span class="line">			cin&gt;&gt;v[i];</span><br><span class="line">		int current &#x3D; 1;</span><br><span class="line">		for(int i &#x3D; 1;i &lt;&#x3D; N;i++)&#123;</span><br><span class="line">			s.push(i);</span><br><span class="line">			if(s.size()&gt;M) break;</span><br><span class="line">			while(!s.empty()&amp;&amp;s.top()&#x3D;&#x3D;v[current])&#123;</span><br><span class="line">				s.pop();</span><br><span class="line">				current++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(current &#x3D;&#x3D; N+1) cout&lt;&lt;&quot;YES\n&quot;;</span><br><span class="line">		else cout&lt;&lt;&quot;NO\n&quot;;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>current确定当前扫描到第几个位置。</p>
<p>栈只需要从1顺序进，每进一个就while循环，判断栈顶和current当前位置，只要对上了，current往后走，栈不停弹出。</p>
<p>判断成功的方法：current最后到了N+1，也就是前面都通过检验。</p>
<p>这里就相当于一个证明题：对于一个命题，错与对哪个好证明，就证明哪个，最后用反证法。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Reversing Linked List</title>
    <url>/2020/05/28/Reversing-Linked-List/</url>
    <content><![CDATA[<p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>
<p>Then <em>N</em> lines follow, each describes a node in the format:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure>

<p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure>

<p><a href="https://pintia.cn/problem-sets/1211841066264109056/problems/1231458941036285954" target="_blank" rel="noopener">链接</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int temp,data[100005],nex[100005],lis[100005],ans[100005];</span><br><span class="line">int main()&#123;</span><br><span class="line">	int first,k,n,sum &#x3D; 0;</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;temp;</span><br><span class="line">		cin&gt;&gt;data[temp]&gt;&gt;nex[temp];</span><br><span class="line">	&#125;</span><br><span class="line">	while(first!&#x3D;-1)&#123;</span><br><span class="line">		lis[sum++] &#x3D; first;</span><br><span class="line">		first &#x3D; nex[first];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i &#x3D; 0;i&lt;sum;i++) ans[i] &#x3D; lis[i];</span><br><span class="line">	for(int i &#x3D; 0;i&lt;(sum-sum%k);i++)&#123;&#x2F;&#x2F;反转范围为前k的整数倍,后面剩余部分不动</span><br><span class="line">		ans[i] &#x3D; lis[i&#x2F;k*k+k-1-i%k];&#x2F;&#x2F;i&#x2F;k*k确定第几组反转的起步位置，k-1-i%k控制组内的顺序移动</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i &#x3D; 0;i&lt;sum-1;i++)</span><br><span class="line">		printf(&quot;%05d %d %05d\n&quot;,ans[i],data[ans[i]],ans[i+1]);</span><br><span class="line">	printf(&quot;%05d %d -1\n&quot;,ans[sum-1],data[ans[sum-1]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里采用数组模拟链表</p>
<p>对于节点元素：value,next；</p>
<p>分别用两个数组模拟,数组下标为节点地址，只要有节点地址，就能通过访问两个数组获取相应的值；</p>
<p>对于翻转，只要关注节点排列的顺序就行了。</p>
<p>lis数组存储链表上节点的顺序依次地址。</p>
<p>ans来存储lis按照一定k值重写排列的地址。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>一元多项式的乘法与加法运算</title>
    <url>/2020/05/28/%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>设计函数分别求两个一元多项式的乘积与和。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure>

<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure>



<p><a href="https://pintia.cn/problem-sets/434/problems/5865" target="_blank" rel="noopener">链接</a></p>
<p>解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">	int co;</span><br><span class="line">	int ex;</span><br><span class="line">	node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void attach(node** rear,int a,int b)&#123;</span><br><span class="line">	node* temp &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">	temp-&gt;co &#x3D; a;</span><br><span class="line">	temp-&gt;ex &#x3D; b;</span><br><span class="line">	temp-&gt;next &#x3D; NULL;</span><br><span class="line">	(*rear)-&gt;next &#x3D; temp;</span><br><span class="line">	(*rear) &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">node* read()&#123;</span><br><span class="line">	int c;</span><br><span class="line">	cin&gt;&gt;c;</span><br><span class="line">	node* p &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">	p-&gt;next &#x3D; NULL;</span><br><span class="line">	node* rear &#x3D; p;</span><br><span class="line">	while(c--)&#123;</span><br><span class="line">		int a,b;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		attach(&amp;rear,a,b);</span><br><span class="line">	&#125;</span><br><span class="line">	node* t &#x3D; p-&gt;next;</span><br><span class="line">	free(p);</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">node* plu(node* a,node* b)&#123;</span><br><span class="line">	node* p &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">	node* rear &#x3D; p;</span><br><span class="line">	p-&gt;next &#x3D; NULL;</span><br><span class="line">	while(a&amp;&amp;b)&#123;</span><br><span class="line">		if(a-&gt;ex&gt;b-&gt;ex)&#123;</span><br><span class="line">			attach(&amp;rear,a-&gt;co,a-&gt;ex);</span><br><span class="line">			a &#x3D; a-&gt;next;</span><br><span class="line">		&#125;else if(a-&gt;ex&lt;b-&gt;ex)&#123;</span><br><span class="line">			attach(&amp;rear,b-&gt;co,b-&gt;ex);</span><br><span class="line">			b &#x3D; b-&gt;next;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			if(a-&gt;co+b-&gt;co !&#x3D; 0)&#123;</span><br><span class="line">				attach(&amp;rear,a-&gt;co+b-&gt;co,a-&gt;ex);	</span><br><span class="line">			&#125; </span><br><span class="line">			a &#x3D; a-&gt;next;</span><br><span class="line">			b &#x3D; b-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(a)&#123;</span><br><span class="line">		attach(&amp;rear,a-&gt;co,a-&gt;ex);</span><br><span class="line">		a &#x3D; a-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	while(b)&#123;</span><br><span class="line">		attach(&amp;rear,b-&gt;co,b-&gt;ex);</span><br><span class="line">		b &#x3D; b-&gt;next; </span><br><span class="line">	&#125; </span><br><span class="line">	node* t &#x3D; p-&gt;next;</span><br><span class="line">	free(p);</span><br><span class="line">	return t;</span><br><span class="line">&#125;</span><br><span class="line">void print(node* a)&#123;</span><br><span class="line">	if(!a) printf(&quot;0 0&quot;);</span><br><span class="line">	else&#123;</span><br><span class="line">		bool flag &#x3D; false;</span><br><span class="line">		while(a)&#123;</span><br><span class="line">			if(!flag)&#123;</span><br><span class="line">				cout&lt;&lt;a-&gt;co&lt;&lt;&quot; &quot;&lt;&lt;a-&gt;ex;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				cout&lt;&lt;&quot; &quot;&lt;&lt;a-&gt;co&lt;&lt;&quot; &quot;&lt;&lt;a-&gt;ex;</span><br><span class="line">			&#125;</span><br><span class="line">			a &#x3D; a-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">node* muti(node* a,node* b)&#123;</span><br><span class="line">	node* p &#x3D; NULL;</span><br><span class="line">	if(!a||!b) return NULL;</span><br><span class="line">	while(a)&#123;</span><br><span class="line">		node* temp &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">		temp-&gt;next &#x3D; NULL;</span><br><span class="line">		node* bp &#x3D; b;</span><br><span class="line">		node* rear &#x3D; temp; </span><br><span class="line">		while(bp)&#123;</span><br><span class="line">			attach(&amp;rear,a-&gt;co*bp-&gt;co,a-&gt;ex+bp-&gt;ex);</span><br><span class="line">			bp &#x3D; bp-&gt;next;</span><br><span class="line">		&#125; </span><br><span class="line">		node* t &#x3D; temp-&gt;next;</span><br><span class="line">		free(temp);</span><br><span class="line">		p &#x3D; plu(p,t);</span><br><span class="line">		a &#x3D; a-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	node* a &#x3D; read();</span><br><span class="line">	node* b &#x3D; read();</span><br><span class="line">	node* c &#x3D; muti(a,b);</span><br><span class="line">	print(c);</span><br><span class="line">	cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">	c &#x3D; plu(a,b);</span><br><span class="line">	print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>1、在用malloc创建节点时，不要忘了对里面的指针初始化。</p>
<p>2、attach函数参数为node**，这是指针的指针，目的是更改指向节点的指针的值（需要不断更改rear的位置）</p>
<p>node** a（b的内存地址）</p>
<p>-&gt;node* b(c的内存地址)</p>
<p>-&gt;node c</p>
<p>更改c的属性值： b-&gt;value = xxx;（*a）-&gt;value = xxx;</p>
<p>更改b的值： (*a) = xxx;</p>
<p>3、注意代码的可重用性，这里的乘法就可以用到加法。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title>Maximum Subsequence Sum</title>
    <url>/2020/05/26/Maximum-Subsequence-Sum/</url>
    <content><![CDATA[<p><a href="https://pintia.cn/problem-sets/1211841066264109056/problems/1211848231062290433" target="_blank" rel="noopener">链接</a></p>
<p>Given a sequence of <em>K</em> integers { <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }. A continuous subsequence is defined to be { <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>
<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure>



<p>解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int k,arr[100000];</span><br><span class="line">int cmax,rmax &#x3D; -1;</span><br><span class="line">int l,r,temp;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    for(int i &#x3D; 0;i&lt;k;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 0;i&lt;k;i++)&#123;</span><br><span class="line">        cmax+&#x3D;arr[i];</span><br><span class="line">        if(rmax&lt;cmax)&#123;</span><br><span class="line">            r &#x3D; i;</span><br><span class="line">            l &#x3D; temp;</span><br><span class="line">            rmax &#x3D; cmax;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cmax&lt;0)&#123;</span><br><span class="line">            cmax &#x3D; 0;</span><br><span class="line">            temp &#x3D; i+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(rmax &lt; 0 )</span><br><span class="line">        cout &lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;arr[0]&lt;&lt;&quot; &quot;&lt;&lt;arr[k-1];</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt; rmax&lt;&lt;&quot; &quot;&lt;&lt;arr[l]&lt;&lt;&quot; &quot;&lt;&lt;arr[r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、设置左边界的时机，需要通过temp临时存储，当cmax&lt;0,可以肯定的是左边界在后面一个，但此时不能直接修改l，例如：3 -4 -5，直接修改会产生错误。所以需要在cmax&gt;rmax时修改。</p>
<p>2、rmax初值需要设置为负数，如果默认0，例如 0,0,0,0。结果会输出第一个和最后一个，导致错误。</p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
        <tag>动态规划，最⼤大连续⼦子序列列和</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.5.13</title>
    <url>/2020/05/13/2020-5-13/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
  </entry>
  <entry>
    <title>王阳明心学及其现代意义</title>
    <url>/2020/05/09/%E7%8E%8B%E9%98%B3%E6%98%8E%E5%BF%83%E5%AD%A6%E5%8F%8A%E5%85%B6%E7%8E%B0%E4%BB%A3%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>王阳明心学就是中国人生哲学的最高成果。</p>
<p>在自己的成长过程中形成自己的精神家园。</p>
<p>安心立命。</p>
<p>人生富贵穷通，莫非命也。</p>
<p>生活的阅历积累道一定程度，每个人都有自己的命。</p>
<p>出生于怎样家庭，怎样父母成了我，这些事情不容我选择。</p>
<p>孟子说：人生总要有所求</p>
<p>求有两种：</p>
<p>求则得之，舍则失之；是求有益于得也，求在我者也。</p>
<p>求之有道，得之有命，是求无益于得也，求在外者也。</p>
<p>为何要重温阳明心学？</p>
<p>今日之中国，重欲汹汹，各种的欲望。</p>
<p>改革开放30年，中华名族形成这样一个民风：各释其能，各谋其力，纷争交给法律，前途交给偶然。</p>
<p>当然这无可厚非。</p>
<p>但这民风伴随重功利，清道义。名族将内不能安，外不能立。</p>
<p>GDP增长极快，有大量资本。一个名族不能因为货币，成为一个名族安身立命之根本。</p>
<p>社会信任的普遍危机是当代中国最基本的品质。</p>
<p>什么是心？</p>
<p>烦恼来自于心</p>
<p>能生出烦恼的心最难对付。</p>
<p>孔子论语中说：“不仁者（心没有安顿的人），不可以久处约（贫贱的生活处境），不可以长处乐（富贵的生活环境）。</p>
<p>我们有无限心，人在每一个瞬间筹划着未来，这是我们心得无限面，心超越事实，在筹划不存在的未来。烦恼与精彩都从中来。</p>
<p>无限心无法安顿在有限事物上。</p>
<p>如何安顿?</p>
<p>第一步 处世（超越现实世界）</p>
<p>第二步 入世</p>
<p>以出世的精神做入世的事情</p>
<p>中国哲学的境界有三条出世的路</p>
<p>儒：无所为而为</p>
<p>没有失败的人生，做一件事情就为了自己的价值</p>
<p>知己不可为而为之。</p>
<p>道：无为而无不为</p>
<p>人的幸福来自天，苦恼来自自己。</p>
<p>不为：不造作的事情</p>
<p>为道日损，损之又损。</p>
<p>生非贵之，所能存。生非爱之，所能厚。</p>
<p>了解天道，就是减去人为的东西。顺应去做。</p>
<p>做减法的方法在老庄的著作里。</p>
<p>佛家：无心而为</p>
<p>认真做，不求结果，除人心，不除事。</p>
<p>中国哲学就是人生哲学，如何安排最难安排的生命?</p>
<p>欧洲基督教</p>
<p>阿拉伯伊斯兰教</p>
<p>这些地区的出世路为宗教</p>
<p>生有涯，知无涯，以有涯随无涯，殆己！</p>
<p>什么是心学?</p>
<p>孟子：善端（根源）</p>
<p>孔子论道为仁</p>
<p>荀子：生物来自本能，人生来就恶。</p>
<p>孟子：避免利益纠纷而有道德，避免社会解体。</p>
<p>荀子认为智力高于动物，人发明道德。</p>
<p>孟子认为道德来自于心</p>
<p>恻隐</p>
<p>羞恶</p>
<p>辞让</p>
<p>是非</p>
<p>heart 生物学</p>
<p>mind 心理学</p>
<p>GEMUTE</p>
<p>良知乃是天理昭明灵觉处，故良知即是天理。</p>
<p>“心即理”（阳明学第一命题）</p>
<p>万物皆备于我，反心而诚善莫大焉。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学导论第5课</title>
    <url>/2020/05/03/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E7%AC%AC5%E8%AF%BE/</url>
    <content><![CDATA[<p>一个名族的思想境界如果不能提升，就没办法寻找真理，理解面临困境的根源。</p>
<p>哲学上的自由，是一种能力来终止自然规律在我们身上的作用。</p>
<p>荀子试图对道德现象作科学的解释。</p>
<p>法律的前提，每个人都有责任能力，责任能力对自然规律有一种超越的能力（超越生物性），这种认定必须是形而上学的假定。</p>
<p>理性有两种含义：</p>
<p>1、科学范畴，选择最优方式，避免利益冲突（understanding）</p>
<p>2、一种绝对、无条件对事物认知的能力，用法在于实践，创建社会关系（reason）</p>
<p>建立社会关系的礼非知性（1）</p>
<p>人心有限：理性规律</p>
<p>人心无限：比如构造上帝</p>
<p>因为世界历史已经形成。资本生产方式本质是超越国界，掠夺别人的资源，要无穷无尽的资源，无尽无尽的市场。在这个历史背景下，宋明心学不能盛行（来不及转变）</p>
<p>宋明心学不能盛行原因之一：中国的政治发送巨大变化，取消宰相制度。中断了中国文人，天下关怀的现实可能性。</p>
<p>这样就不能实现名族生命实践的道统。后果就是清朝的腐败。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学导论第4课</title>
    <url>/2020/05/02/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E7%AC%AC4%E8%AF%BE/</url>
    <content><![CDATA[<p>一个名族文化生命衰弱需要其他名族的思想和智慧的启发。</p>
<p>古希腊晚期道德秩序败坏，社会混乱，从东方犹太思想进入古希腊世界，刺激了古希腊，为后来的基督教形成建立了基础，造成了后来的中世纪。</p>
<p>隋唐时期引入佛教的经典，慢慢吸收思想的养料，完成文化的自我拯救。</p>
<p>玄奘 唯识宗</p>
<p>虚无的思想（般若）</p>
<p>8识：眼、耳、鼻、舌、身</p>
<p>第6识：意识。统摄前五种感觉。</p>
<p>第7识：末那识。感性世界在流变，但对同一个东西，都存在一个小我，就是心。</p>
<p>第8识：阿赖耶识（藏识/种子识）。</p>
<p>孟子：万物皆备于我，反身而诚乐莫大焉。真理本在心中。（孟子为中国心学的萌芽）</p>
<p>心有4个善端 : 修过、是非、慈让、恻隐。</p>
<p>建立礼，礼就是道德规则。</p>
<p>为了符合个人利益，通过礼来正名分，为防止免于大家利益纷争。</p>
<p>前提是人性本恶。</p>
<p>这是荀子的思想。荀子讲的心是自然性nature</p>
<p>孟子讲心是人性</p>
<p>心乃是哲学题材，非脏器。</p>
<p>善恶是人的社会存在，人的社会存在根据在于心（非mind 心智）。</p>
<p>7识从8识种子库里来，8识是超越小我的大我。任何思维都在一个思维范畴里，在大我里。</p>
<p>就好比speak和language。</p>
<p>引入佛学后，挽救文化生命，重建了对真理的了解。</p>
<p>进入宋明儒学，迎来中国第二次思想高峰。</p>
<p>佛教中国化禅宗。</p>
<p>金刚经:应无所往，而生其心。</p>
<p>宋明儒学有两个流派：</p>
<p>程朱理学。通过佛教的启发建立一种形而上的哲学体系，把天理讲清楚，并遵守它，存天理，灭人欲。</p>
<p>陆王心学：进行反驳，认为程朱理学违背心学原则，真理在心之内。</p>
<p>陆象山讲：吾心即宇宙，宇宙便是吾心。此心非小我。</p>
<p>王阳明说：心外无物。（与康德西方的心学很像）</p>
<p>启蒙是指让道德成为个人的自律而不是外部伦理权威的威力。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学导论第3课</title>
    <url>/2020/04/30/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E7%AC%AC3%E8%AF%BE/</url>
    <content><![CDATA[<p>发现很多事情都是站在西方哲学概念体系来解释中方哲学概念体系。</p>
<p>中国人讲国家，是不是等同于西方的概念? 这需要哲学的考察。</p>
<p>名词就是名器。</p>
<p>对于中，国家是感性的，motherland。</p>
<p>对于西，真正公民具有独立人格，市民生活。政治国家为我服务。</p>
<p>中国思想不能发展出超验。</p>
<p>中国近传统精神：儒道互补。</p>
<p>道是儒的反面。对于文明和理想的目标，总有道家思想来消解儒家思想。</p>
<p>一方坚持执着，一方去掉执着。</p>
<p>儒家具有家国天下的情怀，伦理政治的思想。</p>
<p>对于官，首先是教化，树立道德榜样，然后才是利益纷争的摆明。</p>
<p>这与西方不同，对于中方，伦理政治是不分开的，而西方分开。</p>
<p>西方有一基调就是人都是自私的，所以需要政治制约，解决纷争。</p>
<p>中国几千年文明但却没有宗教。</p>
<p>西方哲学搞理论。中方哲学讲究为人与做学问统一，比如孔子。</p>
<p>通过道德榜样，通过修养成为圣贤，然后治理天下。这是中国哲学治理天下的前提。</p>
<p>然后这里有一个很大的缺陷，如果当官的人并不是圣贤，而是伪善的（乡愿，孔子云：“乡愿，德之贼也”）</p>
<p>从历史来讲，其实这种情况一直都是在循环。所以每一代文人都有忧患意识。</p>
<p>所谓上梁不正下梁歪，如果没有一个好的榜样，就会影响下面的人。</p>
<p>西方是一个制度，一个宗教。制度制约管理者，宗教教导普通人。这和中方不同。</p>
<p>所以历史上，康有为曾想把儒家变为宗教。</p>
<p>儒家的原则和目标，到家的自在奸猾。</p>
<p>老子的《道德经》从一个角度看就是一本权术书。</p>
<p>讲经又讲权，讲原则又讲权变。就是如今的高度原则性与高度灵活性的统一。</p>
<p>以权变经，圆滑是中国文化传统的一个特征，早就中国的国民性格。</p>
<p>我们在这样的文化环境成长，虽然没有读过儒道两加经典，但也是受影响了。</p>
<p>这是一种对理解这个世界基本的态度。</p>
<p>不能救市，就能隐匿，追求个人的自在去吧。</p>
<p>不把原则坚持到底，中华名族成为世界众多名族中，最呼吁和平的名族。</p>
<p>这里讲究内方外圆，处事圆滑，不锋芒毕露，执着放在内心。儒道互补。</p>
<p>圆滑，不会保持旺盛的创造力，和生命的理想。从历史上来看，中华名族也遇到很多危险。</p>
<p>中国思想基本进程</p>
<p>（1）百家争鸣</p>
<p>由夏商周三朝的生命实践，体会了非常多种道，这就是百家。这是道统为立，中国文化发展还没有统一方向。</p>
<p>（2）两汉道统确定</p>
<p>通过对道的体会制作名器</p>
<p>（3）魏晋时期</p>
<p>发现使用之后千疮百孔，导致该时期，放浪形骸，藐视礼教。魏晋时期跟随道家态度。</p>
<p>这是中国文化衰落的征兆。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis generator</title>
    <url>/2020/04/29/mybatis-generator/</url>
    <content><![CDATA[<p>使用mybatis generator来自动生成mapper和model。</p>
<p>发现自动生成的数据，应该是int却变为long，暂时不知道什么原因。</p>
<p>然后暂时解决方案如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table tableName&#x3D;&quot;question&quot; domainObjectName&#x3D;&quot;Question&quot;&gt;</span><br><span class="line">&lt;columnOverride column&#x3D;&quot;ID&quot; javaType&#x3D;&quot;java.lang.Integer&quot; jdbcType&#x3D;&quot;INTEGER&quot;&gt;&lt;&#x2F;columnOverride&gt;</span><br><span class="line">&lt;columnOverride column&#x3D;&quot;creator&quot; javaType&#x3D;&quot;java.lang.Integer&quot; jdbcType&#x3D;&quot;INTEGER&quot;&gt;&lt;&#x2F;columnOverride&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>





<p>这搞了挺久。。。出去散步<del>~</del></p>
]]></content>
      <categories>
        <category>mybatis generator</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Spring Boot</tag>
        <tag>mybatis generator</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学导论第2课</title>
    <url>/2020/04/29/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E7%AC%AC2%E8%AF%BE/</url>
    <content><![CDATA[<p>国民性与典章制度皆为器，是名族文化精神的载体。</p>
<h1 id="中西文化精神的根基差别"><a href="#中西文化精神的根基差别" class="headerlink" title="中西文化精神的根基差别"></a>中西文化精神的根基差别</h1><p>中西方都有着私有财产的历史。</p>
<p>司马迁写史记，有一篇叫货殖列传描述先秦商人。</p>
<p>古希腊就有着频繁商业活动。</p>
<h2 id="西方理解"><a href="#西方理解" class="headerlink" title="西方理解"></a>西方理解</h2><p>例如我有一块表，如何证明这块表属于我？</p>
<p>不是肉体器官占有了这块表，而是人格的存在，人格占有了外物。人格与物之间具有占有和被占有的关系。</p>
<p>人格是超感性存在，是超验，不在感性世界中。</p>
<p>当一位老者逝去，将遗产分给儿子时，这里就有着人格的存在。</p>
<p>也可看出法律也有形而上学原理。</p>
<p>钱本质上是智思体/意会体（noumenon，思想领会，人格真实比感性更真实），超感性，代表社会权利/</p>
<p>工程师、工人、资本家看机器各不相同。</p>
<p>上述都是康德阐发，可见私有财产和西方人格的存在联系到了一起。</p>
<h2 id="中方理解"><a href="#中方理解" class="headerlink" title="中方理解"></a>中方理解</h2><p>中国人要亲身感受，精神与肉体不缺分。</p>
<p>就好像中西方都有着灵魂的概念。</p>
<p>西方认为，人的肉体只会带来欲望，使得灵魂不存粹，当死去，进入天国可以与上帝一起，实现永恒的沉思。这里就构建了超越感性的世界。</p>
<p>中方认为死去，这辈子命不好，下辈子想要有一个好的开始。这里面具有感性。</p>
<p>中华名族还是讲究生命情感。</p>
<h1 id="感性能不能遵守超验规则的真实性？"><a href="#感性能不能遵守超验规则的真实性？" class="headerlink" title="感性能不能遵守超验规则的真实性？"></a>感性能不能遵守超验规则的真实性？</h1><p>规则是超验的。因为不是感性的，所有会感觉不自由。</p>
<p>例如一个学生高考离分数线差两分。</p>
<p>家长第一时间不会想说你差这个分数线两分，应该遵守这个规则。会想办法破坏规则。而是拿好贡品找菩萨或是谁谁谁帮忙。</p>
<p>对于没权没势的家庭会看着别人是否破坏规则，然后举报那个破坏规则的人。</p>
<p><strong><em>每一个名族的道统对于这个世界的领会都是不一样的。</em></strong></p>
<p>写到这里就觉得其实在这里从小所受教育其实受西方思想挺大的。从历史上讲，若中华名族的思想远播海外，那或许就是另一个局面了。</p>
<h1 id="中西方名族形成最初的智慧根源"><a href="#中西方名族形成最初的智慧根源" class="headerlink" title="中西方名族形成最初的智慧根源"></a>中西方名族形成最初的智慧根源</h1><p>名族形成最初的智慧的差异来自于最初路径的选择。</p>
<p>四个名族：中华名族（老子、孔子）、古希腊名族（柏拉图）、古印度（释迦摩尼）、古以色列</p>
<p>四大名族的思想开启了轴心时代。</p>
<p>思想不会新的，新的是指思潮。</p>
<h1 id="思想形成受最初受地理环境影响"><a href="#思想形成受最初受地理环境影响" class="headerlink" title="思想形成受最初受地理环境影响"></a>思想形成受最初受地理环境影响</h1><p>古希腊爱琴海，多岛屿，海上移民频繁。在同一个岛上会有不同部落。这里不能靠血缘关系，而是契约。但契约本身不可靠，所以在这之前就出现了原始宗教，通过诸神的伦理关系，将人与神产生关联，使得人间的契约神圣化。</p>
<p>religion 宗教-&gt;契约。</p>
<p>应中华民族生活位置是大陆，所以单靠学院关系，并不靠契约。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学导论第1课</title>
    <url>/2020/04/28/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E7%AC%AC1%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="何为哲学"><a href="#何为哲学" class="headerlink" title="何为哲学"></a>何为哲学</h1><p>哲学是论道学问。</p>
<p>道无法言说，而哲学就是研究无法言说的道。</p>
<h1 id="何为道"><a href="#何为道" class="headerlink" title="何为道"></a>何为道</h1><p>《周易》有云：“形而上者谓之道，形而下者谓之器”</p>
<p>形指的是感性，经验。</p>
<p>形而上指超越经验。</p>
<p>民族德社会典章制度是一种器（具体科学）。</p>
<p>举个例子：中国茶道所用工具是一种器，规则也是器。但一起体现了道。</p>
<p>无道就是没有文化生命，哲学论道就是把一个名族文化生命，发展方向德领会说出来。达到对文化生命德自觉这就是论道。</p>
<h1 id="道的领会不同"><a href="#道的领会不同" class="headerlink" title="道的领会不同"></a>道的领会不同</h1><p>中西方对道的领会不一样。因为名族不同。</p>
<p>西方讲究逻辑，区分了理性与非理性</p>
<p>中方没有区分，中华名族的哲学是以生命感受为基础。</p>
<p>西方哲学是范畴逻辑演绎。西方哲学是在超感性。<br>中国哲学是生命情感的体验，真理在生命情感的体验之中。</p>
<h1 id="哲学真理与科学真理有什么却别？"><a href="#哲学真理与科学真理有什么却别？" class="headerlink" title="哲学真理与科学真理有什么却别？"></a>哲学真理与科学真理有什么却别？</h1><p>科学真理无民族姓。</p>
<p>科学真理是对事物规律变化的描绘。非自发本身体现真理。</p>
<p>哲学真理里需要人的生命奋斗来体现。</p>
<p>哲学真理以民族生活实践为根基。</p>
<h1 id="哲学为何不能统一"><a href="#哲学为何不能统一" class="headerlink" title="哲学为何不能统一"></a>哲学为何不能统一</h1><p>中西方哲学都有真理的因素。了解真理然后需要实践。这是生命奋斗的体现，生命奋斗有名族性。</p>
<p>当开始实践时必定受当地规则制约。</p>
<p>从古到今出现危机时，都是由不同名族智慧的启发。</p>
<p>例如受到印度佛教启发后宋明中国思想第二次高潮。</p>
<p>欧洲没有犹太思想启发古希腊就没有欧洲中世纪。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学，王德峰</tag>
      </tags>
  </entry>
  <entry>
    <title>计划2</title>
    <url>/2020/04/28/%E8%AE%A1%E5%88%922/</url>
    <content><![CDATA[<p>论文修改交上去了。</p>
<p>29，30号。全力冲击，看看能做多少事。</p>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>计划1</title>
    <url>/2020/04/17/%E8%AE%A1%E5%88%921/</url>
    <content><![CDATA[<p>18号开始，7天。</p>
<p>冥想 15分钟</p>
<p>看专业之外的资料45分钟。</p>
<table>
<thead>
<tr>
<th>4.18</th>
<th>4.19</th>
<th>4.20</th>
<th>4.21</th>
<th>4.22</th>
<th>4.23</th>
<th>4.24</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.3.3</title>
    <url>/2020/03/03/2020-3-3/</url>
    <content><![CDATA[<hr>
<a id="more"></a>

<p>距离考研结束已经很久了，我想是时候写一篇日记作为总结了。</p>
<p>这一次考研过程中，由于数学考试过程中心态过于紧张，导致最后选择题忘记填上去，最后因单科线过不了而结束。现在想来还是挺难受的。数学考场上的紧张和几个夜晚的悲伤将那段时间的效用达到了顶峰。这次失败打断了未来的计划。</p>
<p>自己对于考研这件事情挺执着的，再加上这此失败的原因，因为会去二战。一开始很担心时间浪费了，然后今天下午跟老师做心理咨询的时候相通了，我想每个人的进度都是不一样的，对于整个人生来说，这一年又算得了什么呢?将这一年过得充实就行了。</p>
<p>zk，不能和你一起实现我们的梦想，真的挺遗憾的。回想起我们一起学习的日子，每天很晚从鄞州图书馆走出来，一边走过公园一边聊着各种话题，然后坐公交车离开，那段时间真正地改变了我们的人生。无论如何，后面也要加油啊。</p>
<hr>
<p>先这样吧。</p>
]]></content>
      <categories>
        <category>生活日常</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>《睡眠革命》</title>
    <url>/2020/02/26/%E3%80%8A%E7%9D%A1%E7%9C%A0%E9%9D%A9%E5%91%BD%E3%80%8B/</url>
    <content><![CDATA[<h1 id="了解昼夜节律"><a href="#了解昼夜节律" class="headerlink" title="了解昼夜节律"></a>了解昼夜节律</h1><p><img src="/2020/02/26/%E3%80%8A%E7%9D%A1%E7%9C%A0%E9%9D%A9%E5%91%BD%E3%80%8B/a.png" alt></p>
<p>1．走到户外！让⽇光调整你的⽣物钟，⽽不是人工光线。 </p>
<p>2．了解你的各项⾼峰和低⾕数值，监控那些会在你⾝上⾃然⽽然发⽣的变化。使⽤穿戴式健⾝追踪器进⾏测量。 </p>
<p>3．早上放慢速度。醒来之后⽴⻢陷⼊⼀团忙乱之中，早晚会毁了你的⾝体。睡眠质量和我们早上醒来之后的所作所为息息相 关。 </p>
<h1 id="了解睡眠类型"><a href="#了解睡眠类型" class="headerlink" title="了解睡眠类型"></a>了解睡眠类型</h1><p>谷歌 慕尼黑大学睡觉类型调查问卷。</p>
<h1 id="90分钟睡眠法"><a href="#90分钟睡眠法" class="headerlink" title="90分钟睡眠法"></a>90分钟睡眠法</h1><p>设定必须起床的最早时间，必须比上学、上班或做其他事情的时间早至少90分钟。</p>
<p>根据起床时间和90分钟时长的睡眠周期，回过头算入睡时间。</p>
<p> 以90分钟为一个周期，五个睡眠周期，早上七点半起来，就在午夜12点睡（需要提前躺下15分钟，取决于多久能睡着）。</p>
<p>如果错过理想入睡时间，就要下一个周期开始的时间。</p>
<p>最好合计每周的睡眠周期，一天为五个睡眠周期的话，那就将每周获得35个睡眠周期设为目标，不要被其中一天的糟糕睡眠影响，每周至少有4个晚上拥有完美的时间安排，就没问题了。</p>
<p>先从每晚5个睡眠周期开始，看看7天之后感觉如何，之后再做调整。</p>
<p>尽量避免连续三个晚上睡眠不足的情况发生。</p>
]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>集成MyBatis实现数据持久化保存</title>
    <url>/2020/02/13/%E9%9B%86%E6%88%90MyBatis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%BF%9D%E5%AD%98/</url>
    <content><![CDATA[<h1 id="简要"><a href="#简要" class="headerlink" title="简要"></a>简要</h1><p>对应SpringBoot需要使用MyBatis-Spring-Boot-Starter来连接数据库，这里我使用H2数据库。</p>
<p>官方文档：</p>
<p><a href="http://www.h2database.com/html/main.html" target="_blank" rel="noopener">H2</a></p>
<p><a href="https://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">MyBatis-Spring-Boot-Starter</a></p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.0.0.RC1/reference/htmlsingle/#boot-features-embedded-database-support" target="_blank" rel="noopener">配置文件文档</a></p>
<p>整体思路：</p>
<p>1、添加H2的maven依赖，这种数据库可以内置在里面，直接idea直接来创建数据库</p>
<p>2、MyBatis-Spring-Boot-Starter的maven依赖</p>
<p>3、写对应配置文件</p>
<p>4、写mapper</p>
<hr>
<a id="more"></a>

<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>对应配置文件添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:h2:路径</span><br><span class="line">spring.datasource.username&#x3D;用户名</span><br><span class="line">spring.datasource.password&#x3D;密码</span><br><span class="line">spring.datasource.driver-class-name&#x3D;org.h2.Driver</span><br></pre></td></tr></table></figure>



<h1 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h1><p>mapper:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> life.cj.community.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> life.cj.community.model.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into user (name,account_id,token,gmt_create,gmt_modified) values (#&#123;name&#125;,#&#123;accountId&#125;,#&#123;token&#125;,#&#123;gmtCreate&#125;,#&#123;gmtModified&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="User数据结构"><a href="#User数据结构" class="headerlink" title="User数据结构"></a>User数据结构</h1><p>对于存储在服务器内部的数据结构，创建model包（区别与dto）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> life.cj.community.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String accountId;</span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line">    <span class="keyword">private</span> Long gmtCreate;</span><br><span class="line">    <span class="keyword">private</span> Long gmtModified;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAccountId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountId</span><span class="params">(String accountId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountId = accountId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.token = token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getGmtCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gmtCreate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGmtCreate</span><span class="params">(Long gmtCreate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gmtCreate = gmtCreate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getGmtModified</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gmtModified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGmtModified</span><span class="params">(Long gmtModified)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gmtModified = gmtModified;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>H2</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>关于SpringBoot下的Session和Cookies</title>
    <url>/2020/02/13/%E5%85%B3%E4%BA%8ESpringBoot%E4%B8%8B%E7%9A%84session%E5%92%8CCookies/</url>
    <content><![CDATA[<p>简要描述：</p>
<p>服务器就是一家银行。</p>
<p>Session就是在该银行下开通的户口。</p>
<p>Cookies就是给该户口办理的银行卡。</p>
<p>用户可以拿着银行卡给该银行，银行可以凭借该银行卡找到该户口，知道了用户的身份。</p>
<p>给用户开户：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getSession().setAttribute(<span class="string">"user"</span>,githubUser);</span><br></pre></td></tr></table></figure>

<p>SpringBoot有这种机制，直接返回时，会自动加入对应的Cookies(银行卡)给用户，只是这是随机，不能指定。</p>
<hr>
<p>thymeleaf的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">th:if&#x3D;&quot;$&#123;session.user!&#x3D; null&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">th:text&#x3D;&quot;$&#123;session.user.getName()&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Cookies，Session</tag>
      </tags>
  </entry>
  <entry>
    <title>调用github接口实现登录功能</title>
    <url>/2020/02/12/%E8%B0%83%E7%94%A8github%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>本文讲述如何调用Github的接口，实现IT社区的登录功能。</p>
<a id="more"></a>

<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p><a href="https://developer.github.com/apps/building-oauth-apps/" target="_blank" rel="noopener">参考文档</a></p>
<h1 id="第一步：创建并注册OAuth-App（对应步骤1-2）"><a href="#第一步：创建并注册OAuth-App（对应步骤1-2）" class="headerlink" title="第一步：创建并注册OAuth App（对应步骤1,2）"></a>第一步：创建并注册OAuth App（对应步骤1,2）</h1><h1 id="第二部-用户授权将github上的个人信息给我的应用"><a href="#第二部-用户授权将github上的个人信息给我的应用" class="headerlink" title="第二部 : 用户授权将github上的个人信息给我的应用"></a>第二部 : 用户授权将github上的个人信息给我的应用</h1><p><img src="/2020/02/12/%E8%B0%83%E7%94%A8github%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD/1.jpg" alt="流程图"></p>
<p><a href="https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/" target="_blank" rel="noopener">对应链接</a></p>
<h2 id="调用github的authorize接口"><a href="#调用github的authorize接口" class="headerlink" title="调用github的authorize接口"></a>调用github的authorize接口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;authorize?client_id&#x3D;5f60243f732e3787b680&amp;redirect_uri&#x3D;http:&#x2F;&#x2F;localhost:8887&#x2F;callback&amp;scope&#x3D;user&amp;state&#x3D;1&quot;&gt;登录&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>上面向接口发送了三个参数</p>
<ul>
<li>client_id：这个就是步骤1注册时，提供给你的一个id，就相当于一个github给应用注册者的一个标识符</li>
<li>redirect_uri： 当授权完成时，返回的地址</li>
<li>scope：目前网站设计只要向github获取用户的个人信息就够了</li>
<li>state ：这里应该随机调入一个数，并在本地保存下来，后面github又会返回这个数，这主要是保护作用，防止第三方伪装。（这里为了简便，随便填入1）</li>
</ul>
<p>当github返回时，会另外携带<strong><em>code</em></strong>和<strong><em>state</em></strong>两个参数。</p>
<p>上述就完成了流程图中的1.2和1.2.1两个步骤。</p>
<h2 id="调用github的access-token接口"><a href="#调用github的access-token接口" class="headerlink" title="调用github的access_token接口"></a>调用github的access_token接口</h2><p>这里不是由用户发出，而是由服务器本身发出，所以写一个程序用来接受之前github发给我的两个参数，并再带上必要的参数，向github发出HTTP请求，然后获取access_token。</p>
<p>程序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> life.cj.community.Controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> life.cj.community.dto.AccessTokenDTO;</span><br><span class="line"><span class="keyword">import</span> life.cj.community.dto.GithubUser;</span><br><span class="line"><span class="keyword">import</span> life.cj.community.provider.GithubProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GithubProvider githubProvider; 	<span class="comment">//该类使用了OkHttp来发出请求，所以按程序组织习惯，该类放在了用Controller同级的Provider包中。</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;github.client.id&#125;"</span>) 	<span class="comment">//作为此类数据，应当放在配置文件中</span></span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;github.client.secret&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String clientSecret;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;github.redirect.uri&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String redirectUri;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/callback"</span>)<span class="comment">//流程图中1.2.1步返回时，接受code和state两个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">callback</span><span class="params">(@RequestParam(name=<span class="string">"code"</span>)</span>String code,</span></span><br><span class="line"><span class="function">                           @<span class="title">RequestParam</span><span class="params">(name=<span class="string">"state"</span>)</span>String state)</span>&#123;</span><br><span class="line">        AccessTokenDTO accessTokenDTO = <span class="keyword">new</span> AccessTokenDTO();<span class="comment">//参数超过了2个，创AccessTokenDTO</span></span><br><span class="line">		accessTokenDTO.setClient_id(clientId);</span><br><span class="line">        accessTokenDTO.setClient_secret(clientSecret);</span><br><span class="line">        accessTokenDTO.setCode(code);</span><br><span class="line">        accessTokenDTO.setRedirect_uri(redirectUri);</span><br><span class="line">        accessTokenDTO.setState(state);</span><br><span class="line">        String aceessToken = githubProvider.getAceessToken(accessTokenDTO);</span><br><span class="line">        GithubUser user = githubProvider.getUser(aceessToken);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> life.cj.community.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> life.cj.community.dto.AccessTokenDTO;</span><br><span class="line"><span class="keyword">import</span> life.cj.community.dto.GithubUser;</span><br><span class="line"><span class="keyword">import</span> okhttp3.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GithubProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAceessToken</span><span class="params">(AccessTokenDTO accessTokenDTO)</span></span>&#123; <span class="comment">//获取1.2.1.2返回时的token</span></span><br><span class="line">        MediaType mediaType = MediaType.get(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        RequestBody body = RequestBody.create(mediaType, JSON.toJSONString(accessTokenDTO));</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"https://github.com/login/oauth/access_token"</span>)</span><br><span class="line">                .post(body)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> (Response response = client.newCall(request).execute()) &#123;</span><br><span class="line">            String string = response.body().string();</span><br><span class="line">            String token = string.split(<span class="string">"&amp;"</span>)[<span class="number">0</span>].split(<span class="string">"="</span>)[<span class="number">1</span>];<span class="comment">//根据返回数据形式，获取信息</span></span><br><span class="line">            <span class="keyword">return</span>  token;</span><br><span class="line">            <span class="comment">//System.out.println(string);</span></span><br><span class="line">            <span class="comment">//return response.body().string();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成了1.2.1.1和1.2.1.2步骤</p>
<h2 id="调用github的user接口"><a href="#调用github的user接口" class="headerlink" title="调用github的user接口"></a>调用github的user接口</h2><p>获取user信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GithubUser <span class="title">getUser</span><span class="params">(String accessToken)</span></span>&#123;</span><br><span class="line">        OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">                .url(<span class="string">"https://api.github.com/user?access_token="</span>+ accessToken)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Response response = client.newCall(request).execute();</span><br><span class="line">            String string = response.body().string();</span><br><span class="line">            <span class="comment">//使用fastjson将string的json对象解析成java的类对象</span></span><br><span class="line">            GithubUser githubUser = JSON.parseObject(string, GithubUser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">return</span> githubUser;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h1 id="附加工具"><a href="#附加工具" class="headerlink" title="附加工具"></a>附加工具</h1><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><h2 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h2><h2 id="mvnrepository"><a href="#mvnrepository" class="headerlink" title="mvnrepository"></a>mvnrepository</h2><h1 id="扩展资料"><a href="#扩展资料" class="headerlink" title="扩展资料"></a>扩展资料</h1><p>这种机制是如何设计出来的？</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">Oauth设计机制</a></p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Github</tag>
        <tag>OAuth Apps</tag>
        <tag>Fastjson</tag>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone加速</title>
    <url>/2020/02/11/git-clone%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<p><strong><em>解决方案</em></strong></p>
<a id="more"></a>

<p>设置代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<p>取消代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>

<p>查看git全局设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>

<p>只对github</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy socks5:&#x2F;&#x2F;127.0.0.1:1080 </span><br><span class="line">git config --global --unset http.https:&#x2F;&#x2F;github.com.proxy</span><br></pre></td></tr></table></figure>



<p><strong><em>此方案前提需要代理</em></strong></p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/10/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>用了几天的时间把博客搭建起来了，此博客打算用于记录生活和学习过程。</p>
<p>此博客还需要不断完善，目前先总结一下搭建过程。</p>
<a id="more"></a>

<h1 id="1-域名和解析"><a href="#1-域名和解析" class="headerlink" title="1.域名和解析"></a>1.域名和解析</h1><h2 id="1-1-域名购买"><a href="#1-1-域名购买" class="headerlink" title="1.1 域名购买"></a>1.1 域名购买</h2><p>这是<a href="https://www.namesilo.com/" target="_blank" rel="noopener">域名购买地址</a>，这个域名提供商免费提供whois信息保护，所以就选择了这家。</p>
<h2 id="1-2-DNS解析设置"><a href="#1-2-DNS解析设置" class="headerlink" title="1.2 DNS解析设置"></a>1.2 DNS解析设置</h2><p>因为我的博客是同时部署到了Github pages和coding page，所以dns服务设置了阿里云的dns服务，将国内流量导向coding，将国外的流量导向github，同时将github和coding设置为强制开始https。<br><img src="/2020/02/10/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/1.jpg" alt="域名解析"></p>
<h1 id="2-博客搭建"><a href="#2-博客搭建" class="headerlink" title="2.博客搭建"></a>2.博客搭建</h1><h2 id="2-1-环境配置"><a href="#2-1-环境配置" class="headerlink" title="2.1 环境配置"></a>2.1 环境配置</h2><p>本博客基于Hexo NexT主题，所以要先安装<a href="https://nodejs.org" target="_blank" rel="noopener">Node.js</a>和<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>。配置完成后，在git bash中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>hexo就安装完成了，接着在指定文件夹（blog搭建的地方）打开git bash输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>这样就搭建起了一个初始的blog，所以非常便捷。</p>
<h2 id="2-2-常用操作"><a href="#2-2-常用操作" class="headerlink" title="2.2 常用操作"></a>2.2 常用操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;&quot;&#x2F;&#x2F;新文章，&quot;&quot;里面是文章名&#96;</span><br><span class="line">hexo g&#x2F;&#x2F;生成静态文件&#96;</span><br><span class="line">hexo clean &#x2F;&#x2F;清除缓存</span><br><span class="line">hexo s&#x2F;&#x2F;启动服务器</span><br><span class="line">hexo d&#x2F;&#x2F;部署</span><br></pre></td></tr></table></figure>
<h2 id="2-3-更改博客主题"><a href="#2-3-更改博客主题" class="headerlink" title="2.3 更改博客主题"></a>2.3 更改博客主题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &lt;blog-path&gt;  #定位到 Hexo 博客目录</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next &#x2F;themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>然后修改博客根目录_config.yml配置文件,将theme对应的值改为nexT即可。</p>
<h2 id="2-4更多详细配置"><a href="#2-4更多详细配置" class="headerlink" title="2.4更多详细配置"></a>2.4更多详细配置</h2><p>可参看:</p>
<ul>
<li><p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo文档</a></p>
</li>
<li><p><a href="https://theme-next.org/docs/" target="_blank" rel="noopener">NexT文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
