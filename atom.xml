<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CJ&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cjay.life/"/>
  <updated>2020-07-25T11:04:34.866Z</updated>
  <id>https://cjay.life/</id>
  
  <author>
    <name>CJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>csapp第三章-程序的机器级表示</title>
    <link href="https://cjay.life/2020/07/24/csapp%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <id>https://cjay.life/2020/07/24/csapp%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</id>
    <published>2020-07-24T07:07:02.000Z</published>
    <updated>2020-07-25T11:04:34.866Z</updated>
    
    <content type="html"><![CDATA[<p>机器代码，用字节序列编码低级的操作。编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。</p><h1 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假设一个C程序，有两个文件p1.c和p2.c。</span><br><span class="line">linux&gt; gcc -0g p p1.c p2.c</span><br></pre></td></tr></table></figure><p>编译选项-Og告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。</p><p>实际上gcc命令调用了一整套程序，将源代码转化成可执行代码。</p><ol><li>C预处理器扩展源代码，插入所有用#include指令指定的文件，并扩展所有用#define声明指定的宏。</li><li>编译器产生两个源文件的汇编代码，p1.s和p2.s</li><li>汇编器将汇编代码转成二进制目标代码文件p1.o和p2.o。（目标代码是机器代码的而一种形式，包括指令的二进制表示，但还没有填入全局值得地址）</li><li>链接器将两个目标代码文件和实现库函数得代码合并，并产生最终得可执行代码文件p</li></ol><h1 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h1><p>对于机器编程来说，其中两种抽象尤为重要。</p><ol><li>指令集体系结构或指令集架构（Instruction Set Architecture,ISA）定义机器级程序得格式和行为，它定义了处理器状态，指令得格式，以及每条指令对状态得影响。但硬件层面描述复杂，它们并发执行许多指令，但可以采取措施保证整体行为与ISA指定顺序完全一致。</li><li>机器级程序使用内存地址是虚拟地址。存储器系统得实际实现是将多个硬件存储器和操作系统软件给结合起来。</li></ol><p>一些x86-64的机器代码对于C语言程序员隐藏的处理器状态都是可见的：</p><ol><li>程序计数器（PC，x86-64中用%rip表示）给除将要执行恶下一条指令在内存中的地址。</li><li>整数寄存器文件包括16个命名的地址，分别存储64位的值，可以存放地或整数数据。</li><li>条件码寄存器保存最近执行的算术或逻辑命令的状态信息。用来实现控制或条件流中的条件变化。</li><li>一组向量寄存器用来存放一个或多个整数或浮点数值。</li></ol><p>从机器代码角度看内存，内存只是一个很大的、按字节寻址的数组。</p><p>程序在内存中包括：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。</p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>由于是从16位体系结构拓展成32位的，Intel用术语“字（word）”表示16位数据类型。32位“双子（double words）”。64位数为“四字（quad words）”。</p><p>图片</p><p>大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有四个变种:movb(传送字节)、movw（传送字）、movl（传送双字）和movq（传送四字。）</p><h1 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h1><p>x86-84的中央处理单元（CPU）包含一组16个存储64位值得通用目的寄存器。用来存储整数数据和指针。</p><p>图片</p><p>指令可以对这16个寄存器得低位字节中存放得不同大小数据进行操作。</p><p>在常见得程序里不同得寄存器扮演不同角色。其中最特别得栈指针%rsp。用来指明运行时栈结束位置。</p><h2 id="操作器指令符"><a href="#操作器指令符" class="headerlink" title="操作器指令符"></a>操作器指令符</h2><p>大多数指令有一个或多个操作数（operand）。操作数分为三种类型。</p><ol><li>立即数(immediate)：用来表示常数值。</li><li>寄存器（register）</li><li>内存引用</li></ol><p>寻找方式也有多种。Imm（rb,ri,s）表示最常用的形式:一个立即数偏移Imm，一个基址寄存器rb，一个变址寄存器ri和一个比例因子s,s必须是1，2，4，或者8.</p><p>图片</p><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><p>图片</p><p>原操作数是一个立即数，存储在寄存器或内存中。目的操作数只当一个位置。</p><p>x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。需要第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。</p><p><strong>大部分mov指令仅仅更新目的范围内的操作数，movl指令以寄存器为目的时，它会把该寄存器的高位4字节设置为0</strong></p><p>图片</p><p>常规的movq指令只能以表示为32位补码数字的立即数作为原操作数，然后把这个值符号扩展得到64位，放到目的位置。<strong>movabsq指令能以任意64位，并且只能放到寄存器作为目的。</strong></p><p>图片2</p><p>第一类零扩展数据传送，第二类符号扩展数据传送。每条指令名字的最后两个字符都是大小指示符：第一个指定源的大小，第二个指明目的大小。</p><h2 id="数据传送实例"><a href="#数据传送实例" class="headerlink" title="数据传送实例"></a>数据传送实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">long exchange(long *xp,long y)</span><br><span class="line">&#123;</span><br><span class="line">long x &#x3D; *xp;</span><br><span class="line">*xp &#x3D; y;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编</span><br><span class="line">&#x2F;&#x2F;xp in %rdi,y in %rsi,x in %rax</span><br><span class="line">exchange:</span><br><span class="line">movq(%rdi),%rax</span><br><span class="line">movq%rsi,(%rdi)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。像x这样的局部变量通常保存在寄存器中，而不是内存。访问寄存器比访问内存快许多。</p><h2 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h2><p>最后两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据。</p><p>图片</p><p>在x86-64中，程序栈存放在内存中某个区域。栈向下增长，栈顶元素的地址是栈中元素地址中最低的。栈指针%rsp保存着栈顶元素的地址。</p><p>将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此，pushq %rbp 的行为等价于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub $8,%rsp&#x2F;&#x2F;Decrement stack pointer</span><br><span class="line">movq %rbp,(%rsp)&#x2F;&#x2F;store %rbp on stack</span><br></pre></td></tr></table></figure><p>区别在于pushq指令编码为1字节，上面两条一共8字节。</p><p>图片</p><p>popq    %rax等价于下面两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq (%rsp),%rax&#x2F;&#x2F;Read %rax from stack</span><br><span class="line">addq $8,%rsp&#x2F;&#x2F;Incremetn stack pointer</span><br></pre></td></tr></table></figure><p>因为栈其实就是内存中的一片空间，其实可以用程序访问栈内的任意位置。假设栈顶元素是四字，指令movq 8(%rsp),%rdx会将第二个四字从栈中复制到寄存器%rdx。</p><h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><p>图片</p><p>大部分操作都分成了指令类，指令类都带不同大小操作数变种<strong>只有leaq没有</strong>。例如，ADD由四条加法指令组成：addb、addw、addl和addq。</p><p>这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。</p><h2 id="加载有效地址（load-effective-address）"><a href="#加载有效地址（load-effective-address）" class="headerlink" title="加载有效地址（load effective address）"></a>加载有效地址（load effective address）</h2><p>lea指令实际上是movq指令的变型。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令将有效地址写入到目的操作数。</p><p>这条指令可以为后面的内容引用产生指针。它还可以简洁得描述普通得算术操作。<strong>目的操作数必须是一个寄存器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">long scale(long x,long y,long z)&#123;</span><br><span class="line">long t &#x3D; x + 4*y + 12*z;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编</span><br><span class="line">&#x2F;&#x2F;x in %rdi,y in %rsi,z in %rdx</span><br><span class="line">scale:</span><br><span class="line">leaq(%rdi,%rsi,4), %rax&#x2F;&#x2F;x + 4*y</span><br><span class="line">leaq(%rdx,%rdx,2), %rdx&#x2F;&#x2F;z+2*z &#x3D; 3*z</span><br><span class="line">leaq(%rax,%rdx,4), %rax &#x2F;&#x2F;(x+4*y)+4*(3*z) &#x3D; x + 4*y + 12*z</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>leaq指令能执行加法和有限形式得乘法，在编译如上简单算术表达式时，是很有用处的。</p><h2 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h2><p>第二组操作是一元操作，操作数可以是寄存器，也可以是内存位置。</p><p>第三组是二元操作，第一个操作数可以是立即数、寄存器或是内存地址。第二个操作数可以是寄存器或者是内存位置。当第二个操作数为内存地址时，处理器必须从内存中读出值，执行操作，再把结果写回内存。</p><h2 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h2><p>最后一组为移位操作，先给出位移量，第二项给出要位移的数。可以逻辑移动，也可以算术。位移量可以是一个立即数，或者放在单字节寄存器%cl中。（这些指令只允许特定的寄存器作为操作数）。位移操作对w位长的数据值进行操作，位移量是由%cl寄存器的低m位决定，2的m次 = w。</p><p>例如当寄存器%cl的十六进制值为0xFF时，指令salb会移7位，salw会移15位，sall移31位，salq移63位。移位操作的目的操作数可以是一个寄存器值或是一个内存位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">long arith(long x,long y,long z)</span><br><span class="line">&#123;</span><br><span class="line">long t1 &#x3D; x^y;</span><br><span class="line">long t2 &#x3D; z*48;</span><br><span class="line">long t3 &#x3D; t1&amp;0x0F0F0F0F;</span><br><span class="line">long t4 &#x3D; t2-t3;</span><br><span class="line">return t4;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编</span><br><span class="line">&#x2F;&#x2F;x in %rdi,y in %rsi,z in %rdx</span><br><span class="line">arith:</span><br><span class="line">xorq%rsi,%rdi &#x2F;&#x2F;t1 &#x3D; x^y</span><br><span class="line">leaq(%rdx,%rdx,2),%rax&#x2F;&#x2F;3*z</span><br><span class="line">salq$4,%rax&#x2F;&#x2F;t2 &#x3D; 16*(3*z) &#x3D; 48*z</span><br><span class="line">andl$252645135,%edi&#x2F;&#x2F;t3 &#x3D; t1&amp;0x0F0F0F0F</span><br><span class="line">subq%rdi,%rax&#x2F;&#x2F;Return t2-t3</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h2><p>对于两个64位有符号或无符号整数相乘得到乘积需要128位来表示。Intel把16字节的数称为八字(oct word)。</p><p>图片</p><p>两种乘法都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器%rdx（高64位）和%rax（低64位）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">typedef unsigned __int128 unit128_t</span><br><span class="line">void store_uprod(uint128_t *dest,unit64_t x,unit64_t y)&#123;</span><br><span class="line">*dest &#x3D; x*(unit128_t)y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inttypes.h对标准C拓展的一部分，但这个标准并没有实现128位的值。只好依赖GCC提供的128位整数支持，用名字__int128声明。这段代码指明得到的乘积应该存放在指针dest指向的16字节处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dest in %rdi,x in %rsi,y in %rdx</span><br><span class="line">store_uprod:</span><br><span class="line">movq%rsi,%rax&#x2F;&#x2F;Copy x to mutiplicand</span><br><span class="line">mulq%rdx&#x2F;&#x2F;Multiply by y</span><br><span class="line">movq%rax,(%rdi)&#x2F;&#x2F;store lower 8 bytes at dest</span><br><span class="line">movq%rdx,8(%rdi)&#x2F;&#x2F;store upper 8 bytes at dest+8</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这段代码针对小端机器，所以高位字节存储在大地址。</p><p>单操作数除法指令。有符号除法指令idivl将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存在%rax中，余数存储在%rdx中。</p><p>对于64位除法来说，这个值在%rax中，%rdx的位设置为全0（无符号）或%rax的符号位（有符号）。后面这个操作由指令cqto来完成。这条指令隐含读出%rax符号位，并将它复制到%rdx所在的位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void remdiv(long x,long y,long *qp,long *rp)&#123;</span><br><span class="line">long q &#x3D; x&#x2F;y;</span><br><span class="line">long r &#x3D; x%y;</span><br><span class="line">*qp &#x3D; q;</span><br><span class="line">*rp &#x3D; r;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; x in %rdi,y in %rsi,qp in %rdx,rp in %rcx</span><br><span class="line">rediv:</span><br><span class="line">movq%rdx，%r8&#x2F;&#x2F;Copy qp</span><br><span class="line">movq%rdi,%rax&#x2F;&#x2F;Move x to lower 8 bytes of dividend</span><br><span class="line">cqto&#x2F;&#x2F;Sign-extend to upper 8 bytes of dividend</span><br><span class="line">idiq%rsi&#x2F;&#x2F;Divide by y</span><br><span class="line">movq%rax,(%r8)&#x2F;&#x2F;Store quotient at qp</span><br><span class="line">movq%rdx,(%rcx)&#x2F;&#x2F;Store remainder at rp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>首先把qp保存到另一个寄存器中（第2行），因为除法操作要使用参数寄存器%rdx。3~4准备被除数，复制并符号扩展x。</p><p>无符号除法使用divq指令。通常，寄存器%rdx会事先设置为0。</p><h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><p>C语言中的某些机构，比如条件语句、循环语句和分支语句，要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：<strong>测试数据值，然后根据测试的结果来改变控制流或者数据流。</strong></p><p>用jump指令可以改变一组机器代码指令的执行顺序，通过某个测试结果调转到程序的其他部分。</p><h2 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h2><p>除整数寄存器，CPU还维护一组单个位的条件码(condition code)寄存器。它们描述最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。常用有:</p><ul><li>CF:进位标志。最近的操作最高位产生了进位。可用来无符号操作的溢出。</li><li>ZF:零标志。最近操作结果为0.</li><li>SF:符号标志。最近的操作得到结果为负。</li><li>OF：溢出标志。最近操作导致一个补码溢出–正溢出或负溢出。</li></ul><p>leaq指令不改变任何条件码，因为它用来进行地址计算。除此之外3-10中所有指令都会设置条件码。</p><p>除了3-10中的指令会设置条件码，还有两类指令(有8，16，32和64位形式)，它们只设置条件码不改变任何其他寄存器。</p><p>图片</p><p>CMP根据两数之差设置条件码。CMP与SUB指令的行为一样。列出操作数的顺序是相反的。</p><p>TEST指令的行为与AND指令一样，除了它们只设置条件码而不改变目的寄存器值，典型用法是，两个操作数一样（检查是 正、负还是0），或其中一个操作数是掩码，用来指示哪些位应该被测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;机器代码，用字节序列编码低级的操作。编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。&lt;/p&gt;
&lt;h1 id=&quot;程序编码&quot;&gt;&lt;a href=&quot;#程序编码&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>排序算法的比较</title>
    <link href="https://cjay.life/2020/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://cjay.life/2020/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-07-21T09:06:35.000Z</published>
    <updated>2020-07-21T13:42:47.833Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic2.zhimg.com/80/v2-88e47948380615b5adb6e7c313a916e5_1440w.jpg" alt="浙江大学-数据结构-算法排序的比较-10.4.1 - 知乎"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-88e47948380615b5adb6e7c313a916e5_1440w.jpg&quot; alt=&quot;浙江大学-数据结构-算法排序的比较-10.4.1 - 知乎&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="https://cjay.life/2020/07/21/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/21/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-21T08:02:39.000Z</published>
    <updated>2020-07-21T09:05:23.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>假设我们有N个学生，他们的成绩是0到100之间的整数（于是有M=101个不同的成绩值）。如何在线性时间内将学生按成绩排序?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Bucket_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">count[]初始化;</span><br><span class="line">while(读入1个学生成绩grade)</span><br><span class="line">将该生插入count[grade]链表;</span><br><span class="line">for(i&#x3D;0;i&lt;M;i++)&#123;</span><br><span class="line">if(count[i])</span><br><span class="line">输出整个count[i]链表;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;T(N,M) &#x3D; O(M+N)</span><br></pre></td></tr></table></figure><p>若M&gt;&gt;N该怎么办?</p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>假设我们有N=10个整数，而M = 1000个不同的值。还有可能在线性时间内排序吗？</p><p>这里M已经等于了，N的三次方了。</p><p>可以采用“次位优先”(Least Significant Dighit),T = O(P(N+B)) (P为趟数，B等价于上面的B)</p><h1 id="多关键字的排序"><a href="#多关键字的排序" class="headerlink" title="多关键字的排序"></a>多关键字的排序</h1><p>例如扑克牌排序问题，用主位优先（Most Signficant Digit）排序：为花色建4个桶。</p><p>在每个桶内分别排序，最后合并结果。</p><p>若用次位优先排序:为面值建13个桶，将结果合并，然后再为花色建四个桶。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;桶排序&quot;&gt;&lt;a href=&quot;#桶排序&quot; class=&quot;headerlink&quot; title=&quot;桶排序&quot;&gt;&lt;/a&gt;桶排序&lt;/h1&gt;&lt;p&gt;假设我们有N个学生，他们的成绩是0到100之间的整数（于是有M=101个不同的成绩值）。如何在线性时间内将学生按成绩排序?&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>表排序</title>
    <link href="https://cjay.life/2020/07/19/%E8%A1%A8%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/19/%E8%A1%A8%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-19T09:51:11.000Z</published>
    <updated>2020-07-19T09:57:40.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><ul><li>简介排序</li></ul><p>定义一个指针数组作为”表”（table)</p><p>如果要求按顺序输出，则输出：</p><p>A[table[0]],A[table[1]]…A[table[N]]</p><h1 id="物理排序"><a href="#物理排序" class="headerlink" title="物理排序"></a>物理排序</h1><p>N个数字的排序由由若干个独立的环组成</p><p>Temp = f</p><p>如何判断一个环的结束？</p><p>if（table[i]== i）(前提是每移动一本书，将就table改为A下标)</p><h1 id="物理排序复杂度分析"><a href="#物理排序复杂度分析" class="headerlink" title="物理排序复杂度分析"></a>物理排序复杂度分析</h1><p>最好情况：初始即有序</p><p>最坏情况：</p><ul><li>有N/2个环，每个环2个元素</li><li>需要3*（N/2）次元素移动(a-&gt;tmp,b-&gt;a,b-&gt;tmp）</li></ul><p>T = O(mN),m是每个A元素的复制时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法概述&quot;&gt;&lt;a href=&quot;#算法概述&quot; class=&quot;headerlink&quot; title=&quot;算法概述&quot;&gt;&lt;/a&gt;算法概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;简介排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义一个指针数组作为”表”（table)&lt;/p&gt;
&lt;p&gt;如果要求按顺序输出
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://cjay.life/2020/07/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-19T09:33:13.000Z</published>
    <updated>2020-07-19T09:50:22.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>什么是快速排序算法的最好情况？</p><p>每次正好中分    T(N) = O(NlogN)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Quicksort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">pivot &#x3D; 从A[]中选一个主元;</span><br><span class="line">将S &#x3D; &#123;A[]\pivot&#125; 分成2个独立子集:</span><br><span class="line">A1 &#x3D; &#123;a∈S | a ≤ pivot&#125; 和 A2 &#x3D; &#123;a∈S | a ≥ pivot&#125;;</span><br><span class="line">A[] &#x3D; Quicksort(A1,N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2,N2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选主元"><a href="#选主元" class="headerlink" title="选主元"></a>选主元</h1><p>若选主元每次选择A[0]?</p><p>可能会产生下列情况：</p><p>1 2 3 4 5 6 … N</p><p>   2 3 4 5 6 … N</p><p>​      3 4 5 6 … N</p><p>T(N) = O(N) + T(N-1)</p><p>​        = O(N) + O(N-1) + T(N-2)</p><p>​        = O(N2)</p><p>这里距离一种选主元的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ElementType Median3(ElementType A[],int Left,int Right)</span><br><span class="line">&#123;</span><br><span class="line">int Center &#x3D; ([Left+Right)&#x2F;2;</span><br><span class="line">if(A[Left] &gt; A[Center])</span><br><span class="line">Swap(&amp;A[Left],&amp;A[Center]);</span><br><span class="line">if(A[Left] &gt; A[Right])</span><br><span class="line">Swap(&amp;A[Left],&amp;A[Right]);</span><br><span class="line">if(A[Center]&gt;A[Right])</span><br><span class="line">Swap(&amp;A[Center],&amp;A[Right]);</span><br><span class="line"></span><br><span class="line">Swap(&amp;A[Center],&amp;A[Right-1]);&#x2F;&#x2F;将pivot藏到右边</span><br><span class="line">&#x2F;&#x2F;接下来只需要考虑A[left+1]...A[Right-2]</span><br><span class="line">return A[Right-1]&#x2F;&#x2F;返回pivot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子集划分"><a href="#子集划分" class="headerlink" title="子集划分"></a>子集划分</h1><p>如果有元素正好等于pivot怎么办？</p><ul><li>停下来交换</li><li>不理它，继续移动指针</li></ul><p>第一种方式，优势是最后位置会被移动到靠中的位置，劣势是会有无用的交换</p><p>第二种方式，优势是不用进行无用交换，但劣势会移动到一端去。</p><p>综合起来，还是第一种方式比较好</p><h1 id="小规模数据的处理"><a href="#小规模数据的处理" class="headerlink" title="小规模数据的处理"></a>小规模数据的处理</h1><p>因为快速排序采用递归，所以需要不断压栈出栈，对于N不到100的情况，可能还不如插入排序快。</p><p>解决方案：当数据规模充分小，直接简单排序（比如插入排序)</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Quicksort(ElementType A[],int Left,int Right)&#123;</span><br><span class="line">if(Cutoff &lt;&#x3D; Right-Left)&#123;</span><br><span class="line">Pivot &#x3D; Median3(A,Left,Right);</span><br><span class="line">i &#x3D; Left; j &#x3D; Right-1;</span><br><span class="line">for(;;)&#123;</span><br><span class="line">while(A[++i]&lt;Pivot)&#123;&#125;</span><br><span class="line">while(A[--j]&gt;Pivot)&#123;&#125;</span><br><span class="line">if(i&lt;j)</span><br><span class="line">Swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">else break;</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;A[i],&amp;A[Right-1]);</span><br><span class="line">Quicksort(A,Left,i-1);</span><br><span class="line">Quicksort(A,i+1,Right);</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">Insertion_Sort(A+Left,Right-Left+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法概述&quot;&gt;&lt;a href=&quot;#算法概述&quot; class=&quot;headerlink&quot; title=&quot;算法概述&quot;&gt;&lt;/a&gt;算法概述&lt;/h1&gt;&lt;p&gt;什么是快速排序算法的最好情况？&lt;/p&gt;
&lt;p&gt;每次正好中分    T(N) = O(NlogN)&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://cjay.life/2020/07/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-19T08:01:33.000Z</published>
    <updated>2020-07-19T09:32:45.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心-有序子列的归并"><a href="#核心-有序子列的归并" class="headerlink" title="核心: 有序子列的归并"></a>核心: 有序子列的归并</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;L &#x3D; 左边起始位置，R &#x3D; 右边起始位置，RightEnd &#x3D; 右边终点位置</span><br><span class="line">void Merge(ElementType A[],ElementType TmpA[],int L,int R,int RightEnd)</span><br><span class="line">&#123;</span><br><span class="line">LeftEnd &#x3D; R-1;&#x2F;&#x2F;左边终点位置</span><br><span class="line">Tmp &#x3D; L;&#x2F;&#x2F;存放数组的起始位置</span><br><span class="line">NumElements &#x3D; RightEnd - L + 1;</span><br><span class="line">while(L&lt;&#x3D;LeftEnd &amp;&amp; R&lt;&#x3D;RightEnd)&#123;</span><br><span class="line">if(A[L]&lt;&#x3D;A[R]) TmpA[Tmp++] &#x3D; A[L++];</span><br><span class="line">elseTmpA[Tmp++] &#x3D; A[R++];</span><br><span class="line">&#125;</span><br><span class="line">while(L&lt;&#x3D;LeftEnd)TmpA[Tmp++] &#x3D; A[L++];</span><br><span class="line">while(R&lt;&#x3D;RightEnd)TmpA[Tmp++] &#x3D; A[R++];</span><br><span class="line">for(i &#x3D; 0;i&lt;NumElements;i++,RightEnd--)</span><br><span class="line">A[RightEnd]&#x3D; TmpA[RightEnd];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><ul><li>分而治之</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;T(N) &#x3D; O(NlogN)</span><br><span class="line">void Msort(ElementType A[],ElementType TmpA[],int L,int RightEnd)&#123;</span><br><span class="line">itn center;</span><br><span class="line">if(L&lt;RightEnd)&#123;</span><br><span class="line">center &#x3D; (L+RightEnd)&#x2F;2;</span><br><span class="line">Msort(A,TmpA,L,center);</span><br><span class="line">Msort(A,TmpA,center+1,RightEnd);</span><br><span class="line">Merge(A,TmpA,L,Center+1,RightEnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>统一函数接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Merge_sort(ElementType A[],int N)&#123;</span><br><span class="line">ElementType *TmpA;</span><br><span class="line">TmpA &#x3D; malloc(N*sizeof(ElementType)));</span><br><span class="line">if(Tmp!&#x3D;NULL)&#123;</span><br><span class="line">MSort(A,TmpA,0,N-1);</span><br><span class="line">free(TmpA);</span><br><span class="line">&#125;</span><br><span class="line">else Error(&quot;空间不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void Merge_pass(ElementType A[],ElementType TmpA[],int N,int length)&#123;</span><br><span class="line">&#x2F;&#x2F;length为当前有序子列的长度</span><br><span class="line">for(i &#x3D; 0;i&lt;&#x3D;N-2*length;i+&#x3D;2*length)</span><br><span class="line">merge1(A,TmpA,i,i+length,i+2*length-1);&#x2F;&#x2F;将A中元素归并到TmpA</span><br><span class="line">if(i+length&lt;N)&#x2F;&#x2F;归并最后两个子序列</span><br><span class="line">Merge1(A,TmpA,i,i+length,N-1);</span><br><span class="line">else&#x2F;&#x2F;最后只剩1个子列</span><br><span class="line">for(j &#x3D; i;j&lt;N;j++)TmpA[j] &#x3D; A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge_sort(ElementType A[],int N)&#123;</span><br><span class="line">ElementType *TmpA;</span><br><span class="line">TmpA &#x3D; malloc(N*sizeof(ElementType));</span><br><span class="line">if(TmpA !&#x3D; NULL)&#123;</span><br><span class="line">while(length&lt;N)&#123;&#x2F;&#x2F;这个循环保证了最后TmpA的数据可以回A去</span><br><span class="line">Merge_pass(A,TmpA,N,length);</span><br><span class="line">length*&#x3D;2;</span><br><span class="line">Merge_pass(TmpA,A,N,length);&#x2F;&#x2F;如果上一步length&gt;N也没关系，会倒回A</span><br><span class="line">legth*&#x3D;2</span><br><span class="line">&#125;</span><br><span class="line">free(TmpA);</span><br><span class="line">&#125;</span><br><span class="line">else Error(&quot;空间不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该算法稳定，但是需要额外空间，不适用于内排序，适用于外排序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;核心-有序子列的归并&quot;&gt;&lt;a href=&quot;#核心-有序子列的归并&quot; class=&quot;headerlink&quot; title=&quot;核心: 有序子列的归并&quot;&gt;&lt;/a&gt;核心: 有序子列的归并&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>csapp第二章:信息的表示和处理</title>
    <link href="https://cjay.life/2020/07/18/csapp%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>https://cjay.life/2020/07/18/csapp%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</id>
    <published>2020-07-18T14:46:15.000Z</published>
    <updated>2020-07-24T07:07:19.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h1><p>机器级程序将内存视为字节数组，每一个字节都有一个数字来标识，称它为地址（address）。在机器级程序的视角里，内存被抽象成了一个概念，名为虚拟内存(virtual address space)。而所有地址的集合被称为虚拟地址空间（virtual address space）。</p><h2 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h2><p>以16为基数，叫做十六进制（hexadecimal）数。在C语言中，以0x或0X开头的数字常量被认为是十六进制的值。</p><p><strong>十六进制转二进制的一个窍门是记住A,C和F对应的十进制的值。（10，12，15）</strong></p><h2 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h2><p>每台计算机都有字长（word size），虚拟地址都是用一个字来编码,因此对于字长为w位的机器，虚拟地址范围为0~2的w次-1；程序最多访问2的w次 的字节。</p><p>大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。</p><h2 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h2><p>对于跨越多字节的数据对象，必须建立两个规则：</p><ul><li>对象的地址是什么</li><li>内存中如何排列这些字节</li></ul><p>对象的地址为所使用字节中最小的地址</p><p>对于排列方式有两种：</p><ul><li>小端法(little endian)：最低有效字节在最前面</li><li>大端法(big endian)：最高有效字节在最前面</li></ul><p>看下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">typedef unsigned char *byte_pointer;</span><br><span class="line"></span><br><span class="line">void show_bytes(byte_pointer start,size_t len)&#123;</span><br><span class="line">size_t i;</span><br><span class="line">for(i &#x3D; 0;i&lt;len;i++)</span><br><span class="line">printf(&quot;%.2x&quot;,start[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h2><p>C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都是以某个标准编码来表示，最常见的是ASCII字符码。注意：<strong>strlen()不计算字符结尾，且在使用ASCII码作为字符码的任何系统都得到相同的结果，与字节顺序和字大小规则无关。</strong></p><h2 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h2><p>对于指令的编码，因为机器类型、不同的操作系统等因素，会有不同编码规则，因此二进制代码不兼容。</p><h2 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h2><p>布尔代数是二元集合{0，1}基础上的定义。用来表示这些运算的符号是与C语言位级运算使用的符号相匹配的。</p><p>布尔运算 ~ 对应逻辑运算NOT</p><p>​                &amp; 对应逻辑运算AND</p><p>​                | 对应逻辑运算OR</p><p>​                ^ 对应逻辑运算异或</p><p>上面四个运算可以扩展到位向量的运算，位向量就是固定长度w，由0和1组成的串。</p><p>&amp;和|互相之间有分配律：a&amp;(b|c) = (a&amp;b)|(a&amp;c)，反之亦然。</p><p>位向量一个很有用的应用就是表示有限集合。布尔代数|和&amp;分别对应于集合的并和交哦，而~对应于集合的补。</p><h2 id="C语言中的位级运算"><a href="#C语言中的位级运算" class="headerlink" title="C语言中的位级运算"></a>C语言中的位级运算</h2><p>C语言中： ~ 对应逻辑运算NOT</p><p>​                &amp; 对应逻辑运算AND</p><p>​                | 对应逻辑运算OR</p><p>​                ^ 对应逻辑运算异或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个有意思的交换函数，运用a^a &#x3D; 0 这一性质</span><br><span class="line">void inplace_swap(int *x,int *y)&#123;</span><br><span class="line">*y &#x3D; *x^*y;</span><br><span class="line">*x &#x3D; *x^*y;</span><br><span class="line">*y &#x3D; *x^*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位级运算一个常见用法就是实现掩码运算，例如：</p><p>x&amp;0xFF生成一个由x的最低有效字节组成的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例题：</span><br><span class="line">除了x的最低有效字节外，其他的位都取补，最低有效字节保持不变</span><br><span class="line">x^0xFF(这样写就可以忽略字长)</span><br><span class="line">x的最低有效字节设置全1，其他字节保持不变</span><br><span class="line">x|0xFF</span><br></pre></td></tr></table></figure><h2 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h2><p>C语言还提供了一组逻辑运算符||、&amp;&amp;和！。<strong>这与位级运算是不同的</strong></p><h2 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h2><p>左移只有逻辑左移对应x&lt;&lt;k。</p><p>右移分为逻辑右移和算术右移x&gt;&gt;k。在C语言中没有明确表示，但大多数编译器都是算术右移，在java中，x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k做逻辑右移。</p><p><strong>若移动k≥w位时，实际移动位数为k mod w</strong></p><p><strong>C语言中加减法的优先级比移位运算要高。1&lt;&lt;2+3&lt;&lt;4，其实时（1&lt;&lt;(2+3)）&lt;&lt;4</strong></p><h1 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h1><p>编码整数的两种不同的方式：一种只能表示非负数，而另一种能表示负数、零和正数。</p><p><img src="https://i.loli.net/2020/07/22/J9qTAOSXkBMFxPL.png" alt="img"></p><h2 id="整型数据类型"><a href="#整型数据类型" class="headerlink" title="整型数据类型"></a>整型数据类型</h2><p>很明显，对于相同的数据类型根据程序编译为32位还是64位而有所不同。</p><p><strong>C和C++都支持有符号和无符号数。java只支持有符号数</strong></p><h2 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h2><p>无符号数编码，定义一个 函数名为B2U(Binary to Unsigned)来表示。</p><p><img src="https://i.loli.net/2020/07/22/kDIMsYiCQdNbFma.png" alt="img"></p><p>B2U是一个双射，是唯一的。</p><h2 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h2><p>最常见的有符号数的计算机表示方式就是补码（two’s-complement）形式。</p><p>将字的最高有效位解释为负权（negative weight）。我们用函数B2T来表示</p><p><img src="https://i.loli.net/2020/07/22/982nGHZEBgDN15x.png" alt="img"></p><p>补码编码的唯一性</p><p>B2T是一个双射。</p><p>|TMin| = |TMax| + 1,之所以不对称，因为一半的位模式表示负数，而另一半（符号设置为0）表示非负数，也就意味能表示的整数比负数少一个。第二：UMAX = 2TMAX+1</p><p>为了一些程序也能够在大量的机器和编译器移植，C库中的&lt;limits.h&gt;定义了一组常量(消除了可变性)，INT_MAX,INT_MIN等等。</p><p>而数据类型的取值范围，java标准是非常明确的。</p><h2 id="有符号数和无符号数之间的转换"><a href="#有符号数和无符号数之间的转换" class="headerlink" title="有符号数和无符号数之间的转换"></a>有符号数和无符号数之间的转换</h2><p>C语言允许不同数字类型之间进行强制类型转换。</p><p>强制类型转换的本质是，位值不变，只是改变了解释这些位的方式。</p><h3 id="原理：补码转化位无符号数"><a href="#原理：补码转化位无符号数" class="headerlink" title="原理：补码转化位无符号数"></a>原理：补码转化位无符号数</h3><p><strong>若满足 Tmin≤x≤Tmax的x有</strong></p><p>​                        </p><p><strong>T2U（x） =   x+2的w次,     x&lt;0</strong></p><p>​                       <strong>x,                    x≥0</strong></p><p><img src="https://i.loli.net/2020/07/22/SNJO8wZUC5ugMdG.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/H1SgAlRJ4cM2OVz.png" alt="img"></p><h3 id="无符号数转化为补码"><a href="#无符号数转化为补码" class="headerlink" title="无符号数转化为补码"></a>无符号数转化为补码</h3><p><strong>若满足 0≤u≤Umax的u有</strong></p><p>​                        </p><p><strong>U2T（x） =  u,                            u≤Tmax</strong></p><p>​                       <strong>u-2的w次,                   u&gt;Tmax</strong></p><p><img src="https://i.loli.net/2020/07/22/qSPZxaJyVi3cmCk.png" alt="img"></p><h2 id="C语言中的有符号数与无符号数"><a href="#C语言中的有符号数与无符号数" class="headerlink" title="C语言中的有符号数与无符号数"></a>C语言中的有符号数与无符号数</h2><p>C语言标准没有指定有符号数采用哪种表示，但几乎所有机器都使用补码。</p><p>当申明一个常量默认被当作有符号，要创建一个无符号数常量，必须加上后缀字符U</p><h2 id="拓展一个数字的位表示"><a href="#拓展一个数字的位表示" class="headerlink" title="拓展一个数字的位表示"></a>拓展一个数字的位表示</h2><ul><li>无符号数的零扩展（zero extension）：高位填0就行了</li><li>符号宽展（sign extension)：<img src="https://i.loli.net/2020/07/22/IK2Tw5Ee1AJrmcO.png" alt="img"></li></ul><p>当short转换成unsigned时，首先要改变大小，再完成从有符号到无符号之间的转换。也就是说(unsigned)sx等价于(unsigned)(int)sx。这个规则是C语言标准要求的。</p><p>对于C语言而言，无符号数移位是逻辑移位，有符号数移位是算术移位。 </p><h2 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h2><ul><li>截断无符号数：x’ = x mod 2的k次（截断为k位的结果）</li><li>截断补码数值：具有相似的属性，只不过要将最高位转换为符号位。</li></ul><h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><h2 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h2><p><img src="https://i.loli.net/2020/07/22/yv7sYBCVqb65W1L.png" alt="img"></p><p>对于两个非负整数，满足0≤x,y≤2的w次。每个数都表示为w位无符号数字，然而计算和，可能范围为0≤x+y≤2的（w+1）次-2。</p><p>一般来说，如果x+y＜2的w次，和的w+1位表示中的最高位会等于0，因此不会改变。相反另一种情况会等于1，因此丢弃它相当于从和中减去2的w次。</p><p><img src="https://i.loli.net/2020/07/22/hRTqSjyYUQPf1Ni.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/eonkqLh6mjz8GTD.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/YDNaCt5d6y2on9l.png" alt="img"></p><p>当执行C程序时，不会将溢出作为错误而发信号。所以需要另外检测。</p><p>对在范围0≤x,y≤umax中的x和y，令s = x+y，当s&lt;x或s&lt;y时，发生了溢出。另一方面，如果s确实溢出了，我们就有 s = x+y-2的w次。假设 y&lt;2的w次，我们就有 y-2的w次＜0，因此s&lt;x。</p><h3 id="无符号数取反"><a href="#无符号数取反" class="headerlink" title="无符号数取反"></a>无符号数取反</h3><p><img src="https://i.loli.net/2020/07/22/UvECyAiYpIgMDbJ.png" alt="img"></p><h2 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h2><p><img src="https://i.loli.net/2020/07/22/NJMkY8ew3WszdDu.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/TwpNJS372iqrCUV.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/4KkTBxauCGRtdJj.png" alt="img"></p><p>检测补码加法中的溢出：当x&lt;0,y&lt;0,但s≥0,计算s发生了负溢出。负溢出也是同样道理。</p><h2 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h2><p><img src="https://i.loli.net/2020/07/22/IgLaNrQ8MKezFG4.png" alt="img"></p><p><strong>补码非得位级表示：在C语言中，对于任意整数x,计算-x和~x+1结果一样。</strong></p><h2 id="无符号数乘法"><a href="#无符号数乘法" class="headerlink" title="无符号数乘法"></a>无符号数乘法</h2><p>范围在0&lt;=x,y&lt;=2w-1内的整数x和y可以被表示为w位的无符号数，但是它们的乘积的取值范围为0到2的2w次-2的（w+1）次+1。这可能需要2w位来表示。不过，C语言中的无符号乘法被定义为产生w位的值，就是2w位的整数乘积的低w位表示的值。</p><p><img src="https://i.loli.net/2020/07/22/kA7ZIKoeCUTSmYp.png" alt="img"></p><h2 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h2><p><strong>补码乘法和无符号数乘法具有位级等价性。</strong></p><p><img src="https://i.loli.net/2020/07/22/lLXw4xIu7HPR2bF.png" alt="img"></p><h2 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h2><p>大多数机器，整数乘法指令相当慢，需要10个或者更多的时钟周期，然后其他整数运算只需要1个时钟周期，所以试着用移位和加法运算的组合来代替乘以常数因子的乘法</p><h3 id="乘以2的幂"><a href="#乘以2的幂" class="headerlink" title="乘以2的幂"></a>乘以2的幂</h3><p>需要C语言编译器试图以移位，加法和减法的组合来消除很多整数乘以常数的情况。例如：x*14，编译器将乘法重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)</p><h3 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h3><p>整数除法比乘法更慢，需要30个或更多时钟周期。才用右移来实现，无符号数和补码数分别使用逻辑移位和算术移位来达到目的。</p><p>整数除法总是舍入到0。对于负数向上，对于正数向下。</p><p>对于无符号数。采用逻辑移位。设x’为w-k位[x的w-1,…,w的k]的无符号数，而x’’为k位表示[x的k-1,…,x的0]的无符号数,x = 2的k次*x’+x’’,而0≤x’’&lt;2的k次。因此x’自然向下取整。</p><p>对于补码来说。移位执行的是算术移位。对于正数来说，与无符号数一样的。对于负数，普通的算术移位，会导致向下舍入，所以需要配调整。</p><p>对于，负数想要向上舍入，如何调整？</p><p>在移位之前，“偏置（biasing）”这个值，来修正不适合的舍入。C变量x和k分别有补码值x和无符号数值k，且0≤k&lt;w,则当执行算术移位时，C表达式(x+(1&lt;&lt;k)-1)&gt;&gt;K。</p><p>根本原理：x/y向上取整 = （x+y-1）/y向下取整。</p><p>假设x=qy+r，其中0≤r&lt;y,得到(x+y-1)/y=q+(r+y-1)/y，因此。当r=0时，后面一项等于0，而当r&gt;0时，等于1。也就是说，通过给x增加一个偏量y-1，然后再用除法向下舍入，当y整数x时，我们得到q，否则，就得到q+1。回到y=2k的情况，C表达式X+(1&lt;&lt;K)-1得到数值x+2的k次-1。</p><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><h2 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h2><p>二进制小数点往左移动一位相当于这个数被2除。往右移动一位，相当于将该数乘2。假定我们仅考虑有限从长度的编码，有些小数是不能被精确表示(只能表示: x*2的y次)，只能通过长度不断逼近。</p><h2 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h2><p>IEEE浮点标准用<img src="https://i.loli.net/2020/07/22/olTFs5RBNMtiqvy.png" alt="img">的形式来表示一个数：</p><ul><li>符号（sign）s决定是负数（s=1）还是正数（s=0），而对于数值0的符号位解释作为特殊情况处理。</li><li>尾数（significand）M是一个二进制小数，它的范围是1<del>2-ε，或者是0</del>1-ε。</li><li>阶码（exponent）E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。</li></ul><p>在单精度浮点数中，s、exp、frac分别1、8、23。双精度1,11,52。</p><p>根据exp的值，被编码的值可以分成三种不同的情况（最后的情况有两个变种）。</p><p><img src="https://i.loli.net/2020/07/22/EfHFSGqmxK9oVBN.png" alt="img"></p><ul><li>情况1（规格化数）：阶码的值E = e-bias。e为无符号数。尾数具有隐含的1开头（implied leading 1）表示。</li><li>情况2 （非规格化数）:E = 1-bias。尾数不包含隐含位1开头。（这里设置1-bias是为了平滑过度到规格化值，具体看下图）</li><li>情况3（特殊值）：阶码全为1的时候出现的，当小数域全为0时，根据符号位，得到正负无穷。小数域非0时，结果值称为“NAN”(Not a Number)。例如计算根号-1。</li></ul><h2 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h2><p><img src="https://i.loli.net/2020/07/22/JUIsNwlijmrqC68.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/xYSnNpm7fCOu12j.png" alt="img"></p><p>可以观察到最大非规格化数和最小规格化数之间的平滑转变。这是一个有趣的属性，当这些表达式解释为无符号整数时，它们就是按升序排列的。</p><h2 id="舍入（rounding）"><a href="#舍入（rounding）" class="headerlink" title="舍入（rounding）"></a>舍入（rounding）</h2><p>向偶数舍入（round-to-even），也被称为向最接近的值舍入（round-to-nearest），是默认的方式。</p><p><img src="https://i.loli.net/2020/07/22/hl1zEIGjO5Hn4gt.png" alt="img"></p><h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><p>浮点运算具有交换律，但不具备结合律。对于表达式（3.14+1e10）-1e10求得0，是因为3.14由于太小，被舍入丢失了。另外两个特例（正无穷加负无穷=NAN，x+NAN=NAN）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;信息存储&quot;&gt;&lt;a href=&quot;#信息存储&quot; class=&quot;headerlink&quot; title=&quot;信息存储&quot;&gt;&lt;/a&gt;信息存储&lt;/h1&gt;&lt;p&gt;机器级程序将内存视为字节数组，每一个字节都有一个数字来标识，称它为地址（address）。在机器级程序的视角里，内存被抽象成
      
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://cjay.life/2020/07/18/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/18/%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-18T10:29:54.000Z</published>
    <updated>2020-07-18T14:45:07.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Selection_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">MinPostion &#x3D; ScanForMin(A,i,N-1);&#x2F;&#x2F;找最小元O（N）</span><br><span class="line">Swap(A[i],A[MinPostion]);&#x2F;&#x2F;将未排序部分的最小元换到有序部分的最后位置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看出，虽然元素交换次数变为N-1次，但是寻找最小元的次数固定为N2。</p><p>无论如何： T = O（N2）；</p><p>这里想提高效率，只能从寻找最小元找突破口。</p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Heap_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">BuildHeap(A);&#x2F;&#x2F;O(N);</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">TmpA[i] &#x3D; DeleteMin(A);&#x2F;&#x2F;O(logN)</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">A[i] &#x3D; TmpA[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T(N) = O(NlogN)</p><p>需要额外O（N）空间，并且复制元素需要时间。</p><h2 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Heap_Sort(ElemtType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">BuildHeap(A);</span><br><span class="line">for(i &#x3D; N-1;i&gt;0;i--)&#123;</span><br><span class="line">Swap(&amp;A[0],&amp;A[i]);&#x2F;&#x2F; DeleteMax</span><br><span class="line">PercDown(A,0,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定理：堆排序处理N个不同元素的随机排列的平均比较次数是2NlogN-O(NloglogN);</p><p>虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void Swap(ElementType *a,ElementType *b)</span><br><span class="line">&#123;</span><br><span class="line">ElementType t &#x3D; *a;*a &#x3D; *b;*b &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line">void PercDown(ElementType A[],int p,int N)&#x2F;&#x2F;将N个元素的数组中以A[p]为根的子堆调为最大堆</span><br><span class="line">&#123;</span><br><span class="line">int Parent,Child;</span><br><span class="line">ElementType X;</span><br><span class="line">X &#x3D; A[p];</span><br><span class="line">for(Parent &#x3D; p;(Parent*2+1)&lt;N;Parent &#x3D; Child)&#123;</span><br><span class="line">Child &#x3D; Parent*2+1;</span><br><span class="line">if((Child!&#x3D;N-1)&amp;&amp;(A[Child]&lt;A[Child+1]))</span><br><span class="line">Child++;&#x2F;&#x2F;取左右子节点中的最大者;</span><br><span class="line">if(X&gt;&#x3D;A[Child]) break;</span><br><span class="line">else</span><br><span class="line">A[parent] &#x3D; A[Child];</span><br><span class="line">&#125;</span><br><span class="line">A[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i &#x3D; N&#x2F;2-1;i&gt;&#x3D;0;i--)</span><br><span class="line">PercDown(A,i,N);</span><br><span class="line">for(i &#x3D; N-1;i&gt;0;i--)&#123;</span><br><span class="line">Swap(&amp;A[0],&amp;A[i]);</span><br><span class="line">PercDown(A,0,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="https://cjay.life/2020/07/18/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/18/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-18T09:31:15.000Z</published>
    <updated>2020-07-18T09:59:06.777Z</updated>
    
    <content type="html"><![CDATA[<p>定义增量序列 Dm&gt;Dm-1&gt;…&gt;D1 = 1</p><p>对每个Dk进行Dk间隔排序（k = m,m-1,…1）</p><p>注意: Dk间隔有序的序列，在执行Dk-1间隔排序后，仍然是Dk间隔有序的</p><h1 id="希尔增量序列"><a href="#希尔增量序列" class="headerlink" title="希尔增量序列"></a>希尔增量序列</h1><p>原始希尔排序    Dm =    N/2向下取整,    Dk = Dk+1/2向下取整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Shell_sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">for(D&#x3D;N&#x2F;2;D&gt;0;D&#x2F;&#x3D;2)&#123;&#x2F;&#x2F;希尔增量序列</span><br><span class="line">for(P&#x3D;D;P&lt;N;P++)&#123;&#x2F;&#x2F;插入排序</span><br><span class="line">Tmp &#x3D; A[P];</span><br><span class="line">for(i&#x3D;P;i&gt;&#x3D;0&amp;&amp;A[i-D]&gt;Tmp;i-&#x3D;D)</span><br><span class="line">A[i] &#x3D; A[i-D];</span><br><span class="line">A[i] &#x3D; Tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最坏情况：T &#x3D; 平均时间复杂度（N2），如果增量序列里的元素不互质数，下面的排序都是无用功，直到增量为1才起作用</span><br></pre></td></tr></table></figure><h1 id="更多增量序列"><a href="#更多增量序列" class="headerlink" title="更多增量序列"></a>更多增量序列</h1><h2 id="Hibbard增量序列"><a href="#Hibbard增量序列" class="headerlink" title="Hibbard增量序列"></a>Hibbard增量序列</h2><p>Dk = 2的k次-1(相邻元素互质)</p><p>最坏情况 T = O（N的3/2次）</p><p>猜想: T平均 = O（N的5/4次）</p><h2 id="Sedgewick增量序列"><a href="#Sedgewick增量序列" class="headerlink" title="Sedgewick增量序列"></a>Sedgewick增量序列</h2><p>{1，5，19，41，109，。。。}</p><p>9*4的i次-9*2的i次+1    或           4的i次-3*2的i次+1</p><p>猜想： T平均 = O（N的7/6次)    ,T最差 = O(N的4/3次)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void ShellSort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">int si,D,P,i;</span><br><span class="line">ElementType Tmp;</span><br><span class="line">int Sedgewick[] &#x3D; &#123;929,505,209,41,19,5,1,0&#125;&#x2F;&#x2F;一小部分</span><br><span class="line">for(si &#x3D; 0;Sedgewocl[si]&gt;&#x3D;N;si++)</span><br><span class="line">;</span><br><span class="line">for(D &#x3D; Sedgewick[si];D&gt;0;D &#x3D; Sedgewick[++D])&#123;</span><br><span class="line">for(P &#x3D; D;P&lt;N;p++)&#123;</span><br><span class="line">Tmp &#x3D; A[p];</span><br><span class="line">for(i &#x3D; P;i&gt;&#x3D;0&amp;&amp;tmp&lt;A[i];i-&#x3D;D)</span><br><span class="line">A[i] &#x3D; A[i-D];</span><br><span class="line">A[i] &#x3D; Tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;定义增量序列 Dm&amp;gt;Dm-1&amp;gt;…&amp;gt;D1 = 1&lt;/p&gt;
&lt;p&gt;对每个Dk进行Dk间隔排序（k = m,m-1,…1）&lt;/p&gt;
&lt;p&gt;注意: Dk间隔有序的序列，在执行Dk-1间隔排序后，仍然是Dk间隔有序的&lt;/p&gt;
&lt;h1 id=&quot;希尔增量序列&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>csapp第一章：计算机系统漫游</title>
    <link href="https://cjay.life/2020/07/17/csapp%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <id>https://cjay.life/2020/07/17/csapp%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</id>
    <published>2020-07-17T04:23:05.000Z</published>
    <updated>2020-07-18T09:13:05.946Z</updated>
    
    <content type="html"><![CDATA[<p>本书第一章开头通过跟踪hello程序的生命周期对系统进行学习</p><a id="more"></a><h1 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h1><p>Hello程序在一开始仅仅只是由编辑器创建的文本文件。这些文本文件在本质上都只是比特序列。</p><p><strong>比特序列是如何表示成文本字符？</strong></p><p><strong>这里采用编码标准，标准有很多，这里已ASCII标准为例：ASCII标准将这些最原始的比特序列，分成以字节（8个bit）为单位来表示每个字符。相当于y = f(x),y是文本字符，x是一个字节的bit串，函数f()是ASCII标准，该函数一一映射</strong></p><p><img src="https://i.loli.net/2020/07/17/OKGhCnreoVE1NYX.png" alt></p><p><strong>注意：文本中，每个文本行都有看不见的换行符’\n’，对应整数10</strong></p><p>所以在计算机中，比特序列是通过<strong>读到数据对象时的上下文</strong>来区分不同的数据对象</p><h1 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h1><p>源程序到目标程序（也称为可执行目标文件）转变过程如下：</p><p><img src="https://i.loli.net/2020/07/18/kDML9f4TUYNvcIZ.jpg" alt></p><ul><li>预处理阶段：修改原始C程序，比如将#include&lt;stdio.h&gt;中的stdio.h的内容直接插入程序文本中。最后将扩展名改为.i</li><li>编译阶段：通过编译器，转成了汇编语言程序。</li><li>汇编阶段：通过汇编器，转成了机器语言指令，把这些指令打包成可重定位目标程序（relocatable object program）的格式，保存到hello.o中</li><li>链接阶段：hello程序中调用了printf函数，该阶段就是将hello.o与printf.o以某种方式合并起来</li></ul><h1 id="处理器读并解释存在内存中的指令"><a href="#处理器读并解释存在内存中的指令" class="headerlink" title="处理器读并解释存在内存中的指令"></a>处理器读并解释存在内存中的指令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; .&#x2F;hello</span><br><span class="line">hello,world</span><br><span class="line">linux&gt;</span><br></pre></td></tr></table></figure><p>上图是通过shell（命令行解释器）运行了hello程序。</p><h2 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h2><ol><li>总线：总线被设计成传送定长的字节快，也就是字（word）。字长是系统的一个基本参数，每个系统中都不尽相同。大多数系统中要不32位要不64位。</li><li>I/O设备：每个I/O设备都通过一个控制器或适配器与I/O总线相连。<ul><li>控制器是I/O设备本身或系统的电路板上的芯片组</li><li>适配器是插在主板卡槽上的卡</li></ul></li><li>主存：由一组动态随机存取存储器（DRAM）芯片组成的。</li><li>处理器：是届时或执行存储在内存中指令的引擎。存储器核心是一个大小为一个字的寄存器，称为程序计数器PC，用于指向内存中某条机器语言指令。</li></ol><h2 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h2><p>初始时，shell程序执行它的指令，等待我们输入一个命令。当在键盘上输入“./hello”后，shell程序将字符逐一读入寄存器，再把它放到内存中</p><p><img src="https://i.loli.net/2020/07/18/ygsBjpQWza2c8mK.png" alt></p><p>当输入回车，shell知道我们结束了命令的输入。然后shell执行一系列指令加载并执行hello文件，将这个文件复制到主存。</p><p><img src="https://i.loli.net/2020/07/18/sE1g2olaPY3XStk.png" alt></p><p>处理器就开始执行这些机器语言指令。“Hello world”字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备。</p><p><img src="https://i.loli.net/2020/07/18/req7AfVIOmHBhJl.png" alt></p><h2 id="高速缓存至关重要"><a href="#高速缓存至关重要" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><p>高速缓存通过静态随机访问存储器（SRAM）的硬件技术实现。</p><h2 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h2><p>主要思想是上一层的存储器作为第一层存储器的高速缓存。</p><h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>shell与hello程序都没有直接访问硬件，取而代之是由操作系统提供服务。</p><p>操作系统两个基本功能：</p><ol><li>防止硬件被应用程序滥用</li><li>向应用程序提供简单的机制来控制硬件设备</li></ol><p>操作系统主要采用几个抽象概念来实现上面两个功能：</p><ol><li>文件对I/O设备的抽象表示</li><li>虚拟内存对主存和磁盘I/O设备的抽象表示</li><li>进程则是对处理器、主存和I/O设备的抽象表示</li></ol><p><img src="https://i.loli.net/2020/07/18/IdOl8L1XK7VxJn6.jpg" alt></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是操作系统对一个正在运行的程序一种抽象。有了这种抽象，一个系统上可以并发多个进程。这种并发执行，通过处理器来进程间切换来实现的。操作系统实行这种交错执行的机制称为<strong>上下文切换</strong>。</p><p><strong>上下文是指操作系统跟踪进程运行所需要的状态信息，比如PC和寄存器的当前值，以及主存的内容</strong></p><p>上下文切换其实就是保存当前进程的上下文，恢复新进程的上下文，然后将控制区传递给新进程。</p><p>对于两个并发进程：shell进程和hello进程。刚开始shell进程在运行，即等待命令行输入。</p><p>当运行hello程序，shell系统调用-》系统调用将控制权从shell到给操作系统-》操作系统保存shell进程上下文-》创建hello进程上下文并将控制权给hello进程-》hello进程终止-》操作系统恢复shell上下文，并将控制区给shell</p><p><img src="https://i.loli.net/2020/07/18/sFRvVEjpfN2KTrX.png" alt></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>现代操作系统中，进程由多个线程的执行单元构成，每个线程运行在进程上下文中，享有同样的代码与数据。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存是一种抽象概念，给进程提供一种假象，即每个进程都在独占使用主存。每个进程看到都是虚拟地址空间</p><p><img src="https://i.loli.net/2020/07/18/7vjezVrfUP1kngA.png" alt="Linux进程的虚拟地址空间"></p><p>最低地址开始，从上介绍。</p><ul><li>程序代码和数据：先是代码，接着是数据。</li><li>堆：代码与数据在进程开始运行时就被指定了大小。但调用像malloc和free这样C标准库函数时，堆在运行时动态扩展与搜索。</li><li>共享库：用来存放C标准库和数学库这样的共享库的代码和数据区域。</li><li>栈：编译器用它实现函数调用，调用一个函数，栈增长，一个函数返回时，栈就会收缩。也可以动态扩展和收缩。</li><li>内核虚拟内存：为内核保留</li></ul><p>虚拟内存的运作需要<strong>硬件和操作系统之间交互，包括堆处理器生成的每个地址的硬件翻译</strong></p><p>基本思想是进程虚拟内存的内容存在磁盘上，用主存作为磁盘的高速缓存。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件本质是字节序列。但它向应用程序提供了一个统一的视图来看待各式各样的I/O设备。</p><h1 id="系统之间的网络通信"><a href="#系统之间的网络通信" class="headerlink" title="系统之间的网络通信"></a>系统之间的网络通信</h1><p>系统从主存复制一串字到网络适配器时，数据流过网络到达另一台机器。同时，系统也可以从读取其他机器发送过来的数据，并复制到主存。</p><p><img src="https://i.loli.net/2020/07/18/8SheWR1Fi7Jp5Ug.png" alt></p><h1 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h1><h2 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h2><p>若系统执行某应用程序需要时间Told。假设其中某部分与整体时间的比例为a。</p><p>若该部分性能提升k。则新的执行时间为：<strong>Tnew = (1-a)Told+（aTold）/k = Told[(1-a)+a/k]</strong></p><p>加速比 <strong>S = Told/Tnew = 1/[(1-a)+a/k];</strong></p><p><strong>若k-&gt;∞，则S = 1/（1-a）</strong>，说明想要高的加速比只有通过优化系统大部分组件才行。</p><h2 id="并发（concurrency）与并行-parallelism"><a href="#并发（concurrency）与并行-parallelism" class="headerlink" title="并发（concurrency）与并行(parallelism)"></a>并发（concurrency）与并行(parallelism)</h2><ol><li>线程级并发：使用线程可以在一个进程中执行多个控制流。想要实现线程级的并发，可以采用以下两个技术<ol><li>多核处理器：将多个CPU集成到一个集成电路芯片上。<img src="https://i.loli.net/2020/07/18/RPd5SgyTNUwiVlf.png" alt></li><li>超线程（hyperthreading）或称为同时多线程(simultaneous multi-threading)，允许一个CPU通过执行多个CPU。说是一个CPU，其实CPU里的某些硬件变成了多份，比如程序计数器和寄存器文件。平常线程切换大约需要20000个周期，而采用超线程技术后，只要一个周期。</li></ol></li><li>指令集并行：在较低抽象层次上，现代处理器可以同时执行多条指令。采用流水线(Pipelining),将一条指令分成不同步骤，将硬件组织分成一系列阶段。硬件不同部分来处理指令的不同部分。能够达到接近于一个时钟周期的执行效率。而超标量（super-scalar）处理器速度更快。</li><li>单指令、多数据并行(SIMD):允许一条指令产生多个可以并行的操作。</li></ol><h2 id="计算机系统中抽象的重要性"><a href="#计算机系统中抽象的重要性" class="headerlink" title="计算机系统中抽象的重要性"></a>计算机系统中抽象的重要性</h2><p>例如为一组函数规定简单的应用程序接口（API），使程序员无需了解它内部的工作便可使用。</p><p>指令集架构就是提供了堆实际处理器硬件的抽象。使用这个抽象，机器代码程序好像运行在一个一次只执行一次指令的处理器上。</p><p><img src="https://i.loli.net/2020/07/18/wchIqyM1FjCWVBP.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本书第一章开头通过跟踪hello程序的生命周期对系统进行学习&lt;/p&gt;
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>csapp</title>
    <link href="https://cjay.life/2020/07/17/csapp/"/>
    <id>https://cjay.life/2020/07/17/csapp/</id>
    <published>2020-07-17T04:13:29.000Z</published>
    <updated>2020-07-25T13:53:03.181Z</updated>
    
    <content type="html"><![CDATA[<p>计划:阅读CSAPP和看对应CMU课程，看完后，总结笔记。</p><hr><p>该篇blog用于记录实施进度。</p><p>2020.7.17    1-20</p><p>2020.7.18    20-34</p><p>2020.7.19    34-54</p><p>2020.7.20    54-60（没有效率的一天）</p><p>2020.7.21    60-75</p><p>20207.22    75-88</p><p>2020.7.24    109-122</p><p>2020.7.25    122-136</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计划:阅读CSAPP和看对应CMU课程，看完后，总结笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;该篇blog用于记录实施进度。&lt;/p&gt;
&lt;p&gt;2020.7.17    1-20&lt;/p&gt;
&lt;p&gt;2020.7.18    20-34&lt;/p&gt;
&lt;p&gt;2020.7.19    34-54&lt;/p
      
    
    </summary>
    
    
      <category term="计划" scheme="https://cjay.life/categories/%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="计划" scheme="https://cjay.life/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>简单排序</title>
    <link href="https://cjay.life/2020/07/16/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/16/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-16T14:41:31.000Z</published>
    <updated>2020-07-18T10:29:32.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Bubble_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">for(p &#x3D; N-1;p&gt;&#x3D;0;p--)&#123;</span><br><span class="line">flag &#x3D; 0;</span><br><span class="line">for(i &#x3D; 0;i&lt;p;i++)&#123;&#x2F;&#x2F;一趟冒泡</span><br><span class="line">if(A[i]&gt;A[i+1])&#123;</span><br><span class="line">Swap(A[i],A[i+1]);</span><br><span class="line">flag &#x3D; 1;&#x2F;&#x2F;标识发生了交换</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag &#x3D;&#x3D; 0) break;&#x2F;&#x2F;全程无交换</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：顺序T=O（N）</p><p>最欢情况：逆序T=O（N2）</p><p>稳定，也可以应用于链表</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Insertion_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">for(p &#x3D; 1;p&lt;N;p++)&#123;</span><br><span class="line">Tmp &#x3D; A[p];</span><br><span class="line">for(i &#x3D; p;i&gt;&#x3D;0&amp;&amp;tmp&lt;A[i-1];i--)</span><br><span class="line">A[i] &#x3D; A[i-1];</span><br><span class="line">A[i] &#x3D; Tmp;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：顺序T=O（N）；</p><p>最坏情况: 逆序T=O(N2);</p><h1 id="时间复杂度下界"><a href="#时间复杂度下界" class="headerlink" title="时间复杂度下界"></a>时间复杂度下界</h1><p>对于i&lt;j,如果A[i]&gt;A[j],则称（i,j）是一对逆序对（inversion）</p><p>对于简单排序，都是相邻元素交换，每交换一次正好消去1个逆序对！</p><p>插入排序：T（N,I）= O（N+I），如果序列基本有序，则插入排序简单高效</p><p>定理:任意N个不同元素组成的序列平均具有<strong>N（N-1）/4</strong>个逆序对。</p><p>定理:任何交换相邻元素排序的算法，其平均时间为<strong>Ω（N2）</strong>。</p><p>这意味着，想提高效率，必须:</p><ul><li>每次消去不止1个逆序对</li><li>每次交换相隔较远的2个元素</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>cmu csapp lecture 02 Bits,Bytes,and Integer</title>
    <link href="https://cjay.life/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/"/>
    <id>https://cjay.life/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/</id>
    <published>2020-07-15T10:42:43.000Z</published>
    <updated>2020-07-17T07:18:05.230Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/02-03-bits-ints.pdf" target="_blank" rel="noopener">讲义地址</a></p><h1 id="Representing-amp-Manipulating-Sets"><a href="#Representing-amp-Manipulating-Sets" class="headerlink" title="Representing &amp; Manipulating Sets"></a>Representing &amp; Manipulating Sets</h1><h2 id="Representing"><a href="#Representing" class="headerlink" title="Representing"></a>Representing</h2><p>01101001{0,3,5,6}</p><p>01010101{0,2,4,6}</p><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><p>&amp; Intersection {0,6}</p><p>|  Union            {0,2,3,4,5,6}</p><p>^  Symmetric difference {2,3,4,5}</p><p>~ Complement {1,3,5,7}</p><p>上面的布尔代数运算，是从集合的角度来看。</p><p>watch out for &amp;&amp; vs &amp;(and || vs |)..(Bit-level Operations and logic Operations)</p><h1 id="shift-Operations"><a href="#shift-Operations" class="headerlink" title="shift Operations"></a>shift Operations</h1><h2 id="Left-Shift-x-lt-lt-y"><a href="#Left-Shift-x-lt-lt-y" class="headerlink" title="Left Shift : x &lt;&lt; y"></a>Left Shift : x &lt;&lt; y</h2><h2 id="Right-Shift-x-gt-gt-y"><a href="#Right-Shift-x-gt-gt-y" class="headerlink" title="Right Shift: x&gt;&gt;y"></a>Right Shift: x&gt;&gt;y</h2><h3 id="Logical-shift-Fill-with-0’s-on-left"><a href="#Logical-shift-Fill-with-0’s-on-left" class="headerlink" title="Logical shift:Fill with 0’s on left"></a>Logical shift:Fill with 0’s on left</h3><h3 id="Arithmetic-shift-Replicate-most-significant-bit-on-letf"><a href="#Arithmetic-shift-Replicate-most-significant-bit-on-letf" class="headerlink" title="Arithmetic shift: Replicate most significant bit on letf"></a>Arithmetic shift: Replicate most significant bit on letf</h3><h1 id="Conversion-Visualized"><a href="#Conversion-Visualized" class="headerlink" title="Conversion Visualized"></a>Conversion Visualized</h1><p><img src="/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/1.png" alt="Conversion"></p><h1 id="Casting-Suprises"><a href="#Casting-Suprises" class="headerlink" title="Casting Suprises"></a>Casting Suprises</h1><p>在单一表达式中混有有符号数和无符号数，有符号数会转换成无符号数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/02-03-bits-ints.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;讲义地址&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>三点心得</title>
    <link href="https://cjay.life/2020/07/14/%E4%B8%89%E7%82%B9%E5%BF%83%E5%BE%97/"/>
    <id>https://cjay.life/2020/07/14/%E4%B8%89%E7%82%B9%E5%BF%83%E5%BE%97/</id>
    <published>2020-07-14T09:42:12.000Z</published>
    <updated>2020-07-14T09:44:11.049Z</updated>
    
    <content type="html"><![CDATA[<ol><li>当脑海中浮现不开心的事情后，想开心的事情。</li><li>每次结束前，尽量克服难关。</li><li>趁热打铁</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;当脑海中浮现不开心的事情后，想开心的事情。&lt;/li&gt;
&lt;li&gt;每次结束前，尽量克服难关。&lt;/li&gt;
&lt;li&gt;趁热打铁&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="技巧" scheme="https://cjay.life/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="https://cjay.life/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>旅游规划</title>
    <link href="https://cjay.life/2020/07/13/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/"/>
    <id>https://cjay.life/2020/07/13/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/</id>
    <published>2020-07-13T14:46:14.000Z</published>
    <updated>2020-07-13T14:55:02.274Z</updated>
    
    <content type="html"><![CDATA[<p>7-9 旅游规划 (25分)</p><p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入数据的第1行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0~(<em>N</em>−1)；<em>M</em>是高速公路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。随后的<em>M</em>行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 40</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,S,D;</span><br><span class="line">int visited[505];</span><br><span class="line">int cost[505];</span><br><span class="line">int dist[505];</span><br><span class="line">int costs[505][505];</span><br><span class="line">int graph[505][505];</span><br><span class="line">int t1,t2,t3,t4;</span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;505;i++)&#123;</span><br><span class="line">for(int j &#x3D; 0;j&lt;505;j++)&#123;</span><br><span class="line">if(i!&#x3D;j)&#123;</span><br><span class="line">costs[i][j] &#x3D; 65535;</span><br><span class="line">graph[i][j] &#x3D; 65535;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Dijkstra(int s)&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;&#x2F;&#x2F;初始化</span><br><span class="line">cost[i] &#x3D; costs[s][i];</span><br><span class="line">dist[i] &#x3D; graph[s][i];</span><br><span class="line">&#125;</span><br><span class="line">while(1)&#123;</span><br><span class="line">int min &#x3D; 65535;</span><br><span class="line">int v &#x3D; -1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((i!&#x3D;s)&amp;&amp;(visited[i] &#x3D;&#x3D; 0)&amp;&amp;(graph[s][i]&lt;min))&#123;</span><br><span class="line">v &#x3D; i;</span><br><span class="line">min &#x3D; graph[s][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(v &#x3D;&#x3D; -1) break;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((visited[i] &#x3D;&#x3D; 0)&amp;&amp;(dist[v]+graph[v][i]&lt;dist[i]))&#123;</span><br><span class="line">dist[i] &#x3D; dist[v] + graph[v][i];</span><br><span class="line">cost[i] &#x3D; cost[v]+costs[v][i];</span><br><span class="line">&#125;else if((dist[v]+graph[v][i] &#x3D;&#x3D; dist[i])&amp;&amp;(cost[v]+costs[v][i]&lt;cost[i]))&#123;</span><br><span class="line">cost[i] &#x3D; cost[v] + costs[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;D;</span><br><span class="line">reset();&#x2F;&#x2F;初始化</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3&gt;&gt;t4;</span><br><span class="line">graph[t1][t2] &#x3D; t3;</span><br><span class="line">graph[t2][t1] &#x3D; t3;</span><br><span class="line">costs[t1][t2] &#x3D; t4;</span><br><span class="line">costs[t2][t1] &#x3D; t4;</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(S);</span><br><span class="line">cout&lt;&lt;dist[D]&lt;&lt;&quot; &quot;&lt;&lt;cost[D];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他变型问题"><a href="#其他变型问题" class="headerlink" title="其他变型问题"></a>其他变型问题</h3><p>要求数最短路径有几条</p><ol><li>初始化起点:count[s] = 1;</li><li>如果找到更短路：count[w] = count[v];</li><li>如果找到等长路：count[w]+=count[v];</li></ol><p>要求边数最少的最短路</p><pre><code>1. counts[s] = 0; 2. 如果找到更短路：count[w] = count[v]+1; 3. 如果找到等长路:  count[w] = count[v] + 1;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-9 旅游规划 (25分)&lt;/p&gt;
&lt;p&gt;有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="Dijkstra" scheme="https://cjay.life/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>关键路径</title>
    <link href="https://cjay.life/2020/07/13/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <id>https://cjay.life/2020/07/13/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</id>
    <published>2020-07-13T13:28:14.000Z</published>
    <updated>2020-07-13T13:42:09.499Z</updated>
    
    <content type="html"><![CDATA[<p>AOE（Activity On Edge,与AOV区别）网络</p><p>计算整个工期就是 计算最早完成时间</p><p>机动时间： D&lt;i,j&gt; = Latest[j] - Earliest[i] - C&lt;i,j&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AOE（Activity On Edge,与AOV区别）网络&lt;/p&gt;
&lt;p&gt;计算整个工期就是 计算最早完成时间&lt;/p&gt;
&lt;p&gt;机动时间： D&amp;lt;i,j&amp;gt; = Latest[j] - Earliest[i] - C&amp;lt;i,j&amp;gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="关键路径" scheme="https://cjay.life/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://cjay.life/2020/07/13/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/13/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-13T10:58:20.000Z</published>
    <updated>2020-07-13T14:46:40.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拓扑序定义"><a href="#拓扑序定义" class="headerlink" title="拓扑序定义"></a>拓扑序定义</h1><p>如果图中从v到w有一条有向途径,则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。</p><p>获得一个拓扑序的过程就是拓扑排序</p><p>Activity On Vertex (AOV) 网络如果有合理的拓扑序，则必定是有向无环图（Directed Acylic Grapg,DAG）</p><h1 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void TopSort()&#123;</span><br><span class="line">for(cnt &#x3D; 0;cnt&lt;v;cnt++)&#123;</span><br><span class="line">v &#x3D; 未输出的入度为0的顶点；&#x2F;&#x2F;O(V)</span><br><span class="line">if(这样的v不存在)&#123;</span><br><span class="line">Error(“图中有回路”);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">输出v，或者记录v的输出序号;</span><br><span class="line">for(v的每个邻接点)</span><br><span class="line">Indegree[w]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(V2)</span><br></pre></td></tr></table></figure><h1 id="聪明的算法"><a href="#聪明的算法" class="headerlink" title="聪明的算法"></a>聪明的算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;随时将入度变为0的顶点放到一个容器里</span><br><span class="line">void TopSort()&#123;</span><br><span class="line">for(图中每个顶点 v)</span><br><span class="line">if(Indegree[v] &#x3D;&#x3D; 0)</span><br><span class="line">enqueue(v,q);</span><br><span class="line">while(!isempty(q))&#123;</span><br><span class="line">v &#x3D; dequeue(q);</span><br><span class="line">输出v,或者记录v的输出序号;cnt++</span><br><span class="line">for(v 的每个邻接点 w)</span><br><span class="line">if(--Indegree[W] &#x3D;&#x3D; 0)</span><br><span class="line">enqueue(W,Q);</span><br><span class="line">&#125;</span><br><span class="line">if( cnt !&#x3D; v)</span><br><span class="line">error(“图中有回路”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(V+E)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;拓扑序定义&quot;&gt;&lt;a href=&quot;#拓扑序定义&quot; class=&quot;headerlink&quot; title=&quot;拓扑序定义&quot;&gt;&lt;/a&gt;拓扑序定义&lt;/h1&gt;&lt;p&gt;如果图中从v到w有一条有向途径,则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。&lt;/p&gt;
&lt;p&gt;获得一个拓扑
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="拓扑排序" scheme="https://cjay.life/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树问题(Minimum Spanning Tree)</title>
    <link href="https://cjay.life/2020/07/13/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/"/>
    <id>https://cjay.life/2020/07/13/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-13T09:48:18.000Z</published>
    <updated>2020-07-13T13:16:13.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>最小生成树首先是一棵树</p><ol><li>无回路</li><li>V个顶点一定有V-1条边</li></ol><p>是生成树</p><ol><li>包含全部顶点</li><li>V-1条边都在图里</li></ol><p>边的权重和最小</p><h1 id="生成最小生成树的算法思想（贪心思想）"><a href="#生成最小生成树的算法思想（贪心思想）" class="headerlink" title="生成最小生成树的算法思想（贪心思想）"></a>生成最小生成树的算法思想（贪心思想）</h1><p>每一步都是选最好的（权重最小的边）</p><p>选择过程中的约束：</p><ol><li>只能用图里的边</li><li>只能一种选择v-1条边</li><li>不能有回路</li></ol><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>类似Dijikastra算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">v &#x3D; 未收录顶点中dist最小值;</span><br><span class="line">if(这样的v不存在)</span><br><span class="line">break;</span><br><span class="line">collected[v] &#x3D; true;</span><br><span class="line">for(v 的每个邻接点 w)&#123;</span><br><span class="line">if((collected[w] &#x3D;&#x3D; false) &amp;&amp; (dist[v] + E&lt;v,w&gt; &lt; dist[w]))&#123;</span><br><span class="line">dist[w] &#x3D; dist[v] + E[v,w]l</span><br><span class="line">path[w] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void Prim()&#123;</span><br><span class="line">MST &#x3D; &#123;s&#125;;</span><br><span class="line">while(1)&#123;</span><br><span class="line">v &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">if(这样v不存在)</span><br><span class="line">break;</span><br><span class="line">将v收录进MST: dist[v] &#x3D; 0;</span><br><span class="line">for(v 的每个邻接点 w)&#123;</span><br><span class="line">if(dist[w] !&#x3D; 0)&#123;</span><br><span class="line">if(E&lt;v,w&gt; &lt;dist[w])&#123;</span><br><span class="line">dist[w] &#x3D; E&lt;v,w&gt;;</span><br><span class="line">parent[W] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(MST中收的顶点不到V个)</span><br><span class="line">Error(“生成树不存在”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;dist[v] &#x3D; E&lt;s,v&gt; 或 正无穷</span><br><span class="line">&#x2F;&#x2F;parent[s] &#x3D; -1</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(v2) 稠密图合算</span><br></pre></td></tr></table></figure><h2 id="Kruskal算法（将森林合并成树）"><a href="#Kruskal算法（将森林合并成树）" class="headerlink" title="Kruskal算法（将森林合并成树）"></a>Kruskal算法（将森林合并成树）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Kruskal (Graph G)&#123;</span><br><span class="line">MST &#x3D; &#123;&#125;;</span><br><span class="line">while(MST中不到|V|-1条边 &amp;&amp; E中还有边)&#123;</span><br><span class="line">从E中取一条权重最小边 &#x2F;*最小堆*&#x2F;</span><br><span class="line">将E&lt;v,w&gt;从E中删除；</span><br><span class="line">if(E&lt;v,w&gt;不在MST中构成回路) &#x2F;*并查集*&#x2F;</span><br><span class="line"> E(V,W) 加入 MST;</span><br><span class="line">else</span><br><span class="line">彻底无视 E(V,W);</span><br><span class="line">&#125;</span><br><span class="line">if ( MST 中不到 |V|-1 条边 )</span><br><span class="line">Error ( “生成树不存在” );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(ElogE)</span><br></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 邻接矩阵存储 - Prim最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">Vertex FindMinDist( MGraph Graph, WeightType dist[] )</span><br><span class="line">&#123; &#x2F;* 返回未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">    Vertex MinV, V;</span><br><span class="line">    WeightType MinDist &#x3D; INFINITY;</span><br><span class="line"> </span><br><span class="line">    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        if ( dist[V]!&#x3D;0 &amp;&amp; dist[V]&lt;MinDist) &#123;</span><br><span class="line">            &#x2F;* 若V未被收录，且dist[V]更小 *&#x2F;</span><br><span class="line">            MinDist &#x3D; dist[V]; &#x2F;* 更新最小距离 *&#x2F;</span><br><span class="line">            MinV &#x3D; V; &#x2F;* 更新对应顶点 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (MinDist &lt; INFINITY) &#x2F;* 若找到最小dist *&#x2F;</span><br><span class="line">        return MinV; &#x2F;* 返回对应的顶点下标 *&#x2F;</span><br><span class="line">    else return ERROR;  &#x2F;* 若这样的顶点不存在，返回-1作为标记 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Prim( MGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType dist[MaxVertexNum], TotalWeight;</span><br><span class="line">    Vertex parent[MaxVertexNum], V, W;</span><br><span class="line">    int VCount;</span><br><span class="line">    Edge E;</span><br><span class="line">     </span><br><span class="line">    &#x2F;* 初始化。默认初始点下标是0 *&#x2F;</span><br><span class="line">       for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        &#x2F;* 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY *&#x2F;</span><br><span class="line">           dist[V] &#x3D; Graph-&gt;G[0][V];</span><br><span class="line">           parent[V] &#x3D; 0; &#x2F;* 暂且定义所有顶点的父结点都是初始点0 *&#x2F; </span><br><span class="line">    &#125;</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    VCount &#x3D; 0;      &#x2F;* 初始化收录的顶点数 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    E &#x3D; (Edge)malloc( sizeof(struct ENode) ); &#x2F;* 建立空的边结点 *&#x2F;</span><br><span class="line">            </span><br><span class="line">    &#x2F;* 将初始点0收录进MST *&#x2F;</span><br><span class="line">    dist[0] &#x3D; 0;</span><br><span class="line">    VCount ++;</span><br><span class="line">    parent[0] &#x3D; -1; &#x2F;* 当前树根是0 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    while (1) &#123;</span><br><span class="line">        V &#x3D; FindMinDist( Graph, dist );</span><br><span class="line">        &#x2F;* V &#x3D; 未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">        if ( V&#x3D;&#x3D;ERROR ) &#x2F;* 若这样的V不存在 *&#x2F;</span><br><span class="line">            break;   &#x2F;* 算法结束 *&#x2F;</span><br><span class="line">             </span><br><span class="line">        &#x2F;* 将V及相应的边&lt;parent[V], V&gt;收录进MST *&#x2F;</span><br><span class="line">        E-&gt;V1 &#x3D; parent[V];</span><br><span class="line">        E-&gt;V2 &#x3D; V;</span><br><span class="line">        E-&gt;Weight &#x3D; dist[V];</span><br><span class="line">        InsertEdge( MST, E );</span><br><span class="line">        TotalWeight +&#x3D; dist[V];</span><br><span class="line">        dist[V] &#x3D; 0;</span><br><span class="line">        VCount++;</span><br><span class="line">         </span><br><span class="line">        for( W&#x3D;0; W&lt;Graph-&gt;Nv; W++ ) &#x2F;* 对图中的每个顶点W *&#x2F;</span><br><span class="line">            if ( dist[W]!&#x3D;0 &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;</span><br><span class="line">            &#x2F;* 若W是V的邻接点并且未被收录 *&#x2F;</span><br><span class="line">                if ( Graph-&gt;G[V][W] &lt; dist[W] ) &#123;</span><br><span class="line">                &#x2F;* 若收录V使得dist[W]变小 *&#x2F;</span><br><span class="line">                    dist[W] &#x3D; Graph-&gt;G[V][W]; &#x2F;* 更新dist[W] *&#x2F;</span><br><span class="line">                    parent[W] &#x3D; V; &#x2F;* 更新树 *&#x2F;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; &#x2F;* while结束*&#x2F;</span><br><span class="line">    if ( VCount &lt; Graph-&gt;Nv ) &#x2F;* MST中收的顶点不到|V|个 *&#x2F;</span><br><span class="line">       TotalWeight &#x3D; ERROR;</span><br><span class="line">    return TotalWeight;   &#x2F;* 算法执行完毕，返回最小权重和或错误标记 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 邻接表存储 - Kruskal最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 顶点并查集定义 --------------------*&#x2F;</span><br><span class="line">typedef Vertex ElementType; &#x2F;* 默认元素可以用非负整数表示 *&#x2F;</span><br><span class="line">typedef Vertex SetName;     &#x2F;* 默认用根结点的下标作为集合名称 *&#x2F;</span><br><span class="line">typedef ElementType SetType[MaxVertexNum]; &#x2F;* 假设集合元素下标从0开始 *&#x2F;</span><br><span class="line"> </span><br><span class="line">void InitializeVSet( SetType S, int N )</span><br><span class="line">&#123; &#x2F;* 初始化并查集 *&#x2F;</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    for ( X&#x3D;0; X&lt;N; X++ ) S[X] &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Union( SetType S, SetName Root1, SetName Root2 )</span><br><span class="line">&#123; &#x2F;* 这里默认Root1和Root2是不同集合的根结点 *&#x2F;</span><br><span class="line">    &#x2F;* 保证小集合并入大集合 *&#x2F;</span><br><span class="line">    if ( S[Root2] &lt; S[Root1] ) &#123; &#x2F;* 如果集合2比较大 *&#x2F;</span><br><span class="line">        S[Root2] +&#x3D; S[Root1];     &#x2F;* 集合1并入集合2  *&#x2F;</span><br><span class="line">        S[Root1] &#x3D; Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;                         &#x2F;* 如果集合1比较大 *&#x2F;</span><br><span class="line">        S[Root1] +&#x3D; S[Root2];     &#x2F;* 集合2并入集合1  *&#x2F;</span><br><span class="line">        S[Root2] &#x3D; Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SetName Find( SetType S, ElementType X )</span><br><span class="line">&#123; &#x2F;* 默认集合元素全部初始化为-1 *&#x2F;</span><br><span class="line">    if ( S[X] &lt; 0 ) &#x2F;* 找到集合的根 *&#x2F;</span><br><span class="line">        return X;</span><br><span class="line">    else</span><br><span class="line">        return S[X] &#x3D; Find( S, S[X] ); &#x2F;* 路径压缩 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )</span><br><span class="line">&#123; &#x2F;* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 *&#x2F;</span><br><span class="line">    Vertex Root1, Root2;</span><br><span class="line"> </span><br><span class="line">    Root1 &#x3D; Find( VSet, V1 ); &#x2F;* 得到V1所属的连通集名称 *&#x2F;</span><br><span class="line">    Root2 &#x3D; Find( VSet, V2 ); &#x2F;* 得到V2所属的连通集名称 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    if( Root1&#x3D;&#x3D;Root2 ) &#x2F;* 若V1和V2已经连通，则该边不能要 *&#x2F;</span><br><span class="line">        return false;</span><br><span class="line">    else &#123; &#x2F;* 否则该边可以被收集，同时将V1和V2并入同一连通集 *&#x2F;</span><br><span class="line">        Union( VSet, Root1, Root2 );</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 并查集定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 边的最小堆定义 --------------------*&#x2F;</span><br><span class="line">void PercDown( Edge ESet, int p, int N )</span><br><span class="line">&#123; &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p )    *&#x2F;</span><br><span class="line">  &#x2F;* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 *&#x2F;</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    struct ENode X;</span><br><span class="line"> </span><br><span class="line">    X &#x3D; ESet[p]; &#x2F;* 取出根结点存放的值 *&#x2F;</span><br><span class="line">    for( Parent&#x3D;p; (Parent*2+1)&lt;N; Parent&#x3D;Child ) &#123;</span><br><span class="line">        Child &#x3D; Parent * 2 + 1;</span><br><span class="line">        if( (Child!&#x3D;N-1) &amp;&amp; (ESet[Child].Weight&gt;ESet[Child+1].Weight) )</span><br><span class="line">            Child++;  &#x2F;* Child指向左右子结点的较小者 *&#x2F;</span><br><span class="line">        if( X.Weight &lt;&#x3D; ESet[Child].Weight ) break; &#x2F;* 找到了合适位置 *&#x2F;</span><br><span class="line">        else  &#x2F;* 下滤X *&#x2F;</span><br><span class="line">            ESet[Parent] &#x3D; ESet[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    ESet[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void InitializeESet( LGraph Graph, Edge ESet )</span><br><span class="line">&#123; &#x2F;* 将图的边存入数组ESet，并且初始化为最小堆 *&#x2F;</span><br><span class="line">    Vertex V;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    int ECount;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将图的边存入数组ESet *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;</span><br><span class="line">    for ( V&#x3D;0; V&lt;Graph-&gt;Nv; V++ )</span><br><span class="line">        for ( W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next )</span><br><span class="line">            if ( V &lt; W-&gt;AdjV ) &#123; &#x2F;* 避免重复录入无向图的边，只收V1&lt;V2的边 *&#x2F;</span><br><span class="line">                ESet[ECount].V1 &#x3D; V;</span><br><span class="line">                ESet[ECount].V2 &#x3D; W-&gt;AdjV;</span><br><span class="line">                ESet[ECount++].Weight &#x3D; W-&gt;Weight;</span><br><span class="line">            &#125;</span><br><span class="line">    &#x2F;* 初始化为最小堆 *&#x2F;</span><br><span class="line">    for ( ECount&#x3D;Graph-&gt;Ne&#x2F;2; ECount&gt;&#x3D;0; ECount-- )</span><br><span class="line">        PercDown( ESet, ECount, Graph-&gt;Ne );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int GetEdge( Edge ESet, int CurrentSize )</span><br><span class="line">&#123; &#x2F;* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将最小边与当前堆的最后一个位置的边交换 *&#x2F;</span><br><span class="line">    Swap( &amp;ESet[0], &amp;ESet[CurrentSize-1]);</span><br><span class="line">    &#x2F;* 将剩下的边继续调整成最小堆 *&#x2F;</span><br><span class="line">    PercDown( ESet, 0, CurrentSize-1 );</span><br><span class="line"> </span><br><span class="line">    return CurrentSize-1; &#x2F;* 返回最小边所在位置 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 最小堆定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int Kruskal( LGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType TotalWeight;</span><br><span class="line">    int ECount, NextEdge;</span><br><span class="line">    SetType VSet; &#x2F;* 顶点数组 *&#x2F;</span><br><span class="line">    Edge ESet;    &#x2F;* 边数组 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    InitializeVSet( VSet, Graph-&gt;Nv ); &#x2F;* 初始化顶点并查集 *&#x2F;</span><br><span class="line">    ESet &#x3D; (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne );</span><br><span class="line">    InitializeESet( Graph, ESet ); &#x2F;* 初始化边的最小堆 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;      &#x2F;* 初始化收录的边数 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    NextEdge &#x3D; Graph-&gt;Ne; &#x2F;* 原始边集的规模 *&#x2F;</span><br><span class="line">    while ( ECount &lt; Graph-&gt;Nv-1 ) &#123;  &#x2F;* 当收集的边不足以构成树时 *&#x2F;</span><br><span class="line">        NextEdge &#x3D; GetEdge( ESet, NextEdge ); &#x2F;* 从边集中得到最小边的位置 *&#x2F;</span><br><span class="line">        if (NextEdge &lt; 0) &#x2F;* 边集已空 *&#x2F;</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;* 如果该边的加入不构成回路，即两端结点不属于同一连通集 *&#x2F;</span><br><span class="line">        if ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )&#x3D;&#x3D;true ) &#123;</span><br><span class="line">            &#x2F;* 将该边插入MST *&#x2F;</span><br><span class="line">            InsertEdge( MST, ESet+NextEdge );</span><br><span class="line">            TotalWeight +&#x3D; ESet[NextEdge].Weight; &#x2F;* 累计权重 *&#x2F;</span><br><span class="line">            ECount++; &#x2F;* 生成树中边数加1 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( ECount &lt; Graph-&gt;Nv-1 )</span><br><span class="line">        TotalWeight &#x3D; -1; &#x2F;* 设置错误标记，表示生成树不存在 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    return TotalWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;最小生成树首先是一棵树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无回路&lt;/li&gt;
&lt;li&gt;V个顶点一定有V-1条边&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;是生成树&lt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最小生成树" scheme="https://cjay.life/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈利·波特的考试</title>
    <link href="https://cjay.life/2020/07/13/%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/"/>
    <id>https://cjay.life/2020/07/13/%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/</id>
    <published>2020-07-13T09:06:16.000Z</published>
    <updated>2020-07-13T09:09:36.107Z</updated>
    
    <content type="html"><![CDATA[<p>7-8 哈利·波特的考试 (25分)</p><p>哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。</p><p>现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入第1行给出两个正整数<em>N</em> (≤100)和<em>M</em>，其中<em>N</em>是考试涉及的动物总数，<em>M</em>是用于直接变形的魔咒条数。为简单起见，我们将动物按1~<em>N</em>编号。随后<em>M</em>行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">6 11</span><br><span class="line">3 4 70</span><br><span class="line">1 2 1</span><br><span class="line">5 4 50</span><br><span class="line">2 6 50</span><br><span class="line">5 6 60</span><br><span class="line">1 3 70</span><br><span class="line">4 6 60</span><br><span class="line">3 6 80</span><br><span class="line">5 1 100</span><br><span class="line">2 4 60</span><br><span class="line">5 2 80</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 70</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int D[105][105];</span><br><span class="line">int N,M;</span><br><span class="line">int t1,t2,t3;</span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">if(i!&#x3D;j)</span><br><span class="line">D[i][j] &#x3D; 65535; &#x2F;&#x2F;floyd算法要求无边就初始化为正无穷</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void floyd()&#123;</span><br><span class="line">for(int k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(D[i][k]+D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">D[i][j] &#x3D; D[i][k]+D[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int FindMaxDist(int i)&#123;</span><br><span class="line">int maxdist &#x3D; 0;</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(i!&#x3D;j &amp;&amp; D[i][j]&gt;maxdist)</span><br><span class="line">maxdist &#x3D; D[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;maxdist&lt;&lt;&#39;\n&#39;; </span><br><span class="line">return maxdist;</span><br><span class="line">&#125;</span><br><span class="line">void FindMinDist()&#123;</span><br><span class="line">int mindist &#x3D; 65535;</span><br><span class="line">int animal;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">int maxdist &#x3D; FindMaxDist(i);</span><br><span class="line">if(maxdist &#x3D;&#x3D; 65535)&#123;</span><br><span class="line">printf(&quot;0\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(mindist&gt;maxdist)&#123;</span><br><span class="line">mindist &#x3D; maxdist;</span><br><span class="line">animal &#x3D; i+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d %d\n&quot;,animal,mindist);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">reset();</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;</span><br><span class="line">D[t1-1][t2-1] &#x3D; t3;&#x2F;&#x2F;位置偏移</span><br><span class="line">D[t2-1][t1-1] &#x3D; t3;</span><br><span class="line">&#125;</span><br><span class="line">floyd();</span><br><span class="line">&#x2F;&#x2F;for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">&#x2F;&#x2F;for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;D[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">FindMinDist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-8 哈利·波特的考试 (25分)&lt;/p&gt;
&lt;p&gt;哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最短路径，floyd" scheme="https://cjay.life/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%8Cfloyd/"/>
    
  </entry>
  
  <entry>
    <title>最短路径问题</title>
    <link href="https://cjay.life/2020/07/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>https://cjay.life/2020/07/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-10T12:25:18.000Z</published>
    <updated>2020-07-13T09:09:50.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径问题的抽象"><a href="#最短路径问题的抽象" class="headerlink" title="最短路径问题的抽象"></a>最短路径问题的抽象</h1><p>最短路径就是源点（Source）和终点（Destination）之间权值之和最小的一条路径</p><h1 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h1><ol><li>单元最短路径问题：一点到其他顶点的最短路径<ol><li>（有向）无权图</li><li>（有向）有权图</li></ol></li><li>多源最短路径问题：任意两点之间的最短路径</li></ol><h1 id="无权图的单源最短路算法"><a href="#无权图的单源最短路算法" class="headerlink" title="无权图的单源最短路算法"></a>无权图的单源最短路算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;本质就是BFS的变型</span><br><span class="line">&#x2F;&#x2F;dist[w] &#x3D; S到W的最短距离</span><br><span class="line">&#x2F;&#x2F;dist[S] &#x3D; 0</span><br><span class="line">&#x2F;&#x2F;path[W] &#x3D; S到W的路上经过的某顶点（确切说是上个顶点）</span><br><span class="line">void Unweighted(Vertex S)&#123;</span><br><span class="line">Enqueue(S,Q);</span><br><span class="line">while(!IsEpmty(Q)))&#123;</span><br><span class="line">v &#x3D; Dequeue(Q);</span><br><span class="line">for(V 的每个邻接点 W)&#123;</span><br><span class="line">if(dist[W] &#x3D;&#x3D; -1)&#123;</span><br><span class="line">dist[W] &#x3D; dist[V]+1;</span><br><span class="line">path[W] &#x3D; V;</span><br><span class="line">enqueue(W,Q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有权图的单源最短路算法"><a href="#有权图的单源最短路算法" class="headerlink" title="有权图的单源最短路算法"></a>有权图的单源最短路算法</h1><p><strong><em>Dijkstra算法(按照递增的顺序找到各个顶点的最短路)</em></strong></p><p><strong>前提是不存在负值圈</strong></p><ol><li>令S={源点s + 已经确定了最短路径的顶点vi}</li><li>对不属于集合S的顶点v，定义dist[v]为s到v的最短路径长度，但该路径<em>仅仅经过S中的顶点。</em>即路径{s-&gt;(vi∈S)-&gt;v}的长度</li><li>若路径是按照递增的顺序生成的，则<ol><li>真正的最短路必须只经过S中的顶点（反证法：若存在另外一个结点，那也应该是这一个结点先被收录）</li><li>每次从未收录的顶点中选一个dist最小的收录（贪心）</li><li>增加一个v进入S，可能影响另外一个w的dist值（min{dist[w], dist[v] + &lt;v,w&gt;的权重}）</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">V &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">if(这样v不存在)</span><br><span class="line">break;</span><br><span class="line">collected[v] &#x3D; true;</span><br><span class="line">for(v 的每个邻接点 W)</span><br><span class="line">if(collected[W] &#x3D;&#x3D; false)&#123;</span><br><span class="line">if(dist[v]+E&lt;v,w&gt; &lt; dist[W])&#123;</span><br><span class="line">dist[W] &#x3D; dist[V] + E&lt;v,w&gt;;</span><br><span class="line">path[W] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若将dist的值存在数组和堆中会产生不同的效果：</p><ol><li>数组中 T=O（V2 + E）适合稠密图</li><li>最小堆中<ol><li>更新dist[w] = O(logv)</li><li>T = O(VlogV + ElogV) = O(Elogv) 适合稀疏图</li></ol></li></ol><h1 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h1><ol><li>直接将单元最短路径算法调用V遍 T = O（V3 + E*V）</li><li>Floyd算法 T = O（V3）</li></ol><p>Floyd 算法 </p><ol><li>Dk[i][j] = 路径{i -&gt; {l&lt;=k} -&gt; j}的最小长度</li><li>D0,D1,…,DV-1[i][j]即给出了i到j的真正最短距离</li><li>最初的D-1（如果ij没边，初始化为正无穷）</li><li>Dk-1已经完成，递推到Dk时：<ol><li>或者k不∈最短路径{i-&gt;{l&lt;=k}-&gt;j},则Dk = Dk-1</li><li>或者k∈最短路径,则该路径由两端最短路径组成：Dk[i][j] = Dk-1[i][k] + Dk-1[k][j]</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Floyd()&#123;</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line"> for(j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line"> D[i][j] &#x3D; G[i][j];</span><br><span class="line"> path[i][j] &#x3D; -1;&#x2F;&#x2F;用来打印路径用</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">for(j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(D[i][k]+ D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">D[i][j] &#x3D; D[i][k] + D[k][j];</span><br><span class="line">path[i][j] &#x3D; k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径问题的抽象&quot;&gt;&lt;a href=&quot;#最短路径问题的抽象&quot; class=&quot;headerlink&quot; title=&quot;最短路径问题的抽象&quot;&gt;&lt;/a&gt;最短路径问题的抽象&lt;/h1&gt;&lt;p&gt;最短路径就是源点（Source）和终点（Destination）之间权值之和最小的一
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最短路径" scheme="https://cjay.life/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
</feed>
