<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CJ&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cjay.life/"/>
  <updated>2020-07-17T15:40:37.088Z</updated>
  <id>https://cjay.life/</id>
  
  <author>
    <name>CJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>csapp第一章：计算机系统漫游</title>
    <link href="https://cjay.life/2020/07/17/csapp%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <id>https://cjay.life/2020/07/17/csapp%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</id>
    <published>2020-07-17T04:23:05.000Z</published>
    <updated>2020-07-17T15:40:37.088Z</updated>
    
    <content type="html"><![CDATA[<p>本书第一章开头通过跟踪hello程序的生命周期对系统进行学习</p><h1 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h1><p>Hello程序在一开始仅仅只是由编辑器创建的文本文件。这些文本文件在本质上都只是比特序列。</p><p><strong>比特序列是如何表示成文本字符？</strong></p><p><strong>这里采用编码标准，标准有很多，这里已ASCII标准为例：ASCII标准将这些最原始的比特序列，分成以字节（8个bit）为单位来表示每个字符。相当于y = f(x),y是文本字符，x是一个字节的bit串，函数f()是ASCII标准，该函数一一映射</strong></p><p><img src="https://img2018.cnblogs.com/blog/1334023/201906/1334023-20190625084643603-1395767889.png" alt></p><p><strong>注意：文本中，每个文本行都有看不见的换行符’\n’，对应整数10</strong></p><p>所以在计算机中，比特序列是通过<strong>读到数据对象时的上下文</strong>来区分不同的数据对象</p><h1 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h1><p>源程序到目标程序（也称为可执行目标文件）转变过程如下：</p><p><img src="https://nullcc.github.io/assets/images/post_imgs/compilation_system.png" alt></p><ul><li>预处理阶段：修改原始C程序，比如将#include&lt;stdio.h&gt;中的stdio.h的内容直接插入程序文本中。最后将扩展名改为.i</li><li>编译阶段：通过编译器，转成了汇编语言程序。</li><li>汇编阶段：通过汇编器，转成了机器语言指令，把这些指令打包成可重定位目标程序（relocatable object program）的格式，保存到hello.o中</li><li>链接阶段：hello程序中调用了printf函数，该阶段就是将hello.o与printf.o以某种方式合并起来</li></ul><h1 id="1-4-处理器读并解释存在内存中的指令"><a href="#1-4-处理器读并解释存在内存中的指令" class="headerlink" title="1.4 处理器读并解释存在内存中的指令"></a>1.4 处理器读并解释存在内存中的指令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; .&#x2F;hello</span><br><span class="line">hello,world</span><br><span class="line">linux&gt;</span><br></pre></td></tr></table></figure><p>上图是通过shell（命令行解释器）运行了hello程序。</p><h2 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h2><ol><li>总线：总线被设计成传送定长的字节快，也就是字（word）。字长是系统的一个基本参数，每个系统中都不尽相同。大多数系统中要不32位要不64位。</li><li>I/O设备：每个I/O设备都通过一个控制器或适配器与I/O总线相连。<ul><li>控制器是I/O设备本身或系统的电路板上的芯片组</li><li>适配器是插在主板卡槽上的卡</li></ul></li><li>主存：由一组动态随机存取存储器（DRAM）芯片组成的。</li><li>处理器：是届时或执行存储在内存中指令的引擎。存储器核心是一个大小为一个字的寄存器，称为程序计数器PC，用于指向内存中某条机器语言指令。</li></ol><h2 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h2><p>初始时，shell程序执行它的指令，等待我们输入一个命令。当在键盘上输入“./hello”后，shell程序将字符逐一读入寄存器，再把它放到内存中</p><p><img src="https://img2018.cnblogs.com/blog/1334023/201906/1334023-20190626182409229-914940200.png" alt></p><p>当输入回车，shell知道我们结束了命令的输入。然后shell执行一系列指令加载并执行hello文件，将这个文件复制到主存。</p><p><img src="https://img2018.cnblogs.com/blog/1334023/201906/1334023-20190626182731361-479664359.png" alt></p><p>处理器就开始执行这些机器语言指令。“Hello world”字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备。</p><p><img src="https://img2018.cnblogs.com/blog/1334023/201906/1334023-20190626184237882-1227164304.png" alt></p><h2 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h2><p>高速缓存通过静态随机访问存储器（SRAM）的硬件技术实现。</p><h2 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h2><p>主要思想是上一层的存储器作为第一层存储器的高速缓存。</p><h2 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h2><p>shell与hello程序都没有直接访问硬件，取而代之是由操作系统提供服务。</p><p>操作系统两个基本功能：</p><ol><li>防止硬件被应用程序滥用</li><li>向应用程序提供简单的机制来控制硬件设备</li></ol><p>操作系统主要采用几个抽象概念来实现上面两个功能：</p><ol><li>文件对I/O设备的抽象表示</li><li>虚拟内存对主存和磁盘I/O设备的抽象表示</li><li>进程则是对处理器、主存和I/O设备的抽象表示</li></ol><p><img src="https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/5tpq2.jpg" alt></p><h2 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h2><p>进程是操作系统对一个正在运行的程序一种抽象。有了这种抽象，一个系统上可以并发多个进程。这种并发执行，通过处理器来进程间切换来实现的。操作系统实行这种交错执行的机制称为<strong>上下文切换</strong>。</p><p><strong>上下文是指操作系统跟踪进程运行所需要的状态信息，比如PC和寄存器的当前值，以及主存的内容</strong></p><p>上下文切换其实就是保存当前进程的上下文，恢复新进程的上下文，然后将控制区传递给新进程。</p><p>对于两个并发进程：shell进程和hello进程。刚开始shell进程在运行，即等待命令行输入。</p><p>当运行hello程序，shell系统调用-》系统调用将控制权从shell到给操作系统-》操作系统保存shell进程上下文-》创建hello进程上下文并将控制权给hello进程-》hello进程终止-》操作系统恢复shell上下文，并将控制区给shell</p><p><img src="https://images2017.cnblogs.com/blog/997599/201709/997599-20170917182301157-2005157989.png" alt></p><h2 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h2><p>现代操作系统中，进程由多个线程的执行单元构成，每个线程运行在进程上下文中，享有同样的代码与数据。</p><h2 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h2><p>虚拟内存是一种抽象概念，给进程提供一种假象，即每个进程都在独占使用主存。每个进程看到都是虚拟地址空间</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jenItbGVhcm4ub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tL1JOTi8xLjEzJTIwJUU4JUJGJTlCJUU3JUE4JThCJUU3JTlBJTg0JUU4JTk5JTlBJUU2JThCJTlGJUU1JTlDJUIwJUU1JTlEJTgwJUU3JUE5JUJBJUU5JTk3JUI0LnBuZw?x-oss-process=image/format,png" alt="Linux进程的虚拟地址空间"></p><p>最低地址开始，从上介绍。</p><ul><li>程序代码和数据：先是代码，接着是数据。</li><li>堆：代码与数据在进程开始运行时就被指定了大小。但调用像malloc和free这样C标准库函数时，堆在运行时动态扩展与搜索。</li><li>共享库：用来存放C标准库和数学库这样的共享库的代码和数据区域。</li><li>栈：编译器用它实现函数调用，调用一个函数，栈增长，一个函数返回时，栈就会收缩。也可以动态扩展和收缩。</li><li>内核虚拟内存：为内核保留</li></ul><p>虚拟内存的运作需要<strong>硬件和操作系统之间交互，包括堆处理器生成的每个地址的硬件翻译</strong></p><p>基本思想是进程虚拟内存的内容存在磁盘上，用主存作为磁盘的高速缓存。</p><h2 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h2><p>文件本质是字节序列。但它向应用程序提供了一个统一的视图来看待各式各样的I/O设备。</p><h1 id="1-8-系统之间的网络通信"><a href="#1-8-系统之间的网络通信" class="headerlink" title="1.8 系统之间的网络通信"></a>1.8 系统之间的网络通信</h1><p>系统从主存复制一串字到网络适配器时，数据流过网络到达另一台机器。同时，系统也可以从读取其他机器发送过来的数据，并复制到主存。</p><p><img src="https://img2018.cnblogs.com/blog/1526080/201811/1526080-20181129202305045-102973742.png" alt></p><h1 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h1><h2 id="1-9-1-Amdahl定律"><a href="#1-9-1-Amdahl定律" class="headerlink" title="1.9.1 Amdahl定律"></a>1.9.1 Amdahl定律</h2><p>若系统执行某应用程序需要时间Told。假设其中某部分与整体时间的比例为a。</p><p>若该部分性能提升k。则新的执行时间为：<strong>Tnew = (1-a)Told+（aTold）/k = Told[(1-a)+a/k]</strong></p><p>加速比 <strong>S = Told/Tnew = 1/[(1-a)+a/k];</strong></p><p><strong>若k-&gt;∞，则S = 1/（1-a）</strong>，说明想要高的加速比只有通过优化系统大部分组件才行。</p><h2 id="1-9-2-并发（concurrency）与并行-parallelism"><a href="#1-9-2-并发（concurrency）与并行-parallelism" class="headerlink" title="1.9.2 并发（concurrency）与并行(parallelism)"></a>1.9.2 并发（concurrency）与并行(parallelism)</h2><ol><li>线程级并发：使用线程可以在一个进程中执行多个控制流。想要实现线程级的并发，可以采用以下两个技术<ol><li>多核处理器：将多个CPU集成到一个集成电路芯片上。<img src="https://img2018.cnblogs.com/blog/1334023/201906/1334023-20190629151543016-1999642658.png" alt></li><li>超线程（hyperthreading）或称为同时多线程(simultaneous multi-threading)，允许一个CPU通过执行多个CPU。说是一个CPU，其实CPU里的某些硬件变成了多份，比如程序计数器和寄存器文件。平常线程切换大约需要20000个周期，而采用超线程技术后，只要一个周期。</li></ol></li><li>指令集并行：在较低抽象层次上，现代处理器可以同时执行多条指令。采用流水线(Pipelining),将一条指令分成不同步骤，将硬件组织分成一系列阶段。硬件不同部分来处理指令的不同部分。能够达到接近于一个时钟周期的执行效率。而超标量（super-scalar）处理器速度更快。</li><li>单指令、多数据并行(SIMD):允许一条指令产生多个可以并行的操作。</li></ol><h2 id="1-9-3-计算机系统中抽象的重要性"><a href="#1-9-3-计算机系统中抽象的重要性" class="headerlink" title="1.9.3 计算机系统中抽象的重要性"></a>1.9.3 计算机系统中抽象的重要性</h2><p>例如为一组函数规定简单的应用程序接口（API），使程序员无需了解它内部的工作便可使用。</p><p>指令集架构就是提供了堆实际处理器硬件的抽象。使用这个抽象，机器代码程序好像运行在一个一次只执行一次指令的处理器上。</p><p><img src="https://img2018.cnblogs.com/blog/1526080/201811/1526080-20181129202927009-1202675019.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本书第一章开头通过跟踪hello程序的生命周期对系统进行学习&lt;/p&gt;
&lt;h1 id=&quot;1-1-信息就是位-上下文&quot;&gt;&lt;a href=&quot;#1-1-信息就是位-上下文&quot; class=&quot;headerlink&quot; title=&quot;1.1 信息就是位+上下文&quot;&gt;&lt;/a&gt;1.1 信息就是位
      
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>csapp</title>
    <link href="https://cjay.life/2020/07/17/csapp/"/>
    <id>https://cjay.life/2020/07/17/csapp/</id>
    <published>2020-07-17T04:13:29.000Z</published>
    <updated>2020-07-17T15:41:21.204Z</updated>
    
    <content type="html"><![CDATA[<p>计划:阅读CSAPP和看对应CMU课程，看完后，总结笔记。</p><hr><p>该篇blog用于记录实施进度。</p><p>2020.7.17    1-20页</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计划:阅读CSAPP和看对应CMU课程，看完后，总结笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;该篇blog用于记录实施进度。&lt;/p&gt;
&lt;p&gt;2020.7.17    1-20页&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="计划" scheme="https://cjay.life/categories/%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="计划" scheme="https://cjay.life/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>简单排序</title>
    <link href="https://cjay.life/2020/07/16/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/16/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-16T14:41:31.000Z</published>
    <updated>2020-07-16T15:20:59.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Bubble_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">for(p &#x3D; N-1;p&gt;&#x3D;0;p--)&#123;</span><br><span class="line">flag &#x3D; 0;</span><br><span class="line">for(i &#x3D; 0;i&lt;p;i++)&#123;&#x2F;&#x2F;一趟冒泡</span><br><span class="line">if(A[i]&gt;A[i+1])&#123;</span><br><span class="line">Swap(A[i],A[i+1]);</span><br><span class="line">flag &#x3D; 1;&#x2F;&#x2F;标识发生了交换</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag &#x3D;&#x3D; 0) break;&#x2F;&#x2F;全程无交换</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：顺序T=O（N）</p><p>最欢情况：逆序T=O（N2）</p><p>稳定，也可以应用于链表</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Insertion_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">for(p &#x3D; 1;p&lt;N;p++)&#123;</span><br><span class="line">Tmp &#x3D; A[p];</span><br><span class="line">for(i &#x3D; p;i&gt;&#x3D;0&amp;&amp;tmp&lt;A[i-1];i--)</span><br><span class="line">A[i] &#x3D; A[i-1];</span><br><span class="line">A[i] &#x3D; Tmp;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：顺序T=O（N）；</p><p>最坏情况: 逆序T=O(N2);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>cmu csapp lecture 02 Bits,Bytes,and Integer</title>
    <link href="https://cjay.life/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/"/>
    <id>https://cjay.life/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/</id>
    <published>2020-07-15T10:42:43.000Z</published>
    <updated>2020-07-17T07:18:05.230Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/02-03-bits-ints.pdf" target="_blank" rel="noopener">讲义地址</a></p><h1 id="Representing-amp-Manipulating-Sets"><a href="#Representing-amp-Manipulating-Sets" class="headerlink" title="Representing &amp; Manipulating Sets"></a>Representing &amp; Manipulating Sets</h1><h2 id="Representing"><a href="#Representing" class="headerlink" title="Representing"></a>Representing</h2><p>01101001{0,3,5,6}</p><p>01010101{0,2,4,6}</p><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><p>&amp; Intersection {0,6}</p><p>|  Union            {0,2,3,4,5,6}</p><p>^  Symmetric difference {2,3,4,5}</p><p>~ Complement {1,3,5,7}</p><p>上面的布尔代数运算，是从集合的角度来看。</p><p>watch out for &amp;&amp; vs &amp;(and || vs |)..(Bit-level Operations and logic Operations)</p><h1 id="shift-Operations"><a href="#shift-Operations" class="headerlink" title="shift Operations"></a>shift Operations</h1><h2 id="Left-Shift-x-lt-lt-y"><a href="#Left-Shift-x-lt-lt-y" class="headerlink" title="Left Shift : x &lt;&lt; y"></a>Left Shift : x &lt;&lt; y</h2><h2 id="Right-Shift-x-gt-gt-y"><a href="#Right-Shift-x-gt-gt-y" class="headerlink" title="Right Shift: x&gt;&gt;y"></a>Right Shift: x&gt;&gt;y</h2><h3 id="Logical-shift-Fill-with-0’s-on-left"><a href="#Logical-shift-Fill-with-0’s-on-left" class="headerlink" title="Logical shift:Fill with 0’s on left"></a>Logical shift:Fill with 0’s on left</h3><h3 id="Arithmetic-shift-Replicate-most-significant-bit-on-letf"><a href="#Arithmetic-shift-Replicate-most-significant-bit-on-letf" class="headerlink" title="Arithmetic shift: Replicate most significant bit on letf"></a>Arithmetic shift: Replicate most significant bit on letf</h3><h1 id="Conversion-Visualized"><a href="#Conversion-Visualized" class="headerlink" title="Conversion Visualized"></a>Conversion Visualized</h1><p><img src="/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/1.png" alt="Conversion"></p><h1 id="Casting-Suprises"><a href="#Casting-Suprises" class="headerlink" title="Casting Suprises"></a>Casting Suprises</h1><p>在单一表达式中混有有符号数和无符号数，有符号数会转换成无符号数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/02-03-bits-ints.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;讲义地址&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>三点心得</title>
    <link href="https://cjay.life/2020/07/14/%E4%B8%89%E7%82%B9%E5%BF%83%E5%BE%97/"/>
    <id>https://cjay.life/2020/07/14/%E4%B8%89%E7%82%B9%E5%BF%83%E5%BE%97/</id>
    <published>2020-07-14T09:42:12.000Z</published>
    <updated>2020-07-14T09:44:11.049Z</updated>
    
    <content type="html"><![CDATA[<ol><li>当脑海中浮现不开心的事情后，想开心的事情。</li><li>每次结束前，尽量克服难关。</li><li>趁热打铁</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;当脑海中浮现不开心的事情后，想开心的事情。&lt;/li&gt;
&lt;li&gt;每次结束前，尽量克服难关。&lt;/li&gt;
&lt;li&gt;趁热打铁&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="技巧" scheme="https://cjay.life/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="https://cjay.life/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>旅游规划</title>
    <link href="https://cjay.life/2020/07/13/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/"/>
    <id>https://cjay.life/2020/07/13/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/</id>
    <published>2020-07-13T14:46:14.000Z</published>
    <updated>2020-07-13T14:55:02.274Z</updated>
    
    <content type="html"><![CDATA[<p>7-9 旅游规划 (25分)</p><p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入数据的第1行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0~(<em>N</em>−1)；<em>M</em>是高速公路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。随后的<em>M</em>行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 40</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,S,D;</span><br><span class="line">int visited[505];</span><br><span class="line">int cost[505];</span><br><span class="line">int dist[505];</span><br><span class="line">int costs[505][505];</span><br><span class="line">int graph[505][505];</span><br><span class="line">int t1,t2,t3,t4;</span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;505;i++)&#123;</span><br><span class="line">for(int j &#x3D; 0;j&lt;505;j++)&#123;</span><br><span class="line">if(i!&#x3D;j)&#123;</span><br><span class="line">costs[i][j] &#x3D; 65535;</span><br><span class="line">graph[i][j] &#x3D; 65535;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Dijkstra(int s)&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;&#x2F;&#x2F;初始化</span><br><span class="line">cost[i] &#x3D; costs[s][i];</span><br><span class="line">dist[i] &#x3D; graph[s][i];</span><br><span class="line">&#125;</span><br><span class="line">while(1)&#123;</span><br><span class="line">int min &#x3D; 65535;</span><br><span class="line">int v &#x3D; -1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((i!&#x3D;s)&amp;&amp;(visited[i] &#x3D;&#x3D; 0)&amp;&amp;(graph[s][i]&lt;min))&#123;</span><br><span class="line">v &#x3D; i;</span><br><span class="line">min &#x3D; graph[s][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(v &#x3D;&#x3D; -1) break;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((visited[i] &#x3D;&#x3D; 0)&amp;&amp;(dist[v]+graph[v][i]&lt;dist[i]))&#123;</span><br><span class="line">dist[i] &#x3D; dist[v] + graph[v][i];</span><br><span class="line">cost[i] &#x3D; cost[v]+costs[v][i];</span><br><span class="line">&#125;else if((dist[v]+graph[v][i] &#x3D;&#x3D; dist[i])&amp;&amp;(cost[v]+costs[v][i]&lt;cost[i]))&#123;</span><br><span class="line">cost[i] &#x3D; cost[v] + costs[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;D;</span><br><span class="line">reset();&#x2F;&#x2F;初始化</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3&gt;&gt;t4;</span><br><span class="line">graph[t1][t2] &#x3D; t3;</span><br><span class="line">graph[t2][t1] &#x3D; t3;</span><br><span class="line">costs[t1][t2] &#x3D; t4;</span><br><span class="line">costs[t2][t1] &#x3D; t4;</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(S);</span><br><span class="line">cout&lt;&lt;dist[D]&lt;&lt;&quot; &quot;&lt;&lt;cost[D];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他变型问题"><a href="#其他变型问题" class="headerlink" title="其他变型问题"></a>其他变型问题</h3><p>要求数最短路径有几条</p><ol><li>初始化起点:count[s] = 1;</li><li>如果找到更短路：count[w] = count[v];</li><li>如果找到等长路：count[w]+=count[v];</li></ol><p>要求边数最少的最短路</p><pre><code>1. counts[s] = 0; 2. 如果找到更短路：count[w] = count[v]+1; 3. 如果找到等长路:  count[w] = count[v] + 1;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-9 旅游规划 (25分)&lt;/p&gt;
&lt;p&gt;有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="Dijkstra" scheme="https://cjay.life/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>关键路径</title>
    <link href="https://cjay.life/2020/07/13/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <id>https://cjay.life/2020/07/13/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</id>
    <published>2020-07-13T13:28:14.000Z</published>
    <updated>2020-07-13T13:42:09.499Z</updated>
    
    <content type="html"><![CDATA[<p>AOE（Activity On Edge,与AOV区别）网络</p><p>计算整个工期就是 计算最早完成时间</p><p>机动时间： D&lt;i,j&gt; = Latest[j] - Earliest[i] - C&lt;i,j&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AOE（Activity On Edge,与AOV区别）网络&lt;/p&gt;
&lt;p&gt;计算整个工期就是 计算最早完成时间&lt;/p&gt;
&lt;p&gt;机动时间： D&amp;lt;i,j&amp;gt; = Latest[j] - Earliest[i] - C&amp;lt;i,j&amp;gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="关键路径" scheme="https://cjay.life/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://cjay.life/2020/07/13/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/13/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-13T10:58:20.000Z</published>
    <updated>2020-07-13T14:46:40.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拓扑序定义"><a href="#拓扑序定义" class="headerlink" title="拓扑序定义"></a>拓扑序定义</h1><p>如果图中从v到w有一条有向途径,则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。</p><p>获得一个拓扑序的过程就是拓扑排序</p><p>Activity On Vertex (AOV) 网络如果有合理的拓扑序，则必定是有向无环图（Directed Acylic Grapg,DAG）</p><h1 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void TopSort()&#123;</span><br><span class="line">for(cnt &#x3D; 0;cnt&lt;v;cnt++)&#123;</span><br><span class="line">v &#x3D; 未输出的入度为0的顶点；&#x2F;&#x2F;O(V)</span><br><span class="line">if(这样的v不存在)&#123;</span><br><span class="line">Error(“图中有回路”);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">输出v，或者记录v的输出序号;</span><br><span class="line">for(v的每个邻接点)</span><br><span class="line">Indegree[w]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(V2)</span><br></pre></td></tr></table></figure><h1 id="聪明的算法"><a href="#聪明的算法" class="headerlink" title="聪明的算法"></a>聪明的算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;随时将入度变为0的顶点放到一个容器里</span><br><span class="line">void TopSort()&#123;</span><br><span class="line">for(图中每个顶点 v)</span><br><span class="line">if(Indegree[v] &#x3D;&#x3D; 0)</span><br><span class="line">enqueue(v,q);</span><br><span class="line">while(!isempty(q))&#123;</span><br><span class="line">v &#x3D; dequeue(q);</span><br><span class="line">输出v,或者记录v的输出序号;cnt++</span><br><span class="line">for(v 的每个邻接点 w)</span><br><span class="line">if(--Indegree[W] &#x3D;&#x3D; 0)</span><br><span class="line">enqueue(W,Q);</span><br><span class="line">&#125;</span><br><span class="line">if( cnt !&#x3D; v)</span><br><span class="line">error(“图中有回路”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(V+E)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;拓扑序定义&quot;&gt;&lt;a href=&quot;#拓扑序定义&quot; class=&quot;headerlink&quot; title=&quot;拓扑序定义&quot;&gt;&lt;/a&gt;拓扑序定义&lt;/h1&gt;&lt;p&gt;如果图中从v到w有一条有向途径,则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。&lt;/p&gt;
&lt;p&gt;获得一个拓扑
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="拓扑排序" scheme="https://cjay.life/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树问题(Minimum Spanning Tree)</title>
    <link href="https://cjay.life/2020/07/13/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/"/>
    <id>https://cjay.life/2020/07/13/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-13T09:48:18.000Z</published>
    <updated>2020-07-13T13:16:13.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>最小生成树首先是一棵树</p><ol><li>无回路</li><li>V个顶点一定有V-1条边</li></ol><p>是生成树</p><ol><li>包含全部顶点</li><li>V-1条边都在图里</li></ol><p>边的权重和最小</p><h1 id="生成最小生成树的算法思想（贪心思想）"><a href="#生成最小生成树的算法思想（贪心思想）" class="headerlink" title="生成最小生成树的算法思想（贪心思想）"></a>生成最小生成树的算法思想（贪心思想）</h1><p>每一步都是选最好的（权重最小的边）</p><p>选择过程中的约束：</p><ol><li>只能用图里的边</li><li>只能一种选择v-1条边</li><li>不能有回路</li></ol><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>类似Dijikastra算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">v &#x3D; 未收录顶点中dist最小值;</span><br><span class="line">if(这样的v不存在)</span><br><span class="line">break;</span><br><span class="line">collected[v] &#x3D; true;</span><br><span class="line">for(v 的每个邻接点 w)&#123;</span><br><span class="line">if((collected[w] &#x3D;&#x3D; false) &amp;&amp; (dist[v] + E&lt;v,w&gt; &lt; dist[w]))&#123;</span><br><span class="line">dist[w] &#x3D; dist[v] + E[v,w]l</span><br><span class="line">path[w] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void Prim()&#123;</span><br><span class="line">MST &#x3D; &#123;s&#125;;</span><br><span class="line">while(1)&#123;</span><br><span class="line">v &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">if(这样v不存在)</span><br><span class="line">break;</span><br><span class="line">将v收录进MST: dist[v] &#x3D; 0;</span><br><span class="line">for(v 的每个邻接点 w)&#123;</span><br><span class="line">if(dist[w] !&#x3D; 0)&#123;</span><br><span class="line">if(E&lt;v,w&gt; &lt;dist[w])&#123;</span><br><span class="line">dist[w] &#x3D; E&lt;v,w&gt;;</span><br><span class="line">parent[W] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(MST中收的顶点不到V个)</span><br><span class="line">Error(“生成树不存在”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;dist[v] &#x3D; E&lt;s,v&gt; 或 正无穷</span><br><span class="line">&#x2F;&#x2F;parent[s] &#x3D; -1</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(v2) 稠密图合算</span><br></pre></td></tr></table></figure><h2 id="Kruskal算法（将森林合并成树）"><a href="#Kruskal算法（将森林合并成树）" class="headerlink" title="Kruskal算法（将森林合并成树）"></a>Kruskal算法（将森林合并成树）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Kruskal (Graph G)&#123;</span><br><span class="line">MST &#x3D; &#123;&#125;;</span><br><span class="line">while(MST中不到|V|-1条边 &amp;&amp; E中还有边)&#123;</span><br><span class="line">从E中取一条权重最小边 &#x2F;*最小堆*&#x2F;</span><br><span class="line">将E&lt;v,w&gt;从E中删除；</span><br><span class="line">if(E&lt;v,w&gt;不在MST中构成回路) &#x2F;*并查集*&#x2F;</span><br><span class="line"> E(V,W) 加入 MST;</span><br><span class="line">else</span><br><span class="line">彻底无视 E(V,W);</span><br><span class="line">&#125;</span><br><span class="line">if ( MST 中不到 |V|-1 条边 )</span><br><span class="line">Error ( “生成树不存在” );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(ElogE)</span><br></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 邻接矩阵存储 - Prim最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">Vertex FindMinDist( MGraph Graph, WeightType dist[] )</span><br><span class="line">&#123; &#x2F;* 返回未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">    Vertex MinV, V;</span><br><span class="line">    WeightType MinDist &#x3D; INFINITY;</span><br><span class="line"> </span><br><span class="line">    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        if ( dist[V]!&#x3D;0 &amp;&amp; dist[V]&lt;MinDist) &#123;</span><br><span class="line">            &#x2F;* 若V未被收录，且dist[V]更小 *&#x2F;</span><br><span class="line">            MinDist &#x3D; dist[V]; &#x2F;* 更新最小距离 *&#x2F;</span><br><span class="line">            MinV &#x3D; V; &#x2F;* 更新对应顶点 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (MinDist &lt; INFINITY) &#x2F;* 若找到最小dist *&#x2F;</span><br><span class="line">        return MinV; &#x2F;* 返回对应的顶点下标 *&#x2F;</span><br><span class="line">    else return ERROR;  &#x2F;* 若这样的顶点不存在，返回-1作为标记 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Prim( MGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType dist[MaxVertexNum], TotalWeight;</span><br><span class="line">    Vertex parent[MaxVertexNum], V, W;</span><br><span class="line">    int VCount;</span><br><span class="line">    Edge E;</span><br><span class="line">     </span><br><span class="line">    &#x2F;* 初始化。默认初始点下标是0 *&#x2F;</span><br><span class="line">       for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        &#x2F;* 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY *&#x2F;</span><br><span class="line">           dist[V] &#x3D; Graph-&gt;G[0][V];</span><br><span class="line">           parent[V] &#x3D; 0; &#x2F;* 暂且定义所有顶点的父结点都是初始点0 *&#x2F; </span><br><span class="line">    &#125;</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    VCount &#x3D; 0;      &#x2F;* 初始化收录的顶点数 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    E &#x3D; (Edge)malloc( sizeof(struct ENode) ); &#x2F;* 建立空的边结点 *&#x2F;</span><br><span class="line">            </span><br><span class="line">    &#x2F;* 将初始点0收录进MST *&#x2F;</span><br><span class="line">    dist[0] &#x3D; 0;</span><br><span class="line">    VCount ++;</span><br><span class="line">    parent[0] &#x3D; -1; &#x2F;* 当前树根是0 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    while (1) &#123;</span><br><span class="line">        V &#x3D; FindMinDist( Graph, dist );</span><br><span class="line">        &#x2F;* V &#x3D; 未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">        if ( V&#x3D;&#x3D;ERROR ) &#x2F;* 若这样的V不存在 *&#x2F;</span><br><span class="line">            break;   &#x2F;* 算法结束 *&#x2F;</span><br><span class="line">             </span><br><span class="line">        &#x2F;* 将V及相应的边&lt;parent[V], V&gt;收录进MST *&#x2F;</span><br><span class="line">        E-&gt;V1 &#x3D; parent[V];</span><br><span class="line">        E-&gt;V2 &#x3D; V;</span><br><span class="line">        E-&gt;Weight &#x3D; dist[V];</span><br><span class="line">        InsertEdge( MST, E );</span><br><span class="line">        TotalWeight +&#x3D; dist[V];</span><br><span class="line">        dist[V] &#x3D; 0;</span><br><span class="line">        VCount++;</span><br><span class="line">         </span><br><span class="line">        for( W&#x3D;0; W&lt;Graph-&gt;Nv; W++ ) &#x2F;* 对图中的每个顶点W *&#x2F;</span><br><span class="line">            if ( dist[W]!&#x3D;0 &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;</span><br><span class="line">            &#x2F;* 若W是V的邻接点并且未被收录 *&#x2F;</span><br><span class="line">                if ( Graph-&gt;G[V][W] &lt; dist[W] ) &#123;</span><br><span class="line">                &#x2F;* 若收录V使得dist[W]变小 *&#x2F;</span><br><span class="line">                    dist[W] &#x3D; Graph-&gt;G[V][W]; &#x2F;* 更新dist[W] *&#x2F;</span><br><span class="line">                    parent[W] &#x3D; V; &#x2F;* 更新树 *&#x2F;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; &#x2F;* while结束*&#x2F;</span><br><span class="line">    if ( VCount &lt; Graph-&gt;Nv ) &#x2F;* MST中收的顶点不到|V|个 *&#x2F;</span><br><span class="line">       TotalWeight &#x3D; ERROR;</span><br><span class="line">    return TotalWeight;   &#x2F;* 算法执行完毕，返回最小权重和或错误标记 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 邻接表存储 - Kruskal最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 顶点并查集定义 --------------------*&#x2F;</span><br><span class="line">typedef Vertex ElementType; &#x2F;* 默认元素可以用非负整数表示 *&#x2F;</span><br><span class="line">typedef Vertex SetName;     &#x2F;* 默认用根结点的下标作为集合名称 *&#x2F;</span><br><span class="line">typedef ElementType SetType[MaxVertexNum]; &#x2F;* 假设集合元素下标从0开始 *&#x2F;</span><br><span class="line"> </span><br><span class="line">void InitializeVSet( SetType S, int N )</span><br><span class="line">&#123; &#x2F;* 初始化并查集 *&#x2F;</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    for ( X&#x3D;0; X&lt;N; X++ ) S[X] &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Union( SetType S, SetName Root1, SetName Root2 )</span><br><span class="line">&#123; &#x2F;* 这里默认Root1和Root2是不同集合的根结点 *&#x2F;</span><br><span class="line">    &#x2F;* 保证小集合并入大集合 *&#x2F;</span><br><span class="line">    if ( S[Root2] &lt; S[Root1] ) &#123; &#x2F;* 如果集合2比较大 *&#x2F;</span><br><span class="line">        S[Root2] +&#x3D; S[Root1];     &#x2F;* 集合1并入集合2  *&#x2F;</span><br><span class="line">        S[Root1] &#x3D; Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;                         &#x2F;* 如果集合1比较大 *&#x2F;</span><br><span class="line">        S[Root1] +&#x3D; S[Root2];     &#x2F;* 集合2并入集合1  *&#x2F;</span><br><span class="line">        S[Root2] &#x3D; Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SetName Find( SetType S, ElementType X )</span><br><span class="line">&#123; &#x2F;* 默认集合元素全部初始化为-1 *&#x2F;</span><br><span class="line">    if ( S[X] &lt; 0 ) &#x2F;* 找到集合的根 *&#x2F;</span><br><span class="line">        return X;</span><br><span class="line">    else</span><br><span class="line">        return S[X] &#x3D; Find( S, S[X] ); &#x2F;* 路径压缩 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )</span><br><span class="line">&#123; &#x2F;* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 *&#x2F;</span><br><span class="line">    Vertex Root1, Root2;</span><br><span class="line"> </span><br><span class="line">    Root1 &#x3D; Find( VSet, V1 ); &#x2F;* 得到V1所属的连通集名称 *&#x2F;</span><br><span class="line">    Root2 &#x3D; Find( VSet, V2 ); &#x2F;* 得到V2所属的连通集名称 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    if( Root1&#x3D;&#x3D;Root2 ) &#x2F;* 若V1和V2已经连通，则该边不能要 *&#x2F;</span><br><span class="line">        return false;</span><br><span class="line">    else &#123; &#x2F;* 否则该边可以被收集，同时将V1和V2并入同一连通集 *&#x2F;</span><br><span class="line">        Union( VSet, Root1, Root2 );</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 并查集定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 边的最小堆定义 --------------------*&#x2F;</span><br><span class="line">void PercDown( Edge ESet, int p, int N )</span><br><span class="line">&#123; &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p )    *&#x2F;</span><br><span class="line">  &#x2F;* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 *&#x2F;</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    struct ENode X;</span><br><span class="line"> </span><br><span class="line">    X &#x3D; ESet[p]; &#x2F;* 取出根结点存放的值 *&#x2F;</span><br><span class="line">    for( Parent&#x3D;p; (Parent*2+1)&lt;N; Parent&#x3D;Child ) &#123;</span><br><span class="line">        Child &#x3D; Parent * 2 + 1;</span><br><span class="line">        if( (Child!&#x3D;N-1) &amp;&amp; (ESet[Child].Weight&gt;ESet[Child+1].Weight) )</span><br><span class="line">            Child++;  &#x2F;* Child指向左右子结点的较小者 *&#x2F;</span><br><span class="line">        if( X.Weight &lt;&#x3D; ESet[Child].Weight ) break; &#x2F;* 找到了合适位置 *&#x2F;</span><br><span class="line">        else  &#x2F;* 下滤X *&#x2F;</span><br><span class="line">            ESet[Parent] &#x3D; ESet[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    ESet[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void InitializeESet( LGraph Graph, Edge ESet )</span><br><span class="line">&#123; &#x2F;* 将图的边存入数组ESet，并且初始化为最小堆 *&#x2F;</span><br><span class="line">    Vertex V;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    int ECount;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将图的边存入数组ESet *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;</span><br><span class="line">    for ( V&#x3D;0; V&lt;Graph-&gt;Nv; V++ )</span><br><span class="line">        for ( W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next )</span><br><span class="line">            if ( V &lt; W-&gt;AdjV ) &#123; &#x2F;* 避免重复录入无向图的边，只收V1&lt;V2的边 *&#x2F;</span><br><span class="line">                ESet[ECount].V1 &#x3D; V;</span><br><span class="line">                ESet[ECount].V2 &#x3D; W-&gt;AdjV;</span><br><span class="line">                ESet[ECount++].Weight &#x3D; W-&gt;Weight;</span><br><span class="line">            &#125;</span><br><span class="line">    &#x2F;* 初始化为最小堆 *&#x2F;</span><br><span class="line">    for ( ECount&#x3D;Graph-&gt;Ne&#x2F;2; ECount&gt;&#x3D;0; ECount-- )</span><br><span class="line">        PercDown( ESet, ECount, Graph-&gt;Ne );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int GetEdge( Edge ESet, int CurrentSize )</span><br><span class="line">&#123; &#x2F;* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将最小边与当前堆的最后一个位置的边交换 *&#x2F;</span><br><span class="line">    Swap( &amp;ESet[0], &amp;ESet[CurrentSize-1]);</span><br><span class="line">    &#x2F;* 将剩下的边继续调整成最小堆 *&#x2F;</span><br><span class="line">    PercDown( ESet, 0, CurrentSize-1 );</span><br><span class="line"> </span><br><span class="line">    return CurrentSize-1; &#x2F;* 返回最小边所在位置 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 最小堆定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int Kruskal( LGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType TotalWeight;</span><br><span class="line">    int ECount, NextEdge;</span><br><span class="line">    SetType VSet; &#x2F;* 顶点数组 *&#x2F;</span><br><span class="line">    Edge ESet;    &#x2F;* 边数组 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    InitializeVSet( VSet, Graph-&gt;Nv ); &#x2F;* 初始化顶点并查集 *&#x2F;</span><br><span class="line">    ESet &#x3D; (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne );</span><br><span class="line">    InitializeESet( Graph, ESet ); &#x2F;* 初始化边的最小堆 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;      &#x2F;* 初始化收录的边数 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    NextEdge &#x3D; Graph-&gt;Ne; &#x2F;* 原始边集的规模 *&#x2F;</span><br><span class="line">    while ( ECount &lt; Graph-&gt;Nv-1 ) &#123;  &#x2F;* 当收集的边不足以构成树时 *&#x2F;</span><br><span class="line">        NextEdge &#x3D; GetEdge( ESet, NextEdge ); &#x2F;* 从边集中得到最小边的位置 *&#x2F;</span><br><span class="line">        if (NextEdge &lt; 0) &#x2F;* 边集已空 *&#x2F;</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;* 如果该边的加入不构成回路，即两端结点不属于同一连通集 *&#x2F;</span><br><span class="line">        if ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )&#x3D;&#x3D;true ) &#123;</span><br><span class="line">            &#x2F;* 将该边插入MST *&#x2F;</span><br><span class="line">            InsertEdge( MST, ESet+NextEdge );</span><br><span class="line">            TotalWeight +&#x3D; ESet[NextEdge].Weight; &#x2F;* 累计权重 *&#x2F;</span><br><span class="line">            ECount++; &#x2F;* 生成树中边数加1 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( ECount &lt; Graph-&gt;Nv-1 )</span><br><span class="line">        TotalWeight &#x3D; -1; &#x2F;* 设置错误标记，表示生成树不存在 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    return TotalWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;最小生成树首先是一棵树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无回路&lt;/li&gt;
&lt;li&gt;V个顶点一定有V-1条边&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;是生成树&lt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最小生成树" scheme="https://cjay.life/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈利·波特的考试</title>
    <link href="https://cjay.life/2020/07/13/%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/"/>
    <id>https://cjay.life/2020/07/13/%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/</id>
    <published>2020-07-13T09:06:16.000Z</published>
    <updated>2020-07-13T09:09:36.107Z</updated>
    
    <content type="html"><![CDATA[<p>7-8 哈利·波特的考试 (25分)</p><p>哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。</p><p>现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入第1行给出两个正整数<em>N</em> (≤100)和<em>M</em>，其中<em>N</em>是考试涉及的动物总数，<em>M</em>是用于直接变形的魔咒条数。为简单起见，我们将动物按1~<em>N</em>编号。随后<em>M</em>行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">6 11</span><br><span class="line">3 4 70</span><br><span class="line">1 2 1</span><br><span class="line">5 4 50</span><br><span class="line">2 6 50</span><br><span class="line">5 6 60</span><br><span class="line">1 3 70</span><br><span class="line">4 6 60</span><br><span class="line">3 6 80</span><br><span class="line">5 1 100</span><br><span class="line">2 4 60</span><br><span class="line">5 2 80</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 70</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int D[105][105];</span><br><span class="line">int N,M;</span><br><span class="line">int t1,t2,t3;</span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">if(i!&#x3D;j)</span><br><span class="line">D[i][j] &#x3D; 65535; &#x2F;&#x2F;floyd算法要求无边就初始化为正无穷</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void floyd()&#123;</span><br><span class="line">for(int k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(D[i][k]+D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">D[i][j] &#x3D; D[i][k]+D[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int FindMaxDist(int i)&#123;</span><br><span class="line">int maxdist &#x3D; 0;</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(i!&#x3D;j &amp;&amp; D[i][j]&gt;maxdist)</span><br><span class="line">maxdist &#x3D; D[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;maxdist&lt;&lt;&#39;\n&#39;; </span><br><span class="line">return maxdist;</span><br><span class="line">&#125;</span><br><span class="line">void FindMinDist()&#123;</span><br><span class="line">int mindist &#x3D; 65535;</span><br><span class="line">int animal;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">int maxdist &#x3D; FindMaxDist(i);</span><br><span class="line">if(maxdist &#x3D;&#x3D; 65535)&#123;</span><br><span class="line">printf(&quot;0\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(mindist&gt;maxdist)&#123;</span><br><span class="line">mindist &#x3D; maxdist;</span><br><span class="line">animal &#x3D; i+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d %d\n&quot;,animal,mindist);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">reset();</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;</span><br><span class="line">D[t1-1][t2-1] &#x3D; t3;&#x2F;&#x2F;位置偏移</span><br><span class="line">D[t2-1][t1-1] &#x3D; t3;</span><br><span class="line">&#125;</span><br><span class="line">floyd();</span><br><span class="line">&#x2F;&#x2F;for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">&#x2F;&#x2F;for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;D[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">FindMinDist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-8 哈利·波特的考试 (25分)&lt;/p&gt;
&lt;p&gt;哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最短路径，floyd" scheme="https://cjay.life/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%8Cfloyd/"/>
    
  </entry>
  
  <entry>
    <title>最短路径问题</title>
    <link href="https://cjay.life/2020/07/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>https://cjay.life/2020/07/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-10T12:25:18.000Z</published>
    <updated>2020-07-13T09:09:50.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径问题的抽象"><a href="#最短路径问题的抽象" class="headerlink" title="最短路径问题的抽象"></a>最短路径问题的抽象</h1><p>最短路径就是源点（Source）和终点（Destination）之间权值之和最小的一条路径</p><h1 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h1><ol><li>单元最短路径问题：一点到其他顶点的最短路径<ol><li>（有向）无权图</li><li>（有向）有权图</li></ol></li><li>多源最短路径问题：任意两点之间的最短路径</li></ol><h1 id="无权图的单源最短路算法"><a href="#无权图的单源最短路算法" class="headerlink" title="无权图的单源最短路算法"></a>无权图的单源最短路算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;本质就是BFS的变型</span><br><span class="line">&#x2F;&#x2F;dist[w] &#x3D; S到W的最短距离</span><br><span class="line">&#x2F;&#x2F;dist[S] &#x3D; 0</span><br><span class="line">&#x2F;&#x2F;path[W] &#x3D; S到W的路上经过的某顶点（确切说是上个顶点）</span><br><span class="line">void Unweighted(Vertex S)&#123;</span><br><span class="line">Enqueue(S,Q);</span><br><span class="line">while(!IsEpmty(Q)))&#123;</span><br><span class="line">v &#x3D; Dequeue(Q);</span><br><span class="line">for(V 的每个邻接点 W)&#123;</span><br><span class="line">if(dist[W] &#x3D;&#x3D; -1)&#123;</span><br><span class="line">dist[W] &#x3D; dist[V]+1;</span><br><span class="line">path[W] &#x3D; V;</span><br><span class="line">enqueue(W,Q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有权图的单源最短路算法"><a href="#有权图的单源最短路算法" class="headerlink" title="有权图的单源最短路算法"></a>有权图的单源最短路算法</h1><p><strong><em>Dijkstra算法(按照递增的顺序找到各个顶点的最短路)</em></strong></p><p><strong>前提是不存在负值圈</strong></p><ol><li>令S={源点s + 已经确定了最短路径的顶点vi}</li><li>对不属于集合S的顶点v，定义dist[v]为s到v的最短路径长度，但该路径<em>仅仅经过S中的顶点。</em>即路径{s-&gt;(vi∈S)-&gt;v}的长度</li><li>若路径是按照递增的顺序生成的，则<ol><li>真正的最短路必须只经过S中的顶点（反证法：若存在另外一个结点，那也应该是这一个结点先被收录）</li><li>每次从未收录的顶点中选一个dist最小的收录（贪心）</li><li>增加一个v进入S，可能影响另外一个w的dist值（min{dist[w], dist[v] + &lt;v,w&gt;的权重}）</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">V &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">if(这样v不存在)</span><br><span class="line">break;</span><br><span class="line">collected[v] &#x3D; true;</span><br><span class="line">for(v 的每个邻接点 W)</span><br><span class="line">if(collected[W] &#x3D;&#x3D; false)&#123;</span><br><span class="line">if(dist[v]+E&lt;v,w&gt; &lt; dist[W])&#123;</span><br><span class="line">dist[W] &#x3D; dist[V] + E&lt;v,w&gt;;</span><br><span class="line">path[W] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若将dist的值存在数组和堆中会产生不同的效果：</p><ol><li>数组中 T=O（V2 + E）适合稠密图</li><li>最小堆中<ol><li>更新dist[w] = O(logv)</li><li>T = O(VlogV + ElogV) = O(Elogv) 适合稀疏图</li></ol></li></ol><h1 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h1><ol><li>直接将单元最短路径算法调用V遍 T = O（V3 + E*V）</li><li>Floyd算法 T = O（V3）</li></ol><p>Floyd 算法 </p><ol><li>Dk[i][j] = 路径{i -&gt; {l&lt;=k} -&gt; j}的最小长度</li><li>D0,D1,…,DV-1[i][j]即给出了i到j的真正最短距离</li><li>最初的D-1（如果ij没边，初始化为正无穷）</li><li>Dk-1已经完成，递推到Dk时：<ol><li>或者k不∈最短路径{i-&gt;{l&lt;=k}-&gt;j},则Dk = Dk-1</li><li>或者k∈最短路径,则该路径由两端最短路径组成：Dk[i][j] = Dk-1[i][k] + Dk-1[k][j]</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Floyd()&#123;</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line"> for(j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line"> D[i][j] &#x3D; G[i][j];</span><br><span class="line"> path[i][j] &#x3D; -1;&#x2F;&#x2F;用来打印路径用</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">for(j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(D[i][k]+ D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">D[i][j] &#x3D; D[i][k] + D[k][j];</span><br><span class="line">path[i][j] &#x3D; k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径问题的抽象&quot;&gt;&lt;a href=&quot;#最短路径问题的抽象&quot; class=&quot;headerlink&quot; title=&quot;最短路径问题的抽象&quot;&gt;&lt;/a&gt;最短路径问题的抽象&lt;/h1&gt;&lt;p&gt;最短路径就是源点（Source）和终点（Destination）之间权值之和最小的一
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最短路径" scheme="https://cjay.life/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>2020-7-9</title>
    <link href="https://cjay.life/2020/07/09/2020-7-9/"/>
    <id>https://cjay.life/2020/07/09/2020-7-9/</id>
    <published>2020-07-09T09:31:07.000Z</published>
    <updated>2020-07-09T09:31:07.468Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>1064 Complete Binary Search Tree (30分)</title>
    <link href="https://cjay.life/2020/07/06/1064-Complete-Binary-Search-Tree-30%E5%88%86/"/>
    <id>https://cjay.life/2020/07/06/1064-Complete-Binary-Search-Tree-30%E5%88%86/</id>
    <published>2020-07-06T15:36:25.000Z</published>
    <updated>2020-07-06T15:38:17.314Z</updated>
    
    <content type="html"><![CDATA[<p>1064 Complete Binary Search Tree (30分)</p><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p><p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 3 8 1 5 7 9 0 2 4</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int num[1005];</span><br><span class="line">int ans[1005];</span><br><span class="line">int N;</span><br><span class="line">int getMid(int l,int r)&#123;</span><br><span class="line">int sum &#x3D; r-l+1;&#x2F;&#x2F;总数</span><br><span class="line">int layer &#x3D; floor(log(sum+1)&#x2F;log(2)); &#x2F;&#x2F;除最后一层的层数，</span><br><span class="line">int lastlayerleaf &#x3D; sum+1-pow(2,layer);&#x2F;&#x2F;最后一层的节点数</span><br><span class="line">int leftnum &#x3D; pow(2,layer-1)-1+min(lastlayerleaf,(int)pow(2,layer-1));&#x2F;&#x2F;左子树结点总数</span><br><span class="line">return l+leftnum; &#x2F;&#x2F;根位置</span><br><span class="line">&#125; </span><br><span class="line">void solve(int l,int r,int root)&#123;</span><br><span class="line">if(r-l+1 &#x3D;&#x3D; 0) return;</span><br><span class="line">int mid &#x3D; getMid(l,r);</span><br><span class="line">ans[root] &#x3D; num[mid];</span><br><span class="line">solve(l,mid-1,root*2+1);</span><br><span class="line">solve(mid+1,r,root*2+2); </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line">for(int i&#x3D;0;i&lt;N;i++)</span><br><span class="line">cin&gt;&gt;num[i];</span><br><span class="line">sort(num,num+N);</span><br><span class="line">solve(0,N-1,0);</span><br><span class="line">cout&lt;&lt;ans[0];</span><br><span class="line">for(int i &#x3D; 1;i&lt;N;i++)</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1064 Complete Binary Search Tree (30分)&lt;/p&gt;
&lt;p&gt;A Binary Search Tree (BST) is recursively defined as a binary tree which has the following 
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树，公式推导" scheme="https://cjay.life/tags/%E6%A0%91%EF%BC%8C%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>1086 Tree Traversals Again (25分)</title>
    <link href="https://cjay.life/2020/07/06/1086-Tree-Traversals-Again-25%E5%88%86/"/>
    <id>https://cjay.life/2020/07/06/1086-Tree-Traversals-Again-25%E5%88%86/</id>
    <published>2020-07-06T14:31:55.000Z</published>
    <updated>2020-07-06T14:34:55.193Z</updated>
    
    <content type="html"><![CDATA[<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p><p><img src="https://images.ptausercontent.com/30" alt="img"><br>Figure 1</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 2 6 5 1</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,n,i,j,k;</span><br><span class="line">string s;</span><br><span class="line">int preorder[35];</span><br><span class="line">int inorder[35];</span><br><span class="line">int postorder[35];</span><br><span class="line">void porder(int ileft,int iright,int pleft,int pright)&#123;&#x2F;&#x2F;核心算法</span><br><span class="line">if((ileft&gt;iright)||(pleft&gt;pright))</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">postorder[k++] &#x3D; preorder[pleft];</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;postorder[k-1]&lt;&lt;endl;</span><br><span class="line">for(i &#x3D; ileft;i&lt;&#x3D;iright;i++)&#123;</span><br><span class="line">if(inorder[i] &#x3D;&#x3D; preorder[pleft])</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">porder(i+1,iright,pleft+1+i-ileft,pright);</span><br><span class="line">porder(ileft,i-1,pleft+1,pleft+i-ileft);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line">int NN &#x3D; 2*N;</span><br><span class="line">stack&lt;int&gt; ss;</span><br><span class="line">while(NN--)&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">if(s&#x3D;&#x3D;&quot;Push&quot;)&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">ss.push(n);</span><br><span class="line">preorder[i++] &#x3D; n;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">n &#x3D; ss.top();</span><br><span class="line">ss.pop();</span><br><span class="line">inorder[j++] &#x3D; n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">porder(0,N-1,0,N-1);</span><br><span class="line">cout&lt;&lt;postorder[N-1];</span><br><span class="line">for(int j &#x3D; N-2;j&gt;&#x3D;0;j--)&#123;</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;postorder[j];</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary t
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树的遍历" scheme="https://cjay.life/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>关于高效学习</title>
    <link href="https://cjay.life/2020/07/06/%E5%85%B3%E4%BA%8E%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    <id>https://cjay.life/2020/07/06/%E5%85%B3%E4%BA%8E%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-06T04:38:50.000Z</published>
    <updated>2020-07-06T05:01:54.023Z</updated>
    
    <content type="html"><![CDATA[<p>看完高效学习篇之后，想要进一步将知识缩减，并带入自己的思考。</p><h1 id="端正学习态度"><a href="#端正学习态度" class="headerlink" title="端正学习态度"></a>端正学习态度</h1><p><img src="https://dingyue.ws.126.net/d62vefHcMwmSZZFe0RXktPa4DG1hElKx4fjzHitgkZx4v1571967477433.jpg" alt="推荐丨金字塔学习法，输出和实践最能提升学习效率_网易订阅"></p><p>在学习知识后，必须有对知识本身有着思考，总结与归纳，不断对这些知识进行应用，对外输出。</p><p>更详细得步骤：</p><ol><li>好的信息源头</li><li>将知识连成地图</li><li>对于知识本身反思与思辨</li><li>举一反三，进行应用</li></ol><h1 id="源头、原理和知识地图"><a href="#源头、原理和知识地图" class="headerlink" title="源头、原理和知识地图"></a>源头、原理和知识地图</h1><p>好的信息源头有如下特质:</p><ol><li>第一首资料</li><li>有佐证、有数据、有引用</li><li>加入了自己经验与思考</li></ol><p>注重基础和原理</p><p>将所有得知识串联起来。</p><h1 id="深度归纳和坚持实践"><a href="#深度归纳和坚持实践" class="headerlink" title="深度归纳和坚持实践"></a>深度归纳和坚持实践</h1><p>对于新技术，除了知识图，还需要问自己多个为什么？</p><ol><li>技术出现得背景、初衷和需要用来解决什么问题</li><li>该技术的优势和劣势</li><li>适用场景（所谓场景一般分别两个，一个是业务场景，一个是技术场景。）</li><li>技术的组成部分和关键点（技术的核心思想和核心组件）</li><li>技术的底层原理和关键实现</li><li>已有的实现和它之间的对比</li></ol><p>举一反三的能力：</p><ol><li>联想能力：对同一个事物的不同看法，联想相关事物</li><li>抽象能力：从不同问题中抽象出解的结构</li><li>自省能力：自己的不足</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完高效学习篇之后，想要进一步将知识缩减，并带入自己的思考。&lt;/p&gt;
&lt;h1 id=&quot;端正学习态度&quot;&gt;&lt;a href=&quot;#端正学习态度&quot; class=&quot;headerlink&quot; title=&quot;端正学习态度&quot;&gt;&lt;/a&gt;端正学习态度&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https:
      
    
    </summary>
    
    
      <category term="学习方法" scheme="https://cjay.life/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="学习方法，左耳朵耗子极客时间" scheme="https://cjay.life/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B7%A6%E8%80%B3%E6%9C%B5%E8%80%97%E5%AD%90%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>7-7 六度空间</title>
    <link href="https://cjay.life/2020/07/05/7-7-%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/"/>
    <id>https://cjay.life/2020/07/05/7-7-%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</id>
    <published>2020-07-05T13:56:26.000Z</published>
    <updated>2020-07-05T14:12:42.386Z</updated>
    
    <content type="html"><![CDATA[<p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p><p><img src="https://images.ptausercontent.com/35" alt="img"><br>图1 六度空间示意图</p><p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p><p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数，分别表示社交网络图的结点数<em>N</em>（1&lt;<em>N</em>≤103，表示人数）、边数<em>M</em>（≤33×<em>N</em>，表示社交关系数）。随后的<em>M</em>行对应<em>M</em>条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到<em>N</em>编号）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1: 70.00%</span><br><span class="line">2: 80.00%</span><br><span class="line">3: 90.00%</span><br><span class="line">4: 100.00%</span><br><span class="line">5: 100.00%</span><br><span class="line">6: 100.00%</span><br><span class="line">7: 100.00%</span><br><span class="line">8: 90.00%</span><br><span class="line">9: 80.00%</span><br><span class="line">10: 70.00%</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int v[1005][1005];</span><br><span class="line">int flag[1005];</span><br><span class="line">int t1,t2,sum;</span><br><span class="line">int BFS(int node)&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int count &#x3D; 1;</span><br><span class="line">int level &#x3D; 0;</span><br><span class="line">int last &#x3D; node;</span><br><span class="line">int tail;</span><br><span class="line">flag[node] &#x3D; 1;</span><br><span class="line">q.push(node);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">node &#x3D; q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">if((v[node][i] &#x3D;&#x3D; 1) &amp;&amp; (flag[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">flag[i] &#x3D; 1;</span><br><span class="line">q.push(i);</span><br><span class="line">count++;</span><br><span class="line">tail &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(node &#x3D;&#x3D; last)&#123;</span><br><span class="line">level++;</span><br><span class="line">last &#x3D; tail;</span><br><span class="line">&#125;</span><br><span class="line">if(level&#x3D;&#x3D;6) break;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">flag[i] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">v[t1][t2] &#x3D; 1;</span><br><span class="line">v[t2][t1] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 1 ;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">sum &#x3D; BFS(i);</span><br><span class="line">printf(&quot;%d: %.2f%%\n&quot;,i,(double)sum&#x2F;N*100);</span><br><span class="line">reset();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="该题要点"><a href="#该题要点" class="headerlink" title="该题要点"></a>该题要点</h3><p>这个题目在传统的BFS算法上进行改造，需要在BFS过程中记录当前遍历的层数。</p><p>这里再原来的基础上增加了三个变量 tail,last,level;</p><p>tail表示下一层的最后一个元素；</p><p>last表示当前层的最后一个元素；</p><p>level表示当前位于第几层；</p><hr><p>初始 tail不用设，last = node（第0层最后一个结点就是自己）,level = 0(自己不算）</p><hr><p>这里关键点是为什么能知道当前node是该层最后一个元素？</p><p>while循环中，最后判断时，弹出的当前结点node == last 时，表明：</p><p>该层最后一个结点已经被弹出，且下一层所有结点全在队列中了；</p><p>这个时候更改新一层的last，将last = tail，并将level++；</p><p>level的数值表示，当前i层的所有数据已经被访问完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="BFS" scheme="https://cjay.life/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>7-10 Saving James Bond - Easy Version</title>
    <link href="https://cjay.life/2020/07/05/7-10-Saving-James-Bond-Easy-Version/"/>
    <id>https://cjay.life/2020/07/05/7-10-Saving-James-Bond-Easy-Version/</id>
    <published>2020-07-05T12:51:32.000Z</published>
    <updated>2020-07-05T12:53:00.625Z</updated>
    
    <content type="html"><![CDATA[<p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p><p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if James can escape, or “No” if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">14 20</span><br><span class="line">25 -15</span><br><span class="line">-25 28</span><br><span class="line">8 49</span><br><span class="line">29 15</span><br><span class="line">-35 -2</span><br><span class="line">5 28</span><br><span class="line">27 -29</span><br><span class="line">-8 -28</span><br><span class="line">-20 -35</span><br><span class="line">-25 -20</span><br><span class="line">-13 29</span><br><span class="line">-30 15</span><br><span class="line">-35 40</span><br><span class="line">12 12</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 13</span><br><span class="line">-12 12</span><br><span class="line">12 12</span><br><span class="line">-12 -12</span><br><span class="line">12 -12</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> struct node&#123;</span><br><span class="line"> int x,y;</span><br><span class="line"> &#125;;</span><br><span class="line"> node cro[105];</span><br><span class="line"> int visited[105];</span><br><span class="line"> int N,D;</span><br><span class="line"> int t1,t2;</span><br><span class="line"> bool answer &#x3D; 0;</span><br><span class="line"> double distance(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line"> return pow(x2-x1,2)+pow(y2-y1,2);</span><br><span class="line"> &#125; </span><br><span class="line">  bool DFS(int x, int y,int n)&#123;</span><br><span class="line"> if((x-D&lt;&#x3D;-50)||(x+D&gt;&#x3D;50)||(y-D&lt;&#x3D;-50)||(y+D&gt;&#x3D;50))&#123;</span><br><span class="line"> answer &#x3D; true;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">visited[n] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((distance(x,y,cro[i].x,cro[i].y)&lt;&#x3D;pow(D,2)) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">DFS(cro[i].x,cro[i].y,i);</span><br><span class="line">if(answer &#x3D;&#x3D; true) break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"> return answer;</span><br><span class="line"> &#125;</span><br><span class="line"> void toJump()&#123;</span><br><span class="line"> for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line"> if((distance(0,0,cro[i].x,cro[i].y)&lt;&#x3D;pow(D+15,2)) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">answer &#x3D; DFS(cro[i].x,cro[i].y,i);</span><br><span class="line">if(answer &#x3D;&#x3D; true) break; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(answer) cout&lt;&lt;&quot;Yes&quot;;</span><br><span class="line">else cout&lt;&lt;&quot;No&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> int main()&#123;</span><br><span class="line"> cin&gt;&gt;N&gt;&gt;D;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line"> cin&gt;&gt;cro[i].x&gt;&gt;cro[i].y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toJump();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="DFS" scheme="https://cjay.life/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>列出连通集</title>
    <link href="https://cjay.life/2020/06/21/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/"/>
    <id>https://cjay.life/2020/06/21/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</id>
    <published>2020-06-21T13:07:36.000Z</published>
    <updated>2020-06-28T15:30:28.257Z</updated>
    
    <content type="html"><![CDATA[<p>7-6 列出连通集 (25分)</p><p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照”{ <em>v</em>1 <em>v</em>2 … <em>v**k</em> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int g[10][10];</span><br><span class="line">int visited[10];</span><br><span class="line">int n,m,t1,t2;</span><br><span class="line">void BFS(int v)&#123;</span><br><span class="line">int vt;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">q.push(v);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">vt &#x3D; q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if((g[vt][i] &#x3D;&#x3D; 1) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">visited[i] &#x3D; 1;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int v)&#123;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if((g[v][i] &#x3D;&#x3D; 1) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">DFS(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i &#x3D; 0;i&lt;m;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">g[t1][t2] &#x3D; 1;</span><br><span class="line">g[t2][t1] &#x3D; 1;</span><br><span class="line">&#125; </span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if(visited[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">DFS(i);</span><br><span class="line">cout&lt;&lt;&quot;&#125;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)</span><br><span class="line">visited[i] &#x3D; 0;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if(visited[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">BFS(i);</span><br><span class="line">cout&lt;&lt;&quot;&#125;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-6 列出连通集 (25分)&lt;/p&gt;
&lt;p&gt;给定一个有&lt;em&gt;N&lt;/em&gt;个顶点和&lt;em&gt;E&lt;/em&gt;条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到&lt;em&gt;N&lt;/em&gt;−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="BFS" scheme="https://cjay.life/tags/BFS/"/>
    
      <category term="DFS" scheme="https://cjay.life/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://cjay.life/2020/06/20/%E5%9B%BE/"/>
    <id>https://cjay.life/2020/06/20/%E5%9B%BE/</id>
    <published>2020-06-20T10:41:22.000Z</published>
    <updated>2020-06-28T15:37:46.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图定义"><a href="#图定义" class="headerlink" title="图定义"></a>图定义</h1><p>由V（Vertex）表示有限顶点集合和E（Edge）表示有限边的集合组成</p><p><strong><em>不考虑重边和自回路</em></strong></p><p><strong><em>V不能为空，E能为空</em></strong></p><p>图又可分为好几种类型，比如：</p><p>有向图与无向图</p><p>网络与非网络图（边是否有权重）</p><h1 id="在程序中表示一个图"><a href="#在程序中表示一个图" class="headerlink" title="在程序中表示一个图"></a>在程序中表示一个图</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><h3 id="无向图用一维矩阵代替二维矩阵"><a href="#无向图用一维矩阵代替二维矩阵" class="headerlink" title="无向图用一维矩阵代替二维矩阵"></a>无向图用一维矩阵代替二维矩阵</h3><p>假定G [N] [N] 矩阵，可以用一个长度为N(N+1)/2的一维矩阵A存储，则Gij在A中对应的下标是：<strong>i（i+1）/2+j</strong></p><h3 id="邻接矩阵的优势"><a href="#邻接矩阵的优势" class="headerlink" title="邻接矩阵的优势"></a>邻接矩阵的优势</h3><ol><li>直观，好理解</li><li>方便查找两个顶点之间是否存在边</li><li>方便查找一个顶点的邻接点（对于无向图，只需要查找一行，有向图要查找一行一列）</li><li>方便计算度</li></ol><h3 id="邻接矩阵的劣势"><a href="#邻接矩阵的劣势" class="headerlink" title="邻接矩阵的劣势"></a>邻接矩阵的劣势</h3><ol><li>对于稀疏图（点多边少）</li><li>若要统计图中边的数量，只能遍历完整个矩阵</li></ol><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>设置G[N]为指针数组，数组中每个单元都存放着一个链表（存放G[i]的临接点）</p><h3 id="邻接表的优势"><a href="#邻接表的优势" class="headerlink" title="邻接表的优势"></a>邻接表的优势</h3><ol><li>方便查找任一结点的所有“邻接点”</li><li>对于稀疏图节约空间：N个头指针+2E个结点（每个结点两个域）</li><li>对于无向图方便计算顶点的度</li></ol><h3 id="邻接表的劣势"><a href="#邻接表的劣势" class="headerlink" title="邻接表的劣势"></a>邻接表的劣势</h3><ol><li>对于边多点少的稠密图就不划算</li><li>对于有向图，只能计算出度；对于入度，需要构造逆邻接表（存指向自己的边）来方便计算入度</li><li>对于查找一对顶点间是否存在边很不方便</li></ol><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深搜（Depth-First-Search-DFS）"><a href="#深搜（Depth-First-Search-DFS）" class="headerlink" title="深搜（Depth First Search ,DFS）"></a>深搜（Depth First Search ,DFS）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Vertex X)&#123;</span><br><span class="line">visited[X] &#x3D; true;</span><br><span class="line">for(V的每个临接点 W)</span><br><span class="line">if(visited[W] &#x3D;&#x3D; false)</span><br><span class="line">DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若有N个顶点，E条边，时间复杂度</p><ul><li>邻接表，O（N+E）</li><li>邻接矩阵，O(N2)</li></ul><h2 id="广搜（Breadth-First-Search）"><a href="#广搜（Breadth-First-Search）" class="headerlink" title="广搜（Breadth First Search）"></a>广搜（Breadth First Search）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Void BFS(Vertex V)&#123;</span><br><span class="line">visited[V] &#x3D; true;</span><br><span class="line">Enqueue(V,Q);</span><br><span class="line">while(!IsEmpty(Q))&#123;</span><br><span class="line">V &#x3D; Dequeue(Q);</span><br><span class="line">for(V 的每个邻接点 W)</span><br><span class="line">if(!visited[w])&#123;</span><br><span class="line">visited[W] &#x3D; true;</span><br><span class="line">Enqueue(W,Q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若有N个顶点，E条边，时间复杂度</p><ul><li>邻接表，O（N+E）</li><li>邻接矩阵，O(N2)</li></ul><h1 id="图论的一些概念"><a href="#图论的一些概念" class="headerlink" title="图论的一些概念"></a>图论的一些概念</h1><p>连通 ：V到W存在一条路径，则称V和W是连通的</p><p>连通图: 图中任意两顶点均连通</p><p>连通分量： <strong><em>无向图</em></strong>的极大连通子图</p><p>​     极大顶点数</p><pre><code>极大边数</code></pre><p>强连通： <strong><em>有向图</em></strong>中顶点V和W之间存在双向路径</p><p>强连通图:  <strong><em>有向图</em></strong>中任意两顶点均强连通</p><p>强连通分量：有向图的极大连通子图</p><p>简单路径：V到W之间的所有顶点都不同</p><p>回路：起点等于终点的路径</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图定义&quot;&gt;&lt;a href=&quot;#图定义&quot; class=&quot;headerlink&quot; title=&quot;图定义&quot;&gt;&lt;/a&gt;图定义&lt;/h1&gt;&lt;p&gt;由V（Vertex）表示有限顶点集合和E（Edge）表示有限边的集合组成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不考虑重边和自回路&lt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>File Transfer</title>
    <link href="https://cjay.life/2020/06/19/File-Transfer/"/>
    <id>https://cjay.life/2020/06/19/File-Transfer/</id>
    <published>2020-06-19T09:23:10.000Z</published>
    <updated>2020-06-19T09:24:55.821Z</updated>
    
    <content type="html"><![CDATA[<p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains <em>N</em> (2≤<em>N</em>≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and <em>N</em>. Then in the following lines, the input is given in the format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I c1 c2</span><br></pre></td></tr></table></figure><p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C c1 c2</span><br></pre></td></tr></table></figure><p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure><p>where <code>S</code> stands for stopping this case.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each <code>C</code> case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are <code>k</code> components.” where <code>k</code> is the number of connected components in this network.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">There are 2 components.</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">I 1 3</span><br><span class="line">C 1 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">The network is connected.</span><br></pre></td></tr></table></figure><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char c;</span><br><span class="line">int N;</span><br><span class="line">int pc[10005];</span><br><span class="line">int find(int a)&#123;</span><br><span class="line">if(pc[a]&lt;0) return a;</span><br><span class="line">else return pc[a] &#x3D; find(pc[a]);</span><br><span class="line">&#125;</span><br><span class="line">void input()&#123;</span><br><span class="line">int t1,t2;</span><br><span class="line">scanf(&quot;%d %d\n&quot;,&amp;t1,&amp;t2);</span><br><span class="line">int root1,root2;</span><br><span class="line">root1 &#x3D; find(t1);</span><br><span class="line">root2 &#x3D; find(t2);</span><br><span class="line">pc[root1] &#x3D; root2;</span><br><span class="line">&#125;</span><br><span class="line">void check()&#123;</span><br><span class="line">int t1,t2;</span><br><span class="line">scanf(&quot;%d %d\n&quot;,&amp;t1,&amp;t2);</span><br><span class="line">if(find(t1) &#x3D;&#x3D; find(t2)) cout&lt;&lt;&quot;yes\n&quot;;</span><br><span class="line">else cout&lt;&lt;&quot;no\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">void sum()&#123;</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">if(pc[i] &#x3D;&#x3D; -1) a++;</span><br><span class="line">if(a &#x3D;&#x3D; 1) cout&lt;&lt;&quot;The network is connected.\n&quot;;</span><br><span class="line">else printf(&quot;There are %d components.\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d\n&quot;,&amp;N);</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">pc[i] &#x3D; -1;</span><br><span class="line">do&#123;</span><br><span class="line">scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">switch(c)&#123;</span><br><span class="line">case &#39;I&#39;: input(); break;</span><br><span class="line">case &#39;C&#39;: check(); break;</span><br><span class="line">case &#39;S&#39;: sum(); break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;while(c!&#x3D;&#39;S&#39;); &#x2F;&#x2F;不要忘了；</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one comput
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="并查集" scheme="https://cjay.life/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
</feed>
