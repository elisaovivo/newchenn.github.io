<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CJ&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cjay.life/"/>
  <updated>2020-08-01T15:19:35.351Z</updated>
  <id>https://cjay.life/</id>
  
  <author>
    <name>CJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>csapp第四章-处理器体系结构</title>
    <link href="https://cjay.life/2020/07/30/csapp%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>https://cjay.life/2020/07/30/csapp%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2020-07-30T09:27:12.000Z</published>
    <updated>2020-08-01T15:19:35.351Z</updated>
    
    <content type="html"><![CDATA[<p>ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行这些指令的处理器。</p><a id="more"></a><h1 id="Y86-64指令集体系结构"><a href="#Y86-64指令集体系结构" class="headerlink" title="Y86-64指令集体系结构"></a>Y86-64指令集体系结构</h1><p>定义一个指令体系结构包括定义各种你状态单元、指令集和它们的编码、一组编程规范和异常事件处理。</p><h2 id="程序员可见的状态"><a href="#程序员可见的状态" class="headerlink" title="程序员可见的状态"></a>程序员可见的状态</h2><p>Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分。这称为程序员可见状态。这里的程序员指用汇编代码写程序的人，也可以是产生机器级代码的编译器。</p><p>图2</p><p>15个程序寄存器，rsp作为栈指针，3个一位条件码。</p><p>目前只认为虚拟内存系统向Y86-64提供了一个单一的字节数组映像。</p><p>Stat来表明程序执行的总体状态。它会指示是正常运行，还是出现了某种异常。</p><h2 id="Y86-64指令"><a href="#Y86-64指令" class="headerlink" title="Y86-64指令"></a>Y86-64指令</h2><p>图片</p><p>这个指令集就是处理器实现的目标。它只包括8字节整数操作，寻址方式较少，操作也较少。因为只有8字节数据，所以称之为“字（word）”不会有歧义。</p><ul><li>四种movq，第一第二个字母代表源和目的格式</li><li>内存引用方式采用基址和偏移量形式</li><li>四个整数操作指令，如图4-2中的OPq。只对寄存器数据进行操作</li><li>7个跳转指令jxx</li><li>6个条件传送指令</li><li>call指令将返回地址入栈，然后跳到目的地址。ret指令从这样的调用中返回。</li><li>pushq和popq指令实现入栈和出栈</li><li>halt指令停止指令的执行。执行该指令会导致处理器停止，并将状态设置为HLT</li></ul><h2 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h2><p>每个指令第一个字节表明指令的类型。该字节分为两部分：高4位代码（code）部分，第4位是功能（function）部分。</p><p>图片</p><p>有些指令只有一个字节长，但有些更长，往往带有寄存器指示符字节（regisiter specifier byte），用于指定一或两个寄存器。对于只需要一个寄存器操作数的指令只要将另一个寄存器指示符设为0xF。</p><p>有些指令需要一个附加的4字节常数字(constant word)。这个字能作为立即数数据，偏移量，以及目的地址。</p><p>指令集的一个重要性质就是字节编码必须有唯一的解释。任意一个字节序列要么是一个唯一的指令序列的编码，要么就不是一个合法的字节序列。只要从序列的一个字节开始处理，我们仍然可以容易确定指令序列。若不知道起始位置，就不能准确确定怎样将序列分成单独的指令。</p><h2 id="Y86-64异常"><a href="#Y86-64异常" class="headerlink" title="Y86-64异常"></a>Y86-64异常</h2><p>图片</p><p>在完整设计中，处理器通常会调用一个异常处理程序（exception handler），这个过程被指定用来处理遇到的某种类型的异常。</p><h2 id="Y86-64程序"><a href="#Y86-64程序" class="headerlink" title="Y86-64程序"></a>Y86-64程序</h2><p>图</p><p>“.”开头的词是汇编器伪指令（assmebler directives），告诉汇编器调整地址，以便在那儿产生代码或插入一些数据。</p><p>.pos告诉汇编器从地址0开始产生代码。</p><p>第3行初始化指针，程序结尾处声明了标号stack，并且指明地址0x200。</p><p>8~13声明4个字的数组，标号arry标签数组的起始，并且在8字节边界处对齐（.align伪指令指定）</p><p>16~19给出main过程</p><p>图</p><p>这里实现了一个指令集模拟器YIS，可以模拟Y86-64机器代码程序的执行</p><p>图</p><p>模拟输出的第一行总结了执行以及PC和程序状态的结果值。模拟器只打印出在模拟过程中被改变了的寄存器或内存的字。左边是原始值，右边是最终值。</p><h2 id="一些Y86-64指令的详情"><a href="#一些Y86-64指令的详情" class="headerlink" title="一些Y86-64指令的详情"></a>一些Y86-64指令的详情</h2><p>当执行pushq %rsp指令时，通常有2种约定：1）压入原始值，2）压入减去8的%rsp值</p><p>popq也一样</p><h1 id="逻辑设计和硬件控制语言HCL"><a href="#逻辑设计和硬件控制语言HCL" class="headerlink" title="逻辑设计和硬件控制语言HCL"></a>逻辑设计和硬件控制语言HCL</h1><p>硬件设计种，用电子电路来计算对位进行运算的函数，以及在各种存储器单元中存储位。大多数现代电路技术都是用信号线上的高压电或低压电表示不同位置。当前技术中，逻辑1用1伏特左右的高压电表示，而逻辑0用0伏特左右的低电压表示。</p><p>实现一个数字系统要三个主要的组成部分：</p><ol><li>计算对位机型操作的函数的组合逻辑</li><li>存储位的存储器单元</li><li>控制存储器单元更新的时钟信号</li></ol><p>HCL（Hardware Control Language，硬件控制语言）来描述不同处理器设计的控制逻辑。</p><h2 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h2><p>数字电路的基本计算单元。它们产生输出，等于它们输入位值得某个布尔函数。</p><p>图</p><p>逻辑门总是活动的。一旦一个门输入变化了，很短时间内，输出就会相应地变化。</p><h2 id="组合电路和HCL布尔表达式"><a href="#组合电路和HCL布尔表达式" class="headerlink" title="组合电路和HCL布尔表达式"></a>组合电路和HCL布尔表达式</h2><p>多个逻辑门组合成网，构建计算块(computational block)，称为组合电路（combinational circuits）。构建有如下限制：</p><ul><li>输入必须是:1)一个系统输入，2）某个存储器单元的输出，3）某个逻辑门的输出</li><li>两个或多个逻辑门的输出不能连在一起</li><li>网必须无环</li></ul><p>图</p><p>HCL来写4-10函数就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool eq &#x3D; (a &amp;&amp; b) || (!a &amp;&amp; !b)</span><br></pre></td></tr></table></figure><p>eq仅仅只是给表达式一个名字</p><p>图4-11的组合电路，称为多路复用器（multiplexor,称为“MUX”）。多路复用器根据输入控制信号的值，从一组不同的数据信号中选出一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;s为1输出a，s为0，输出b</span><br><span class="line">bool out &#x3D; (s &amp;&amp; a) || (!s &amp;&amp; b);</span><br></pre></td></tr></table></figure><h2 id="字级的组合电路和HCL整数表达式"><a href="#字级的组合电路和HCL整数表达式" class="headerlink" title="字级的组合电路和HCL整数表达式"></a>字级的组合电路和HCL整数表达式</h2><p>通常我们设计对数据字(word)进行操作的电路。有一些位级信号，代表一个整数或一些控制模式。</p><p>执行字级计算的组合电路根据输入字的各个位，用逻辑门来计算输出字的各个位。</p><p>图</p><p>这个电路用64个图4-10所示的单个位相等电路实现。</p><p>在HCL中，将所有字级信号都声明位int,不指定字的大小。HCL允许比较字是否相等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool Eq &#x3D; (A&#x3D;&#x3D;B)</span><br></pre></td></tr></table></figure><p>这里参数A和B是int型的。</p><p>4-12所示，画字级电路用中等粗度的线表示携带字的每个位的线路，而用虚线来表示布尔信号结果。</p><p>图</p><p>处理器会用到很多种多路复用器，使得我们能根据某些控制条件，从许多源种选出一个字。在HCL中，多路复用器是情况表达式（case expression）来描述的。情况表达式的通用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">select1:expr1;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">select2:exprn;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这个表达式包含一系列的情况，每种情况i都有一个布尔表达式selecti，和一个整数表达式expr，前者表明什么时候该选择这种情况，后者表明的是得到的值。</p><p>同C的switch语句不同，不要求不同的选择表达式之间互斥。从逻辑上讲，这些选择表达式是顺序求值的，且第一个求值为1的情况会被选中。例如4-13中的字级多路复用器用HCL来描述就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">work out &#x3D; [</span><br><span class="line">s:A;</span><br><span class="line">1:B;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>第二个选择表达式1，如果前面情况都没被选中，就选择这个情况。这是HCL中一种指定默认情况的方法。几乎所有的情况表达式都是以此结尾。</p><p>例子：</p><p>图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">word Out4 &#x3D; [</span><br><span class="line">!s1 &amp;&amp; !s0:A;#00</span><br><span class="line">!s1:B;#01</span><br><span class="line">!s0:C;#10</span><br><span class="line">1:D;#11</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作。算术/逻辑单元(ALU)是一种很重要的组合电路。</p><h2 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h2><p>在处理器设计中，很多时候需要将一个信号与许多可能匹配的信号做比较，以此来检测正在处理的某个指令代码是否属于某一类指令代码。</p><h2 id="存储器与时钟"><a href="#存储器与时钟" class="headerlink" title="存储器与时钟"></a>存储器与时钟</h2><p>组合电路本质上不存储任何信息，只是响应输入，然后输出。为了让计算机系统有状态运行，引入时序电路（sequential circuit），引入按位存储信息的设备。存储设备都是由同一个时钟控制。时钟是周期性信号，决定什么时候要把新值加载到设备中。有两类存储器设备:</p><ul><li>时钟寄存器（简称寄存器）：存储多个字。时钟信号控制寄存器加载输入值。</li><li>随机访问存储器（简称内存）:存储多个字，用地址来选择该读写哪个字。</li></ul><p>图</p><p>寄存器作为电路不同部分中的组合逻辑之间的屏障。每当时钟到达上升沿时，值才会从寄存器的输入传送到输出。</p><p>图</p><p>向寄存器文件写入字是由时钟信号控制的。每次时钟上升时，输入valw上的值会被写入输入dstw上的寄存器ID指示的程序寄存器。</p><p>随机访问存储器与时钟寄存器类似。</p><h1 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h1><h2 id="将处理组织成阶段"><a href="#将处理组织成阶段" class="headerlink" title="将处理组织成阶段"></a>将处理组织成阶段</h2><p>通常，将一条指令划分为以下阶段：</p><ul><li>取指（fetch）: 从内存读取指令字节，地址为PC的值。从指令中抽取指令指示符字节的两个四位部分：icode(指令代码)和ifun(指令功能)。还可能有后面部分。它还会按顺序方式计算当前指令的下一条指令的地址valp。valp等于PC的值加已取指令的长度。</li><li>译码（decode）：从寄存器文件读入最多两个操作数。</li><li>执行（execute）：ALU要么执行指令指明的操作，计算内存引用的有效地址，要么增加或减少栈指针。得到的值，我们称为valE。在此，可能设置条件码。对条件传送指令来说，这个阶段会检查条件码和传送条件，如果成立，就更新目标寄存器。对跳转指令，该阶段会决定是不是选择分支。</li><li>访存（memory）：将输入写入内存，或者从内存读出数据。读出的值为valM。</li><li>写回（write back）：最多写两个结果到寄存器文件</li><li>更新PC（PC update）：将pc设置为下一条指令的地址。</li></ul><p>图</p><p>图</p><p>整数操作指令的处理遵循上面列出的通用模式</p><p>图</p><p>rrmoq指令通用规则</p><p>irmpvq指令具体实例</p><p>图</p><p>rmmovq指令具体实例</p><p>图</p><p>mrmovq指令具体实例</p><p>图</p><p>pushq指令通用规则和实例</p><p>图</p><p>popq指令通用规则和实例</p><p>图</p><p>三类控制转移指令的处理</p><h2 id="SEQ（sequential-顺序的）硬件结构"><a href="#SEQ（sequential-顺序的）硬件结构" class="headerlink" title="SEQ（sequential,顺序的）硬件结构"></a>SEQ（sequential,顺序的）硬件结构</h2><p>图片</p><ul><li>取值：从内存读取指令的字节。PC增加器计算valp</li><li>译码：A和B是两个读端口，同时读出valA和valB</li><li>执行：ALU计算，并对条件码寄存器(CC)三个条件码位。ALU负责计算条件码的新值。这里的cnd是分支信号。</li><li>访存：内存读出或写入一个内存字。</li><li>写回：寄存器文件有两个端口。端口E用来写ALU计算出来的值，端口M用来写从数据内存中写出的值。</li><li>PC更新：PC新值选择自：valp，下一条指令的地址；valc,调用指令或跳转指令指定的目标地址；valM，从内存读取的返回地址。</li></ul><p>图</p><ul><li>白色方框表示始终寄存器。PC是SEQ中唯一的时钟寄存器。</li><li>浅蓝色方框表示硬件单元。当作黑盒子</li><li>控制逻辑块用灰色圆角矩形表示。用来从一组信号源中进行选择，或计算布尔函数。</li><li>线路的名字的白色圆圈中说明。</li><li>宽度位字长的数据连接用中等粗度的线表示。64</li><li>宽度为字节或更窄的数据连接用细线表示。</li><li>单个位的连接用虚线表示。</li></ul><p>SEQ的实现包括组合逻辑和两种存储器设备：时钟寄存器（程序寄存器和条件码寄存器），随机访问存储器(寄存器文件、指令内存和数据内存)。</p><p>所有涉及写数据的存储器就需要对时序进行明确控制。为了精准控制，遵循以下原则组织计算。</p><p>原则：从不回读：<strong>处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态</strong></p><p>例如有些指令会读取条件码，但没有指令必须既设置又读取条件码。通过寄存器和内存的时钟控制，这么做能保证即使所有状态同时更新，也能等价于顺序执行各个阶段，也保证了能在一个周期中完成一条指令。</p><p>图</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行这些指令的处理器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>csapp第三章-程序的机器级表示</title>
    <link href="https://cjay.life/2020/07/24/csapp%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <id>https://cjay.life/2020/07/24/csapp%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</id>
    <published>2020-07-24T07:07:02.000Z</published>
    <updated>2020-07-30T08:31:54.647Z</updated>
    
    <content type="html"><![CDATA[<p>机器代码，用字节序列编码低级的操作。编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。</p><a id="more"></a><h1 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假设一个C程序，有两个文件p1.c和p2.c。</span><br><span class="line">linux&gt; gcc -0g p p1.c p2.c</span><br></pre></td></tr></table></figure><p>编译选项-Og告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级。</p><p>实际上gcc命令调用了一整套程序，将源代码转化成可执行代码。</p><ol><li>C预处理器扩展源代码，插入所有用#include指令指定的文件，并扩展所有用#define声明指定的宏。</li><li>编译器产生两个源文件的汇编代码，p1.s和p2.s</li><li>汇编器将汇编代码转成二进制目标代码文件p1.o和p2.o。（目标代码是机器代码的而一种形式，包括指令的二进制表示，但还没有填入全局值的地址）</li><li>链接器将两个目标代码文件和实现库函数得代码合并，并产生最终得可执行代码文件p</li></ol><h1 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h1><p>对于机器编程来说，其中两种抽象尤为重要。</p><ol><li>指令集体系结构或指令集架构（Instruction Set Architecture,ISA）定义机器级程序得格式和行为，它定义了处理器状态，指令的格式，以及每条指令对状态的影响。但硬件层面描述复杂，它们并发执行许多指令，但可以采取措施保证整体行为与ISA指定顺序完全一致。</li><li>机器级程序使用内存地址是虚拟地址。存储器系统的实际实现是将 多个硬件存储器 和 操作系统软件 给结合起来。</li></ol><p>一些x86-64的机器代码对于C语言程序员隐藏的处理器状态都是可见的：</p><ol><li>程序计数器（PC，x86-64中用%rip表示）给除将要执行恶下一条指令在内存中的地址。</li><li>整数寄存器文件包括16个命名的地址，分别存储64位的值，可以存放地或整数数据。</li><li>条件码寄存器保存最近执行的算术或逻辑命令的状态信息。用来实现控制或条件流中的条件变化。</li><li>一组向量寄存器用来存放一个或多个整数或浮点数值。</li></ol><p>从机器代码角度看内存，内存只是一个很大的、按字节寻址的数组。</p><p>程序在内存中包括：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块。</p><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p>由于是从16位体系结构拓展成32位的，Intel用术语“字（word）”表示16位数据类型。32位“双子（double words）”。64位数为“四字（quad words）”。</p><p><img src="https://i.loli.net/2020/07/30/Lsay2w8dNQqUlbI.png" alt="1334023-20190807170430649-1604938390.png"></p><p>大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如数据传送指令有四个变种:movb(传送字节)、movw（传送字）、movl（传送双字）和movq（传送四字。）</p><h1 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h1><p>x86-84的中央处理单元（CPU）包含一组16个存储64位值的通用目的寄存器。用来存储整数数据和指针。</p><p><img src="https://i.loli.net/2020/07/30/zX4ckLaEUbd9eVf.png" alt="1334023-20190809115302856-2146181911.png"></p><p>指令可以对这16个寄存器得低位字节中存放得不同大小数据进行操作。</p><p>在常见得程序里不同得寄存器扮演不同角色。其中最特别得栈指针%rsp。用来指明运行时栈结束位置。</p><h2 id="操作器指令符"><a href="#操作器指令符" class="headerlink" title="操作器指令符"></a>操作器指令符</h2><p>大多数指令有一个或多个操作数（operand）。操作数分为三种类型。</p><ol><li>立即数(immediate)：用来表示常数值。</li><li>寄存器（register）</li><li>内存引用</li></ol><p>寻找方式也有多种。Imm（rb,ri,s）表示最常用的形式:<strong>一个立即数偏移Imm，一个基址寄存器rb，一个变址寄存器ri和一个比例因子s,s必须是1，2，4，或者8.</strong></p><p><img src="https://i.loli.net/2020/07/30/Wo5YMb7fDKLBywm.png" alt="1334023-20190809144635365-1131133860.png"></p><h2 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h2><p><img src="https://i.loli.net/2020/07/30/1KO2aN9n3roqFt6.png" alt="1334023-20190809153000104-990216913.png"></p><p>原操作数是一个立即数，存储在寄存器或内存中。目的操作数只当一个位置。</p><p><strong>x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。需要第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。</strong></p><p><strong>大部分mov指令仅仅更新目的范围内的操作数，movl指令以寄存器为目的时，它会把该寄存器的高位4字节设置为0</strong></p><p><img src="https://i.loli.net/2020/07/30/a3PGm4geExc8kbo.png" alt="1334023-20190809154255266-1023894161.png"></p><p>常规的movq指令只能以表示为32位补码数字的立即数作为原操作数，然后把这个值符号扩展得到64位，放到目的位置。<strong>movabsq指令能以任意64位，并且只能放到寄存器作为目的。</strong></p><p><img src="https://i.loli.net/2020/07/30/UnziyT9DhxmE4oH.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/30/x8MdiERTnCe72XZ.png" alt="img"></p><p>第一类零扩展数据传送，第二类符号扩展数据传送。每条指令名字的最后两个字符都是大小指示符：第一个指定源的大小，第二个指明目的大小。</p><h2 id="数据传送实例"><a href="#数据传送实例" class="headerlink" title="数据传送实例"></a>数据传送实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">long exchange(long *xp,long y)</span><br><span class="line">&#123;</span><br><span class="line">long x &#x3D; *xp;</span><br><span class="line">*xp &#x3D; y;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编</span><br><span class="line">&#x2F;&#x2F;xp in %rdi,y in %rsi,x in %rax</span><br><span class="line">exchange:</span><br><span class="line">movq(%rdi),%rax</span><br><span class="line">movq%rsi,(%rdi)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。像x这样的局部变量通常保存在寄存器中，而不是内存。访问寄存器比访问内存快许多。</p><h2 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h2><p>最后两个数据传送操作可以将数据压入程序栈中，以及从程序栈中弹出数据。</p><p><img src="https://i.loli.net/2020/07/30/NDsZzGUVE1hTap4.png" alt="img"></p><p>在x86-64中，程序栈存放在内存中某个区域。栈向下增长，栈顶元素的地址是栈中元素地址中最低的。栈指针%rsp保存着栈顶元素的地址。</p><p>将一个四字值压入栈中，首先要将栈指针减8，然后将值写到新的栈顶地址。因此，pushq %rbp 的行为等价于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub $8,%rsp&#x2F;&#x2F;Decrement stack pointer</span><br><span class="line">movq %rbp,(%rsp)&#x2F;&#x2F;store %rbp on stack</span><br></pre></td></tr></table></figure><p>区别在于pushq指令编码为1字节，上面两条一共8字节。</p><p><img src="https://i.loli.net/2020/07/30/D2Zx5RJn1ITtAB3.png" alt="img"></p><p>popq    %rax等价于下面两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movq (%rsp),%rax&#x2F;&#x2F;Read %rax from stack</span><br><span class="line">addq $8,%rsp&#x2F;&#x2F;Incremetn stack pointer</span><br></pre></td></tr></table></figure><p>因为栈其实就是内存中的一片空间，其实可以用程序访问栈内的任意位置。假设栈顶元素是四字，指令movq 8(%rsp),%rdx会将第二个四字从栈中复制到寄存器%rdx。</p><h1 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h1><p><img src="https://i.loli.net/2020/07/30/t7lTmPAco8S4YEg.jpg" alt="img"></p><p>大部分操作都分成了指令类，指令类都带不同大小操作数变种<strong>只有leaq没有</strong>。例如，ADD由四条加法指令组成：addb、addw、addl和addq。</p><p>这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。</p><h2 id="加载有效地址（load-effective-address）"><a href="#加载有效地址（load-effective-address）" class="headerlink" title="加载有效地址（load effective address）"></a>加载有效地址（load effective address）</h2><p>lea指令实际上是movq指令的变型。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令将有效地址写入到目的操作数。</p><p>这条指令可以为后面的内容引用产生指针。它还可以简洁得描述普通得算术操作。<strong>目的操作数必须是一个寄存器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">long scale(long x,long y,long z)&#123;</span><br><span class="line">long t &#x3D; x + 4*y + 12*z;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编</span><br><span class="line">&#x2F;&#x2F;x in %rdi,y in %rsi,z in %rdx</span><br><span class="line">scale:</span><br><span class="line">leaq(%rdi,%rsi,4), %rax&#x2F;&#x2F;x + 4*y</span><br><span class="line">leaq(%rdx,%rdx,2), %rdx&#x2F;&#x2F;z+2*z &#x3D; 3*z</span><br><span class="line">leaq(%rax,%rdx,4), %rax &#x2F;&#x2F;(x+4*y)+4*(3*z) &#x3D; x + 4*y + 12*z</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>leaq指令能执行加法和有限形式得乘法，在编译如上简单算术表达式时，是很有用处的。</p><h2 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h2><p>第二组操作是一元操作，操作数可以是寄存器，也可以是内存位置。</p><p>第三组是二元操作，第一个操作数可以是立即数、寄存器或是内存地址。第二个操作数可以是寄存器或者是内存位置。<strong>当第二个操作数为内存地址时，处理器必须从内存中读出值，执行操作，再把结果写回内存。</strong></p><h2 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h2><p>最后一组为移位操作，先给出位移量，第二项给出要位移的数。可以逻辑移动，也可以算术。位移量可以是一个立即数，或者放在单字节寄存器%cl中。（这些指令只允许特定的寄存器作为操作数）。位移操作对w位长的数据值进行操作，位移量是由%cl寄存器的低m位决定，2的m次 = w。</p><p>例如当寄存器%cl的十六进制值为0xFF时，指令salb会移7位，salw会移15位，sall移31位，salq移63位。移位操作的目的操作数可以是一个寄存器值或是一个内存位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">long arith(long x,long y,long z)</span><br><span class="line">&#123;</span><br><span class="line">long t1 &#x3D; x^y;</span><br><span class="line">long t2 &#x3D; z*48;</span><br><span class="line">long t3 &#x3D; t1&amp;0x0F0F0F0F;</span><br><span class="line">long t4 &#x3D; t2-t3;</span><br><span class="line">return t4;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;汇编</span><br><span class="line">&#x2F;&#x2F;x in %rdi,y in %rsi,z in %rdx</span><br><span class="line">arith:</span><br><span class="line">xorq%rsi,%rdi &#x2F;&#x2F;t1 &#x3D; x^y</span><br><span class="line">leaq(%rdx,%rdx,2),%rax&#x2F;&#x2F;3*z</span><br><span class="line">salq$4,%rax&#x2F;&#x2F;t2 &#x3D; 16*(3*z) &#x3D; 48*z</span><br><span class="line">andl$252645135,%edi&#x2F;&#x2F;t3 &#x3D; t1&amp;0x0F0F0F0F</span><br><span class="line">subq%rdi,%rax&#x2F;&#x2F;Return t2-t3</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="特殊的算术操作"><a href="#特殊的算术操作" class="headerlink" title="特殊的算术操作"></a>特殊的算术操作</h2><p>对于两个64位有符号或无符号整数相乘得到乘积需要128位来表示。Intel把16字节的数称为八字(oct word)。</p><p><img src="https://i.loli.net/2020/07/30/rphUSTxIvDWtNJ4.jpg" alt="img"></p><p>两种乘法都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器%rdx（高64位）和%rax（低64位）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">typedef unsigned __int128 unit128_t</span><br><span class="line">void store_uprod(uint128_t *dest,unit64_t x,unit64_t y)&#123;</span><br><span class="line">*dest &#x3D; x*(unit128_t)y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inttypes.h对标准C拓展的一部分，但这个标准并没有实现128位的值。只好依赖GCC提供的128位整数支持，用名字__int128声明。这段代码指明得到的乘积应该存放在指针dest指向的16字节处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dest in %rdi,x in %rsi,y in %rdx</span><br><span class="line">store_uprod:</span><br><span class="line">movq%rsi,%rax&#x2F;&#x2F;Copy x to mutiplicand</span><br><span class="line">mulq%rdx&#x2F;&#x2F;Multiply by y</span><br><span class="line">movq%rax,(%rdi)&#x2F;&#x2F;store lower 8 bytes at dest</span><br><span class="line">movq%rdx,8(%rdi)&#x2F;&#x2F;store upper 8 bytes at dest+8</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这段代码针对小端机器，所以高位字节存储在大地址。</p><p>单操作数除法指令。有符号除法指令idivl将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存在%rax中，余数存储在%rdx中。</p><p>对于64位除法来说，这个值在%rax中，%rdx的位设置为全0（无符号）或%rax的符号位（有符号）。后面这个操作由指令cqto来完成。这条指令隐含读出%rax符号位，并将它复制到%rdx所在的位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void remdiv(long x,long y,long *qp,long *rp)&#123;</span><br><span class="line">long q &#x3D; x&#x2F;y;</span><br><span class="line">long r &#x3D; x%y;</span><br><span class="line">*qp &#x3D; q;</span><br><span class="line">*rp &#x3D; r;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; x in %rdi,y in %rsi,qp in %rdx,rp in %rcx</span><br><span class="line">rediv:</span><br><span class="line">movq%rdx，%r8&#x2F;&#x2F;Copy qp</span><br><span class="line">movq%rdi,%rax&#x2F;&#x2F;Move x to lower 8 bytes of dividend</span><br><span class="line">cqto&#x2F;&#x2F;Sign-extend to upper 8 bytes of dividend</span><br><span class="line">idiq%rsi&#x2F;&#x2F;Divide by y</span><br><span class="line">movq%rax,(%r8)&#x2F;&#x2F;Store quotient at qp</span><br><span class="line">movq%rdx,(%rcx)&#x2F;&#x2F;Store remainder at rp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>首先把qp保存到另一个寄存器中（第2行），因为除法操作要使用参数寄存器%rdx。3~4准备被除数，复制并符号扩展x。</p><p>无符号除法使用divq指令。通常，寄存器%rdx会事先设置为0。</p><h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><p>C语言中的某些机构，比如条件语句、循环语句和分支语句，要求有条件的执行，根据数据测试的结果来决定操作执行的顺序。机器代码提供两种基本的低级机制来实现有条件的行为：<strong>测试数据值，然后根据测试的结果来改变控制流或者数据流。</strong></p><p>用jump指令可以改变一组机器代码指令的执行顺序，通过某个测试结果调转到程序的其他部分。</p><h2 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h2><p>除整数寄存器，CPU还维护一组单个位的条件码(condition code)寄存器。它们描述最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。常用有:</p><ul><li>CF:进位标志。最近的操作最高位产生了进位。可用来无符号操作的溢出。</li><li>ZF:零标志。最近操作结果为0.</li><li>SF:符号标志。最近的操作得到结果为负。</li><li>OF：溢出标志。最近操作导致一个补码溢出–正溢出或负溢出。</li></ul><p>leaq指令不改变任何条件码，因为它用来进行地址计算。除此之外3-10中所有指令都会设置条件码。</p><p>除了3-10中的指令会设置条件码，还有两类指令(有8，16，32和64位形式)，它们只设置条件码不改变任何其他寄存器。</p><p><img src="https://i.loli.net/2020/07/30/Oe6sWRwL82alYtp.jpg" alt="img"></p><p>CMP根据两数之差设置条件码。CMP与SUB指令的行为一样。列出操作数的顺序是相反的。</p><p>TEST指令的行为与AND指令一样，除了它们只设置条件码而不改变目的寄存器值，典型用法是，两个操作数一样（检查是 正、负还是0），或其中一个操作数是掩码，用来指示哪些位应该被测试。</p><h2 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h2><p>条件码通常不会直接读取，常用使用方法有三种:</p><ol><li>可以根据条件码的某种组合，将一个字节设置为0或1。</li><li>可以条件跳转到程序的某个其他的部分</li><li>可以有条件地传送数据</li></ol><p>对于第一种情况，有一整类指令称为SET指令。这些后缀表示不同条件而不是操作数大小，例如，指令setl和setb表示“小于时设置（set less）”和“低于时设置（set below）”，而不是“设置长字“set long word”和“set byte”。</p><p>一条set指令的目的操作数是低位单字节寄存器运算之一，或是一个字节的内存位置，指令会将这个字节设置成0或者1。</p><p><img src="https://i.loli.net/2020/07/30/WZJgbXfSmYEjxsT.png" alt="img"></p><p>一个计算C语言表达式a&lt;b的经典指令序列如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; int comp(data_t a,data_t b)</span><br><span class="line">&#x2F;&#x2F; a in %rdi,b in %rsi</span><br><span class="line">comp:</span><br><span class="line">cmpq%rsi,%rdi&#x2F;&#x2F;Compare a:b</span><br><span class="line">setl%al&#x2F;&#x2F;Set low-order byte of %eax to 0 or 1</span><br><span class="line">    movzbl%al,%eax&#x2F;&#x2F;Clear rest of %eax(and rest  of %rax)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>cmp指令参数虽然是先b后a，但其实是a:b。</p><p>movzbl指令不仅会把%eax的高3个字节清零，还会把整个寄存器%rax的高4个字节清零。</p><p>某些底层的机器指令可能有多个名字，称之为“同义词（synonym）”</p><p>各个SET命令的描述都适用的情况是：执行比较指令，根据计算t=a-b设置条件码。</p><p>不像C语言，机器代码不会将每个程序值和一个数据类型联系起来。<strong>大多数情况下，机器代码对有符号和无符号两种情况都使用一样的指令，这是因为许多算术运算对无符号和补码算术都有一样的位级行为。但也有些情况需要不同指令来处理有符号和无符号操作，例如，使用不同版本的右移、除法和乘法指令，以及不同条件码组合。</strong></p><h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h2><p>jump指令会导致执行切换到程序中一个全新的位置。跳转目的由标号（label）指明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movq $0,%rax&#x2F;&#x2F; set %rax to 0</span><br><span class="line">jmp .L1&#x2F;&#x2F; Goto .L1</span><br><span class="line">movq (%rax),%rdx&#x2F;&#x2F; Null pointer dereference(skipped)</span><br><span class="line">.L1:</span><br><span class="line">popq %rdx&#x2F;&#x2F;jump target</span><br></pre></td></tr></table></figure><p>在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令地址）编码为跳转指令的一部分。</p><p><img src="https://i.loli.net/2020/07/30/uIERk64tpmAQ7cB.jpg" alt="img"></p><p>jmp指令是无条件跳转。可以是直接跳转(跳转目标作为指令一部分编码)，也可以是间接跳转(从寄存器或内存位置读出的)。直接跳转给出一个标号为目标，间接跳转写法是“*”后跟操作数指示符。</p><p>其他跳转指令都是有条件的，或者跳转或者执行下一条指令。<strong>条件跳转只能是直接跳转</strong></p><h2 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h2><p>跳转指令有几种不同的编码，但最常用的都是PC相对的（PC-relative）就是将目标指令地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这个偏移量可以编码为1，2或4字节。第二种编码方式是给出“绝对”地址，用4个字节直接指定目标。汇编器与链接器会选择适当的跳转目的编码。</p><h2 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h2><p>C语言中的if-else语句的通用形式模板如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(text-expr)</span><br><span class="line">then-statement</span><br><span class="line">else</span><br><span class="line">else-statement</span><br></pre></td></tr></table></figure><p>这里test-expr是一个整数表达式，取值为0或非0,两个分支语句只会执行一个。</p><p>对于这种通用形式，汇编实现通常使用下面这种形式。用C语言来描述控制流：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t &#x3D; text-expr</span><br><span class="line">if(!t)</span><br><span class="line">goto false;</span><br><span class="line">then-statement</span><br><span class="line">goto done;</span><br><span class="line">false:</span><br><span class="line">else-statement;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>汇编器为then-statement和else-statement产生各自的代码块。它会插入条件和无条件分支，以保证执行正确的代码块。</p><h2 id="用条件传送来实现条件分支"><a href="#用条件传送来实现条件分支" class="headerlink" title="用条件传送来实现条件分支"></a>用条件传送来实现条件分支</h2><p>使用<strong>控制的条件转移</strong>这种机制简单而通用，但在现在处理器上，有点低效。一种替代的策略是使用<strong>数据的条件转移。</strong>这种方法计算一个条件操作的两种结果，然后再根据条件是否满足选取一个。只在受限制的情况中，这种策略可行，如果可行就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性。</p><p>为何条件数据传送的方式比较快?</p><p>处理器使用流水线（pipelining）来获得高性能，而这需要提前确定要执行的指令序列，当机器遇到条件跳转（也称为“分支”）时，只有当分支条件求值完成时，才能决定走哪个分支。处理器采用分支预测逻辑来推测每条跳转指令是否执行。只要预测可靠(现代处理器设计试图达到90%的成功率)，指令流水线就可以充满指令。若预测失败，处理器就要丢掉它为该跳转指令后的所有工作，然后再从正确位置处起始的指令去填充流水线。一次预测失误，会浪费15~30个时钟周期。</p><p><img src="https://i.loli.net/2020/07/30/f8Zmr3eqWSko7Xx.png" alt="img"></p><p>每条指令有两个操作数:源寄存器或者内存地址S，和目的寄存器R。源和目的值可以是16位、32位或64位长。<strong>不支持单字节的条件传送。</strong></p><p>汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度，所以对所有的操作数长度，到可以使用同一个的指令名字。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v &#x3D; test-expr ? the-expr:else-expr;</span><br></pre></td></tr></table></figure><p>条件控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(!text-pr)</span><br><span class="line">goto false;</span><br><span class="line">v &#x3D; then-expr;</span><br><span class="line">goto done;</span><br><span class="line">false:</span><br><span class="line">v &#x3D; else-expr;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>条件传送：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v &#x3D; then-expr;</span><br><span class="line">ve &#x3D; else-expr;</span><br><span class="line">t &#x3D; test-expr;</span><br><span class="line">if(!t) v &#x3D; ve;</span><br></pre></td></tr></table></figure><p>不是所有条件表达式都可以用条件出传送来编译，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long cread(long *xp)&#123;</span><br><span class="line">return (xp?*xp:0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xp in %rdi</span><br><span class="line">cread:</span><br><span class="line">movq(%rdi),%rax;&#x2F;&#x2F;v &#x3D; *xp</span><br><span class="line">test%rdi,%rdi&#x2F;&#x2F;Test &#x3D; x</span><br><span class="line">movl$0,%edx&#x2F;&#x2F;Set ve &#x3D; 0</span><br><span class="line">cmove%rdx,%rax&#x2F;&#x2F;if(x&#x3D;&#x3D;0) v &#x3D; ve</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>不过，这个实现是非法的，因为计时当测试为假，movq指令对xp的间接引用还是发生了，导致了间接引用空指针的错误。</p><p>所以如果两个表达式中的任意一个可能产生错误条件或者副作用，就会导致非法行为。</p><p>如果then-expr或者else-expr部分很麻烦，用条件传送传送也不适合，所以各有各的优点。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>C语言提供多种循环结构，即do-while、while和for。汇编中没有相应的指令存在，可以用条件测试和跳转组合起来实现循环的效果。</p><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h3><p>通用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">body-statement</span><br><span class="line">while(test-expr)</span><br></pre></td></tr></table></figure><p>可以看见，body-statement至少执行一次</p><p>翻译如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">body-statement</span><br><span class="line">t &#x3D; test-expr</span><br><span class="line">if(t)</span><br><span class="line">goto loop</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>通用形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while(text-expr)</span><br><span class="line">body-statement</span><br></pre></td></tr></table></figure><p>这个有两种翻译方法</p><h4 id="跳转到中间（jump-to-middle）"><a href="#跳转到中间（jump-to-middle）" class="headerlink" title="跳转到中间（jump to middle）"></a>跳转到中间（jump to middle）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goto test;</span><br><span class="line">loop:</span><br><span class="line">body-statement</span><br><span class="line">test:</span><br><span class="line">t &#x3D; test-expr;</span><br><span class="line">if(t)</span><br><span class="line">goto loop;</span><br></pre></td></tr></table></figure><h4 id="guarded-do"><a href="#guarded-do" class="headerlink" title="guarded-do"></a>guarded-do</h4><p>当采用较高优化等级编译时，会采用这种策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t &#x3D; test-expr;</span><br><span class="line">if(!t)</span><br><span class="line">goto done;</span><br><span class="line">do</span><br><span class="line">body-statement</span><br><span class="line">while(test-expr)</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>把它翻译成goto代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t &#x3D; text-expr;</span><br><span class="line">if(!t)</span><br><span class="line">goto done;</span><br><span class="line">loop:</span><br><span class="line">body-statement</span><br><span class="line">t &#x3D; text-expr;</span><br><span class="line">if(t)</span><br><span class="line">goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>通用形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(init-expr; test-expr;update-expr)</span><br><span class="line">body-statement</span><br></pre></td></tr></table></figure><p>这个行为与while代码行为一样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">while(text-expr)&#123;</span><br><span class="line">body-statement;</span><br><span class="line">update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GCC也对应两种翻译</p><h4 id="跳转到中间策略"><a href="#跳转到中间策略" class="headerlink" title="跳转到中间策略"></a>跳转到中间策略</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">goto test;</span><br><span class="line">loop:</span><br><span class="line">body-statement</span><br><span class="line">update-expr;</span><br><span class="line">test:</span><br><span class="line">t&#x3D; text-expr;</span><br><span class="line">if(t)</span><br><span class="line">goto loop;</span><br></pre></td></tr></table></figure><h4 id="guarded-do-1"><a href="#guarded-do-1" class="headerlink" title="guarded-do"></a>guarded-do</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">t &#x3D; test-expr;</span><br><span class="line">if(!t)</span><br><span class="line">goto done;</span><br><span class="line">loop:</span><br><span class="line">body-statement</span><br><span class="line">update-expr;</span><br><span class="line">t &#x3D; text-expr;</span><br><span class="line">if(t)</span><br><span class="line">goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><p>switch(开关)语句可以根据一个整数索引值进行多重分支（mutiway branching）。这种语句通过使用跳转表（jump table）这种数据结构使得实现更加高效。跳转表是一个数组，表项i是一个代码段的地址，这个地址段实现当开关索引值等于i时程序应该采取的动作。</p><p>与很长的if-else语句相比，使用跳转表的优先是执行开关语句的时间与开关情况的数量无关。GCC根据开关情况的数量和开关情况值得稀疏程度来翻译开关语句。当开关情况比较多（例如4个以上），并且值得范围跨度很小时，就会使用跳转表。</p><p><img src="https://i.loli.net/2020/07/30/XgYcP7zrpLN2mo6.png" alt="img"></p><p>b代码采用了GCC提供的对跳转表的支持，这是对C语言的拓展，GCC的作者创造了新的运算符&amp;&amp;,这个运算符创建了一个指向代码位置的指针。</p><p><img src="https://i.loli.net/2020/07/30/7i3tH1SCWIM9R52.png" alt="img"></p><p>汇编器首先将n减去100，把取值范围移到0和6之间，创建新变量index，<strong>补码表示的负数会被映射成符号位表示的大正数，利用这事实，将index看作无符号数，从而进一步简化分支的可能性。通过测试index是否大于6来判定index是否在0~6范围之外。</strong></p><p>执行switch语句的关键步骤是通过跳转表来访问代码位置。C代码16行，一条goto语句引用跳转表jt。在汇编代码中，类似操作在第5行，jmp指令操作数有前缀”*”,表明是间接跳转，操作数指定一个内存位置，索引由%rsi给出，这个寄存器保存index的值。</p><p>在汇编代码中，跳转表用以下申明表示:</p><p><img src="https://i.loli.net/2020/07/30/h8IOwiZR3DeplNy.jpg" alt="img"></p><p>这些申明表明，在叫做“.rodata“（只读数据，Read-Only Data）的目标代码文件的段中，应该有一组7个”四“字（8个字节），每个字的的值都是与指定的汇编代码标号（例如.L3）相关联的指令地址。标号.L4标记出这个分配地址的起始，与这个标号相对应的地址会作为间接跳转（第5行）的基地址。</p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>过程是软件一种重要抽象。它提供一种封装代码的方式。不同编程语言中，过程的形式多样：函数（function）、方法(method)、子例程（subroutine）、处理函数（handler）等等，但它们具备共性。</p><p>假设过程P调用过程Q，Q执行后返回P。这些动作包括一个或多个机制。</p><ul><li>传递控制。进入进程Q时，PC必须被设置为Q的代码的起始位置，返回时，PC为P调用Q后那条指令的地址。</li><li>传递数据。P必须向Q提供一个或多个参数，Q必须能向P返回一个值。</li><li>分配和释放内存。在开始时，Q可能需要为局部变量分配空间，返回时，又必须释放这些空间。</li></ul><h2 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h2><p>C语言过程调用机制的一个关键特性（大多数其他语言也是如此）在于使用了栈数据结构提供的后进先出的内存管理原则。Q执行中，P以及所有在向上追溯到P的调用链的过程，都暂时被挂起。Q运行时，它只需要为局部变量分配新的存储空间。Q返回时，它局部存储空间都被释放。程序可以用栈来管理它的过程所需要的存储空间。栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。</p><p><img src="https://i.loli.net/2020/07/30/6aB2VvWqzl7oKL9.png" alt="img"></p><p>x86-64的栈向低地址方向增长，而栈指针%rsp指向栈顶元素。可以用pushq和popq指令将数据存入或取出。</p><p>当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧（stack fram）。</p><p>过程P调用过程Q时，会把返回地址压入栈中，指明当Q返回时，要从P程序的哪个位置继续执行。Q代码会拓展栈的边界，分配它栈帧所需空间。这个空间中，可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。</p><p>大多数过程帧都是定长的，在开始就分配好了。但有些过程需要变长的帧。例如通过寄存器，过程P可以传递最多6个整数值，但如果Q需要更多参数，P可以在调用Q之前在自己的栈帧里存储这些参数。</p><p>例如，所有参数都可以用寄存器传递。图中某些栈帧部分可以省略。而且有些过程都不需要栈帧，当所有局部变量都可以保存在寄存器中，而且该函数都不调用其他函数(称为叶子过程，次数把过程调用看成树结构)，就可以这样处理。</p><h2 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h2><p>将控制从函数P转到函数Q只需要简单把PC设置为Q的代码的其实位置。当稍后从Q返回的时候，处理器必须记录好它需要继续P的执行的代码位置。这个信息用指令call Q调用过程Q来记录。<strong>call指令把地址A（返回地址：紧跟在call指令后那条指令的地址）压入栈，并将PC设置为Q的起始地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A。</strong></p><p>call指令分为 两种：</p><ul><li>直接调用（标号）</li><li>间接调用（*后面跟一个操作数指示符）</li></ul><p>例子：P166</p><h2 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h2><p>过程调用还包括数据作为参数传递，从过程返回还可能包含返回的值。大部分都是通过寄存器实现。</p><p>x86-64中，可以通过寄存器最多传递6个整型参数。寄存器使用有特殊顺序，使用的名字取决于传递的数据类型的大小。</p><p><img src="https://i.loli.net/2020/07/30/NduBQ9oxr6wIWhH.png" alt="img"></p><p>如果大于6个参数，多余就用栈传递。1<del>6复制到对应的寄存器，把参数7</del>n放到栈上， 而参数7位于栈顶。通过栈传递参数，数据大小向8的倍数对齐。</p><p><img src="https://i.loli.net/2020/07/30/EvMRS1moP8OcY5Z.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/30/X3mpRwj9qUCl1eQ.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/30/9YDsEiZuGVxIy62.png" alt="img"></p><h3 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h3><p>有时局部数据必须存放在内存中，常见情况：</p><ul><li>寄存器不足够存放所有本地数据</li><li>对一个局部变量使用地址运算符’&amp;’，因此必须为它产生一个地址。</li><li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到</li></ul><p><img src="https://i.loli.net/2020/07/30/tBwzKNpqYaIXDMk.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/30/AGQOeztxXEbWqaK.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/30/AGQOeztxXEbWqaK.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/30/jUFANuIDrfM8Et9.png" alt="img"></p><h2 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h2><p>寄存器是共享资源，我们必须保证一个进程(调用者)调用另一个过程（被调用者）时，被调用者不会覆盖调用者稍后会使用的寄存器值。x86-64使用了一组统一的寄存器使用惯例，所有过程都必须遵循。</p><p><strong>惯例，寄存器%rbx、%rbp和%r12~%r15被划分为被调用者保存寄存器</strong>。P调用Q，Q必须保存这些寄存器的值，保证到时候返回时一样的。</p><p>过程Q要不保存，要不根本就不去改变。可以选择把原始值压入栈中，然后在返回时弹出改回去。压入的值会在栈中创建标号为“保存的寄存器”一部分。</p><p><strong>所有其他的寄存器，除了栈指针%rsp，都分类为调用者保存寄存器。</strong></p><p><img src="https://i.loli.net/2020/07/30/cdyisBH6SRTjrgo.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/30/B7WsmntIjbyVFer.png" alt="img"></p><h2 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h2><p><img src="https://i.loli.net/2020/07/30/iXpUYsxnOMvH6zP.png" alt="img"></p><p>该汇编代码用寄存器%rbx保存n，先把已有值保存到栈上（第2行）,随后在返回时恢复该值（第11行）。每次调用rfact(n-1)结果在%rax中。</p><h1 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h1><h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><p>C语言可以产生指向数组中元素的指针，并对指针运算。在机器代码中，这些指针会被翻译成地址运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T A[N]</span><br></pre></td></tr></table></figure><p>这个申明有两个效果。</p><ul><li>内存中分配一个L*N字节的连续区域。</li><li>引入标识符A，用A来表示指向数组开头的指针。</li></ul><p>元素i会被存放在地址xA+L*i的地方。</p><p>x86-64可以用内存引用指令来简化数组访问。例如，E是一个int型的数组，而我们想计算E[i]，E的地址存放在寄存器%rdx中，i存放在%rcx中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl (%rdx,%rcx,4),%eax</span><br></pre></td></tr></table></figure><h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><p>P是一个指向类型为T的数据的指针，p的值为xp，那么表达式p+i的值为xp+L*i,这里L是数据类型T的大小。</p><h2 id="嵌套的数组"><a href="#嵌套的数组" class="headerlink" title="嵌套的数组"></a>嵌套的数组</h2><p>声明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int A[5][3];</span><br></pre></td></tr></table></figure><p>等价于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef int row3_t[3];</span><br><span class="line">row3_t A[5];</span><br></pre></td></tr></table></figure><p>数组元素在内存中按照“行优先”的顺序排序。</p><p>对于数组：T D[R][C];</p><p>数组元素D[i][j]的内存地址为：&amp;D[i][j] = xd + L（C*i+j）；</p><p>将A[i][j]复制到寄存器%eax中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A in %rdi,i in %rsi,and j in %rdx</span><br><span class="line">leaq (%rsi,%rsi,2),%rax &#x2F;&#x2F;compute 3i</span><br><span class="line">leaq (%rdi,%rax,3),%rax&#x2F;&#x2F;compute 12i</span><br><span class="line">movl (%rax,%rdx,4),%eax &#x2F;&#x2F;Read from M[xa+12i+4j]</span><br></pre></td></tr></table></figure><h2 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h2><p>C语言编译器能优化定长多维数组上的操作代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define N 16</span><br><span class="line">typedef int fix_matrix[N][N];</span><br></pre></td></tr></table></figure><p>它去掉了整数索引j，并把所有的数组引用都换成了指针间接引用。</p><h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>C语言只支持大小在编译时就能确定的多维数组（对第一维可能有些例外）。程序员需要变长数组时不得不用malloc或calloc这样的函数为这些数组分配存储空间。</p><p>ISOC99引入一种功能，运行数组的维度是表达式，在数组被分配的时候再计算出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int A[expr1][expr2]</span><br></pre></td></tr></table></figure><p>访问n*n数组的元素i,j,我们可以写一个如下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int var_ele(long n,int A[N][N],long i,long j)&#123;</span><br><span class="line">return A[i][j]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数n必须再参数A[n][n]之前，这样函数就可以遇到这个数组的时候计算出数组的维度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n in %rdi,A in %rsi,i in %rdx,j in %rcx</span><br><span class="line">var_ele:</span><br><span class="line">imlq%rdx,%rdi &#x2F;&#x2F;compute n*i</span><br><span class="line">leaq(%rsi,%rdi,4),%rax&#x2F;&#x2F;compute xa+4(n*i))</span><br><span class="line">movl(%rax,%rcx,4),%eax&#x2F;&#x2F;read from M[xa+4*(n*i)+4j]</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>跟定长数组的地址计算不同在于:</p><ul><li>增加了参数n,寄存器的使用变化了</li><li>用了乘法指令计算n<em>i，而不是用leaq指令计算3\</em>i</li></ul><p>动态版本必须用乘法指令伸缩n倍，而不能用一系列移位和加法。这会导致严重性能处罚。</p><p><img src="https://i.loli.net/2020/07/30/HacQhKNFtJxV5uy.png" alt="img"></p><p>生成代码会避免直接引用等式&amp;D[i][j] = xd + L(C*i+j)会导致的乘法。</p><h1 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h1><p>C语言提供两种将不同类型的对象组合到一起创建数据类型的机制：结构(structure),将多个对象集合到一个单位中；联合(union),用关键字union来声明，允许用不同的类型来引用一个对象。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>指向结构的指针就是结构第一个字节的地址。</p><p>看下面的结构声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct rec&#123;</span><br><span class="line">int i;</span><br><span class="line">int j;</span><br><span class="line">omt a[2];</span><br><span class="line">int *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设struct rec*类型的变量r放在寄存器%rdi中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r in %rdi</span><br><span class="line">movl (%rdi),%eax&#x2F;&#x2F;Get r-&gt;i</span><br><span class="line">movl %eax,4(%rdi)&#x2F;&#x2F;store in r-&gt;j</span><br></pre></td></tr></table></figure><p>结构的各个字段的选取完全是在编译时处理的，机器代码不包含关于字段声明或字段名字的信息。</p><h2 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h2><p>可以用不同字段来引用相同的内存块。这种方式规避C语言的类型系统。</p><p>联合的一种引用情况是，对一个数据结构中的两个不同字段的使用是互斥的，那可以声明为联合，这样可以减少分配空间的总量。</p><p>还有一种情况用来不同数据类型的位模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned long u &#x3D; (unsigned long) d;</span><br></pre></td></tr></table></figure><p>这种情况下u的位模式与d的位模式是不一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned long double2bits(double d)&#123;</span><br><span class="line">union&#123;</span><br><span class="line">double d;</span><br><span class="line">unsigned long u;</span><br><span class="line">&#125;temp;</span><br><span class="line">temp.d &#x3D; d;</span><br><span class="line">return temp.u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样u和d会有一样的位表示。</p><h2 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h2><p>许多计算机对基本数据类型的合法地址都做了一些限制，要求地址必须是k的倍数。对齐限制简化硬件设计。例如处理器一次往内存取8字节，则地址必须要是8的倍数，否则就要取两次。</p><p>无论是否对齐，x86-64都能工作。不过对齐提高性能。</p><h1 id="在机器级程序中将控制与数据结合起来"><a href="#在机器级程序中将控制与数据结合起来" class="headerlink" title="在机器级程序中将控制与数据结合起来"></a>在机器级程序中将控制与数据结合起来</h1><h2 id="理解指针"><a href="#理解指针" class="headerlink" title="理解指针"></a>理解指针</h2><p>指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值。例如p是一个char<em>类型的指针，它的值为p，那么表达式(int</em>)p+7计算为p+28，而（int*)(p+7)计算为p+7。</p><h2 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h2><p>C对数组引用不进行边界调查，而且局部变量和状态信息都在栈中。这就有可能导致写操作直接写到栈中，破坏原有数据。</p><p>一种特别常见的状态破坏被称为缓冲区溢出（buffer overflow）</p><p>gets函数的问题是它没有颁发确定是否为保存整个字符串分配了足够的康健。若将缓冲区设置得很小，若读入这个长度就会越界。</p><p>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种通过计算机网络攻击系统安全的方法。输入给程序一个字符串，这个字符串包括一些可执行代码的文件编码，称为攻击代码（exploit code）,另外还有一些字节会用一个指向攻击代码的指针覆盖返回地址。</p><h2 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h2><h3 id="栈随机化"><a href="#栈随机化" class="headerlink" title="栈随机化"></a>栈随机化</h3><p>使得栈的位置在程序每次运行时都有变化。实现方式：程序开始时，在栈上分配一段0~n字节之间的随机大小的空间。程序不适用这段抗击那，但会使后续栈位置发生改变。</p><h3 id="栈破坏检测"><a href="#栈破坏检测" class="headerlink" title="栈破坏检测"></a>栈破坏检测</h3><p><img src="https://i.loli.net/2020/07/30/Dlmoi3k1SIgwutM.jpg" alt="img"></p><p>最新GCC版本在产生的代码中加入一种栈保护者（stack protector）机制，来检测缓冲区越界。其思想是在栈帧任何局部缓冲区与栈状态之间存储一个特殊的金丝雀(canary)值，也称为哨兵值（guard value）。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被改变了，如果是，程序异常终止。</p><h3 id="限制可执行代码区域"><a href="#限制可执行代码区域" class="headerlink" title="限制可执行代码区域"></a>限制可执行代码区域</h3><h2 id="支持变长栈帧"><a href="#支持变长栈帧" class="headerlink" title="支持变长栈帧"></a>支持变长栈帧</h2><p><img src="https://i.loli.net/2020/07/30/J4jLmGx3TRCsuzM.png" alt="img"></p><p>函数声明n个指针的局部数组，这里n可变，要求在栈上分配8n个字节。此外还有一个对局部变量i的地址引用，因此i必须在栈中。</p><p>为了管理边长栈帧，x86-64代码使用寄存器%rbp作为栈指针（frame pointer，也称为 base pointer,也是bp由来）。</p><p><img src="https://i.loli.net/2020/07/30/EwFA8UtTQlZ12J9.png" alt="img"></p><p>保存%rbp之前的值到栈中，因为%rbp是一个被调用者保存寄存器。</p><h1 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h1><p>处理器的浮点体系结构有多个方面：</p><ul><li>如何存储和访问浮点数值。通常是通过某种寄存器方式完成</li><li>对浮点数操作的指令</li><li>向函数传递浮点数参数和从函数返回浮点数结果的规则</li><li>函数调用过程中保存寄存器的规则</li></ul><p>SIMD：对多个不同的数据采用并行执行同一个操作。</p><h2 id="浮点传送和转换操作"><a href="#浮点传送和转换操作" class="headerlink" title="浮点传送和转换操作"></a>浮点传送和转换操作</h2><p><img src="https://i.loli.net/2020/07/30/cT8jGLvfow7HaZb.jpg" alt="img"></p><p>指令名字中的字母’a’表示“aligned（对齐的）”</p><p>下两张图里的格式转换指令都是对单个数据值进行操作的标量指令。</p><p><img src="https://i.loli.net/2020/07/30/oncrPBICAm9fiSj.jpg" alt="img"></p><p><img src="https://i.loli.net/2020/07/30/QpM2WPD8v3c4uxY.jpg" alt="img"></p><p>3-48中的指令有两个源和一个目的，第二个操作数的值只会影响结果的高位字节。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcvtsi2sdq %rax,%xmm1,%xmm1</span><br></pre></td></tr></table></figure><p>从%rax中读出长整数，转换成double，放进xmm1低字节中</p><h2 id="过程中的浮点代码"><a href="#过程中的浮点代码" class="headerlink" title="过程中的浮点代码"></a>过程中的浮点代码</h2><p>x86-64中，XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值。</p><ul><li>XMM寄存器%xmm0~%xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器。通过栈传递额外的浮点参数。</li><li>函数使用寄存器%mm0来返回浮点值。</li><li>所有xmm寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中的任意一个。</li></ul><h2 id="浮点运算操作"><a href="#浮点运算操作" class="headerlink" title="浮点运算操作"></a>浮点运算操作</h2><p><img src="https://i.loli.net/2020/07/30/i2LmNbPfqRu3a61.png" alt="img"></p><p>第一个源操作数s1可以是xmm寄存器或内存位置。第二个源操作数和目的操作数都必须是XMM寄存器。每个操作都有针对单精度的指令和针对双精度的指令。</p><h2 id="定义和使用浮点常数"><a href="#定义和使用浮点常数" class="headerlink" title="定义和使用浮点常数"></a>定义和使用浮点常数</h2><p>浮点操作不能以立即数值作为操作数。对于立即数，编译器必须为所有常量值分配和初始化存储空间。然后代码在把这些值从内存读入。</p><h2 id="在浮点代码中使用位级操作"><a href="#在浮点代码中使用位级操作" class="headerlink" title="在浮点代码中使用位级操作"></a>在浮点代码中使用位级操作</h2><h2 id="浮点数比较"><a href="#浮点数比较" class="headerlink" title="浮点数比较"></a>浮点数比较</h2><p>类似于CMP指令，与cmpq一样，都是反序列出操作数的ATT格式管理。S2必须在XMM寄存器中，S1可以在XMM寄存器中，也可以在内存中。</p><p>浮点比较指令会设置三个条件码：零标志位ZF、进位标志位CF和奇偶标志位PF。当两个操作数任一个是NAN时，会设置PF位。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器代码，用字节序列编码低级的操作。编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后GCC调用汇编器和链接器，根据汇编代码生成可执行的机器代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>排序算法的比较</title>
    <link href="https://cjay.life/2020/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://cjay.life/2020/07/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83/</id>
    <published>2020-07-21T09:06:35.000Z</published>
    <updated>2020-07-21T13:42:47.833Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic2.zhimg.com/80/v2-88e47948380615b5adb6e7c313a916e5_1440w.jpg" alt="浙江大学-数据结构-算法排序的比较-10.4.1 - 知乎"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-88e47948380615b5adb6e7c313a916e5_1440w.jpg&quot; alt=&quot;浙江大学-数据结构-算法排序的比较-10.4.1 - 知乎&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基数排序</title>
    <link href="https://cjay.life/2020/07/21/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/21/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-21T08:02:39.000Z</published>
    <updated>2020-07-29T15:04:26.969Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>假设我们有N个学生，他们的成绩是0到100之间的整数（于是有M=101个不同的成绩值）。如何在线性时间内将学生按成绩排序?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Bucket_Sort(ElementType A[], int N)</span><br><span class="line">&#123;</span><br><span class="line">count[]初始化;</span><br><span class="line">while(读入1个学生成绩grade)</span><br><span class="line">将该生插入count[grade]链表;</span><br><span class="line">for(i&#x3D;0;i&lt;M;i++)&#123;</span><br><span class="line">if(count[i])</span><br><span class="line">输出整个count[i]链表;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;T(N,M) &#x3D; O(M+N)</span><br></pre></td></tr></table></figure><p>若M&gt;&gt;N该怎么办?</p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>假设我们有N=10个整数，而M = 1000个不同的值。还有可能在线性时间内排序吗？</p><p>这里M已经等于了，N的三次方了。</p><p>可以采用“次位优先”(Least Significant Dighit),T = O(P(N+B)) (P为趟数，B等价于上面的B)</p><h1 id="多关键字的排序"><a href="#多关键字的排序" class="headerlink" title="多关键字的排序"></a>多关键字的排序</h1><p>例如扑克牌排序问题，用主位优先（Most Signficant Digit）排序：为花色建4个桶。</p><p>在每个桶内分别排序，最后合并结果。</p><p>若用次位优先排序:为面值建13个桶，将结果合并，然后再为花色建四个桶。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;桶排序&quot;&gt;&lt;a href=&quot;#桶排序&quot; class=&quot;headerlink&quot; title=&quot;桶排序&quot;&gt;&lt;/a&gt;桶排序&lt;/h1&gt;&lt;p&gt;假设我们有N个学生，他们的成绩是0到100之间的整数（于是有M=101个不同的成绩值）。如何在
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>表排序</title>
    <link href="https://cjay.life/2020/07/19/%E8%A1%A8%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/19/%E8%A1%A8%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-19T09:51:11.000Z</published>
    <updated>2020-07-29T15:04:37.759Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><ul><li>简介排序</li></ul><p>定义一个指针数组作为”表”（table)</p><p>如果要求按顺序输出，则输出：</p><p>A[table[0]],A[table[1]]…A[table[N]]</p><h1 id="物理排序"><a href="#物理排序" class="headerlink" title="物理排序"></a>物理排序</h1><p>N个数字的排序由由若干个独立的环组成</p><p>Temp = f</p><p>如何判断一个环的结束？</p><p>if（table[i]== i）(前提是每移动一本书，将就table改为A下标)</p><h1 id="物理排序复杂度分析"><a href="#物理排序复杂度分析" class="headerlink" title="物理排序复杂度分析"></a>物理排序复杂度分析</h1><p>最好情况：初始即有序</p><p>最坏情况：</p><ul><li>有N/2个环，每个环2个元素</li><li>需要3*（N/2）次元素移动(a-&gt;tmp,b-&gt;a,b-&gt;tmp）</li></ul><p>T = O(mN),m是每个A元素的复制时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;算法概述&quot;&gt;&lt;a href=&quot;#算法概述&quot; class=&quot;headerlink&quot; title=&quot;算法概述&quot;&gt;&lt;/a&gt;算法概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;简介排序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义一个指针数组作为”表”（tabl
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://cjay.life/2020/07/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-19T09:33:13.000Z</published>
    <updated>2020-07-29T15:04:43.879Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h1><p>什么是快速排序算法的最好情况？</p><p>每次正好中分    T(N) = O(NlogN)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Quicksort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">pivot &#x3D; 从A[]中选一个主元;</span><br><span class="line">将S &#x3D; &#123;A[]\pivot&#125; 分成2个独立子集:</span><br><span class="line">A1 &#x3D; &#123;a∈S | a ≤ pivot&#125; 和 A2 &#x3D; &#123;a∈S | a ≥ pivot&#125;;</span><br><span class="line">A[] &#x3D; Quicksort(A1,N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2,N2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选主元"><a href="#选主元" class="headerlink" title="选主元"></a>选主元</h1><p>若选主元每次选择A[0]?</p><p>可能会产生下列情况：</p><p>1 2 3 4 5 6 … N</p><p>   2 3 4 5 6 … N</p><p>​      3 4 5 6 … N</p><p>T(N) = O(N) + T(N-1)</p><p>​        = O(N) + O(N-1) + T(N-2)</p><p>​        = O(N2)</p><p>这里距离一种选主元的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ElementType Median3(ElementType A[],int Left,int Right)</span><br><span class="line">&#123;</span><br><span class="line">int Center &#x3D; ([Left+Right)&#x2F;2;</span><br><span class="line">if(A[Left] &gt; A[Center])</span><br><span class="line">Swap(&amp;A[Left],&amp;A[Center]);</span><br><span class="line">if(A[Left] &gt; A[Right])</span><br><span class="line">Swap(&amp;A[Left],&amp;A[Right]);</span><br><span class="line">if(A[Center]&gt;A[Right])</span><br><span class="line">Swap(&amp;A[Center],&amp;A[Right]);</span><br><span class="line"></span><br><span class="line">Swap(&amp;A[Center],&amp;A[Right-1]);&#x2F;&#x2F;将pivot藏到右边</span><br><span class="line">&#x2F;&#x2F;接下来只需要考虑A[left+1]...A[Right-2]</span><br><span class="line">return A[Right-1]&#x2F;&#x2F;返回pivot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子集划分"><a href="#子集划分" class="headerlink" title="子集划分"></a>子集划分</h1><p>如果有元素正好等于pivot怎么办？</p><ul><li>停下来交换</li><li>不理它，继续移动指针</li></ul><p>第一种方式，优势是最后位置会被移动到靠中的位置，劣势是会有无用的交换</p><p>第二种方式，优势是不用进行无用交换，但劣势会移动到一端去。</p><p>综合起来，还是第一种方式比较好</p><h1 id="小规模数据的处理"><a href="#小规模数据的处理" class="headerlink" title="小规模数据的处理"></a>小规模数据的处理</h1><p>因为快速排序采用递归，所以需要不断压栈出栈，对于N不到100的情况，可能还不如插入排序快。</p><p>解决方案：当数据规模充分小，直接简单排序（比如插入排序)</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Quicksort(ElementType A[],int Left,int Right)&#123;</span><br><span class="line">if(Cutoff &lt;&#x3D; Right-Left)&#123;</span><br><span class="line">Pivot &#x3D; Median3(A,Left,Right);</span><br><span class="line">i &#x3D; Left; j &#x3D; Right-1;</span><br><span class="line">for(;;)&#123;</span><br><span class="line">while(A[++i]&lt;Pivot)&#123;&#125;</span><br><span class="line">while(A[--j]&gt;Pivot)&#123;&#125;</span><br><span class="line">if(i&lt;j)</span><br><span class="line">Swap(&amp;A[i],&amp;A[j]);</span><br><span class="line">else break;</span><br><span class="line">&#125;</span><br><span class="line">Swap(&amp;A[i],&amp;A[Right-1]);</span><br><span class="line">Quicksort(A,Left,i-1);</span><br><span class="line">Quicksort(A,i+1,Right);</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">Insertion_Sort(A+Left,Right-Left+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;算法概述&quot;&gt;&lt;a href=&quot;#算法概述&quot; class=&quot;headerlink&quot; title=&quot;算法概述&quot;&gt;&lt;/a&gt;算法概述&lt;/h1&gt;&lt;p&gt;什么是快速排序算法的最好情况？&lt;/p&gt;
&lt;p&gt;每次正好中分    T(N) = O(N
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://cjay.life/2020/07/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-19T08:01:33.000Z</published>
    <updated>2020-07-29T15:04:50.543Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="核心-有序子列的归并"><a href="#核心-有序子列的归并" class="headerlink" title="核心: 有序子列的归并"></a>核心: 有序子列的归并</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;L &#x3D; 左边起始位置，R &#x3D; 右边起始位置，RightEnd &#x3D; 右边终点位置</span><br><span class="line">void Merge(ElementType A[],ElementType TmpA[],int L,int R,int RightEnd)</span><br><span class="line">&#123;</span><br><span class="line">LeftEnd &#x3D; R-1;&#x2F;&#x2F;左边终点位置</span><br><span class="line">Tmp &#x3D; L;&#x2F;&#x2F;存放数组的起始位置</span><br><span class="line">NumElements &#x3D; RightEnd - L + 1;</span><br><span class="line">while(L&lt;&#x3D;LeftEnd &amp;&amp; R&lt;&#x3D;RightEnd)&#123;</span><br><span class="line">if(A[L]&lt;&#x3D;A[R]) TmpA[Tmp++] &#x3D; A[L++];</span><br><span class="line">elseTmpA[Tmp++] &#x3D; A[R++];</span><br><span class="line">&#125;</span><br><span class="line">while(L&lt;&#x3D;LeftEnd)TmpA[Tmp++] &#x3D; A[L++];</span><br><span class="line">while(R&lt;&#x3D;RightEnd)TmpA[Tmp++] &#x3D; A[R++];</span><br><span class="line">for(i &#x3D; 0;i&lt;NumElements;i++,RightEnd--)</span><br><span class="line">A[RightEnd]&#x3D; TmpA[RightEnd];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h1><ul><li>分而治之</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;T(N) &#x3D; O(NlogN)</span><br><span class="line">void Msort(ElementType A[],ElementType TmpA[],int L,int RightEnd)&#123;</span><br><span class="line">itn center;</span><br><span class="line">if(L&lt;RightEnd)&#123;</span><br><span class="line">center &#x3D; (L+RightEnd)&#x2F;2;</span><br><span class="line">Msort(A,TmpA,L,center);</span><br><span class="line">Msort(A,TmpA,center+1,RightEnd);</span><br><span class="line">Merge(A,TmpA,L,Center+1,RightEnd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>统一函数接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Merge_sort(ElementType A[],int N)&#123;</span><br><span class="line">ElementType *TmpA;</span><br><span class="line">TmpA &#x3D; malloc(N*sizeof(ElementType)));</span><br><span class="line">if(Tmp!&#x3D;NULL)&#123;</span><br><span class="line">MSort(A,TmpA,0,N-1);</span><br><span class="line">free(TmpA);</span><br><span class="line">&#125;</span><br><span class="line">else Error(&quot;空间不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void Merge_pass(ElementType A[],ElementType TmpA[],int N,int length)&#123;</span><br><span class="line">&#x2F;&#x2F;length为当前有序子列的长度</span><br><span class="line">for(i &#x3D; 0;i&lt;&#x3D;N-2*length;i+&#x3D;2*length)</span><br><span class="line">merge1(A,TmpA,i,i+length,i+2*length-1);&#x2F;&#x2F;将A中元素归并到TmpA</span><br><span class="line">if(i+length&lt;N)&#x2F;&#x2F;归并最后两个子序列</span><br><span class="line">Merge1(A,TmpA,i,i+length,N-1);</span><br><span class="line">else&#x2F;&#x2F;最后只剩1个子列</span><br><span class="line">for(j &#x3D; i;j&lt;N;j++)TmpA[j] &#x3D; A[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Merge_sort(ElementType A[],int N)&#123;</span><br><span class="line">ElementType *TmpA;</span><br><span class="line">TmpA &#x3D; malloc(N*sizeof(ElementType));</span><br><span class="line">if(TmpA !&#x3D; NULL)&#123;</span><br><span class="line">while(length&lt;N)&#123;&#x2F;&#x2F;这个循环保证了最后TmpA的数据可以回A去</span><br><span class="line">Merge_pass(A,TmpA,N,length);</span><br><span class="line">length*&#x3D;2;</span><br><span class="line">Merge_pass(TmpA,A,N,length);&#x2F;&#x2F;如果上一步length&gt;N也没关系，会倒回A</span><br><span class="line">legth*&#x3D;2</span><br><span class="line">&#125;</span><br><span class="line">free(TmpA);</span><br><span class="line">&#125;</span><br><span class="line">else Error(&quot;空间不足&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该算法稳定，但是需要额外空间，不适用于内排序，适用于外排序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;核心-有序子列的归并&quot;&gt;&lt;a href=&quot;#核心-有序子列的归并&quot; class=&quot;headerlink&quot; title=&quot;核心: 有序子列的归并&quot;&gt;&lt;/a&gt;核心: 有序子列的归并&lt;/h1&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>csapp第二章:信息的表示和处理</title>
    <link href="https://cjay.life/2020/07/18/csapp%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>https://cjay.life/2020/07/18/csapp%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</id>
    <published>2020-07-18T14:46:15.000Z</published>
    <updated>2020-07-29T15:04:08.827Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h1><p>机器级程序将内存视为字节数组，每一个字节都有一个数字来标识，称它为地址（address）。在机器级程序的视角里，内存被抽象成了一个概念，名为虚拟内存(virtual address space)。而所有地址的集合被称为虚拟地址空间（virtual address space）。</p><h2 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h2><p>以16为基数，叫做十六进制（hexadecimal）数。在C语言中，以0x或0X开头的数字常量被认为是十六进制的值。</p><p><strong>十六进制转二进制的一个窍门是记住A,C和F对应的十进制的值。（10，12，15）</strong></p><h2 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h2><p>每台计算机都有字长（word size），虚拟地址都是用一个字来编码,因此对于字长为w位的机器，虚拟地址范围为0~2的w次-1；程序最多访问2的w次 的字节。</p><p>大多数64位机器也可以运行32位机器编译的程序，这是一种向后兼容。</p><h2 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h2><p>对于跨越多字节的数据对象，必须建立两个规则：</p><ul><li>对象的地址是什么</li><li>内存中如何排列这些字节</li></ul><p>对象的地址为所使用字节中最小的地址</p><p>对于排列方式有两种：</p><ul><li>小端法(little endian)：最低有效字节在最前面</li><li>大端法(big endian)：最高有效字节在最前面</li></ul><p>看下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">typedef unsigned char *byte_pointer;</span><br><span class="line"></span><br><span class="line">void show_bytes(byte_pointer start,size_t len)&#123;</span><br><span class="line">size_t i;</span><br><span class="line">for(i &#x3D; 0;i&lt;len;i++)</span><br><span class="line">printf(&quot;%.2x&quot;,start[i]);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表示字符串"><a href="#表示字符串" class="headerlink" title="表示字符串"></a>表示字符串</h2><p>C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。每个字符都是以某个标准编码来表示，最常见的是ASCII字符码。注意：<strong>strlen()不计算字符结尾，且在使用ASCII码作为字符码的任何系统都得到相同的结果，与字节顺序和字大小规则无关。</strong></p><h2 id="表示代码"><a href="#表示代码" class="headerlink" title="表示代码"></a>表示代码</h2><p>对于指令的编码，因为机器类型、不同的操作系统等因素，会有不同编码规则，因此二进制代码不兼容。</p><h2 id="布尔代数简介"><a href="#布尔代数简介" class="headerlink" title="布尔代数简介"></a>布尔代数简介</h2><p>布尔代数是二元集合{0，1}基础上的定义。用来表示这些运算的符号是与C语言位级运算使用的符号相匹配的。</p><p>布尔运算 ~ 对应逻辑运算NOT</p><p>​                &amp; 对应逻辑运算AND</p><p>​                | 对应逻辑运算OR</p><p>​                ^ 对应逻辑运算异或</p><p>上面四个运算可以扩展到位向量的运算，位向量就是固定长度w，由0和1组成的串。</p><p>&amp;和|互相之间有分配律：a&amp;(b|c) = (a&amp;b)|(a&amp;c)，反之亦然。</p><p>位向量一个很有用的应用就是表示有限集合。布尔代数|和&amp;分别对应于集合的并和交哦，而~对应于集合的补。</p><h2 id="C语言中的位级运算"><a href="#C语言中的位级运算" class="headerlink" title="C语言中的位级运算"></a>C语言中的位级运算</h2><p>C语言中： ~ 对应逻辑运算NOT</p><p>​                &amp; 对应逻辑运算AND</p><p>​                | 对应逻辑运算OR</p><p>​                ^ 对应逻辑运算异或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个有意思的交换函数，运用a^a &#x3D; 0 这一性质</span><br><span class="line">void inplace_swap(int *x,int *y)&#123;</span><br><span class="line">*y &#x3D; *x^*y;</span><br><span class="line">*x &#x3D; *x^*y;</span><br><span class="line">*y &#x3D; *x^*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位级运算一个常见用法就是实现掩码运算，例如：</p><p>x&amp;0xFF生成一个由x的最低有效字节组成的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例题：</span><br><span class="line">除了x的最低有效字节外，其他的位都取补，最低有效字节保持不变</span><br><span class="line">x^0xFF(这样写就可以忽略字长)</span><br><span class="line">x的最低有效字节设置全1，其他字节保持不变</span><br><span class="line">x|0xFF</span><br></pre></td></tr></table></figure><h2 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h2><p>C语言还提供了一组逻辑运算符||、&amp;&amp;和！。<strong>这与位级运算是不同的</strong></p><h2 id="C语言中的移位运算"><a href="#C语言中的移位运算" class="headerlink" title="C语言中的移位运算"></a>C语言中的移位运算</h2><p>左移只有逻辑左移对应x&lt;&lt;k。</p><p>右移分为逻辑右移和算术右移x&gt;&gt;k。在C语言中没有明确表示，但大多数编译器都是算术右移，在java中，x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k做逻辑右移。</p><p><strong>若移动k≥w位时，实际移动位数为k mod w</strong></p><p><strong>C语言中加减法的优先级比移位运算要高。1&lt;&lt;2+3&lt;&lt;4，其实时（1&lt;&lt;(2+3)）&lt;&lt;4</strong></p><h1 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h1><p>编码整数的两种不同的方式：一种只能表示非负数，而另一种能表示负数、零和正数。</p><p><img src="https://i.loli.net/2020/07/22/J9qTAOSXkBMFxPL.png" alt="img"></p><h2 id="整型数据类型"><a href="#整型数据类型" class="headerlink" title="整型数据类型"></a>整型数据类型</h2><p>很明显，对于相同的数据类型根据程序编译为32位还是64位而有所不同。</p><p><strong>C和C++都支持有符号和无符号数。java只支持有符号数</strong></p><h2 id="无符号数的编码"><a href="#无符号数的编码" class="headerlink" title="无符号数的编码"></a>无符号数的编码</h2><p>无符号数编码，定义一个 函数名为B2U(Binary to Unsigned)来表示。</p><p><img src="https://i.loli.net/2020/07/22/kDIMsYiCQdNbFma.png" alt="img"></p><p>B2U是一个双射，是唯一的。</p><h2 id="补码编码"><a href="#补码编码" class="headerlink" title="补码编码"></a>补码编码</h2><p>最常见的有符号数的计算机表示方式就是补码（two’s-complement）形式。</p><p>将字的最高有效位解释为负权（negative weight）。我们用函数B2T来表示</p><p><img src="https://i.loli.net/2020/07/22/982nGHZEBgDN15x.png" alt="img"></p><p>补码编码的唯一性</p><p>B2T是一个双射。</p><p>|TMin| = |TMax| + 1,之所以不对称，因为一半的位模式表示负数，而另一半（符号设置为0）表示非负数，也就意味能表示的整数比负数少一个。第二：UMAX = 2TMAX+1</p><p>为了一些程序也能够在大量的机器和编译器移植，C库中的&lt;limits.h&gt;定义了一组常量(消除了可变性)，INT_MAX,INT_MIN等等。</p><p>而数据类型的取值范围，java标准是非常明确的。</p><h2 id="有符号数和无符号数之间的转换"><a href="#有符号数和无符号数之间的转换" class="headerlink" title="有符号数和无符号数之间的转换"></a>有符号数和无符号数之间的转换</h2><p>C语言允许不同数字类型之间进行强制类型转换。</p><p>强制类型转换的本质是，位值不变，只是改变了解释这些位的方式。</p><h3 id="原理：补码转化位无符号数"><a href="#原理：补码转化位无符号数" class="headerlink" title="原理：补码转化位无符号数"></a>原理：补码转化位无符号数</h3><p><strong>若满足 Tmin≤x≤Tmax的x有</strong></p><p>​                        </p><p><strong>T2U（x） =   x+2的w次,     x&lt;0</strong></p><p>​                       <strong>x,                    x≥0</strong></p><p><img src="https://i.loli.net/2020/07/22/SNJO8wZUC5ugMdG.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/H1SgAlRJ4cM2OVz.png" alt="img"></p><h3 id="无符号数转化为补码"><a href="#无符号数转化为补码" class="headerlink" title="无符号数转化为补码"></a>无符号数转化为补码</h3><p><strong>若满足 0≤u≤Umax的u有</strong></p><p>​                        </p><p><strong>U2T（x） =  u,                            u≤Tmax</strong></p><p>​                       <strong>u-2的w次,                   u&gt;Tmax</strong></p><p><img src="https://i.loli.net/2020/07/22/qSPZxaJyVi3cmCk.png" alt="img"></p><h2 id="C语言中的有符号数与无符号数"><a href="#C语言中的有符号数与无符号数" class="headerlink" title="C语言中的有符号数与无符号数"></a>C语言中的有符号数与无符号数</h2><p>C语言标准没有指定有符号数采用哪种表示，但几乎所有机器都使用补码。</p><p>当申明一个常量默认被当作有符号，要创建一个无符号数常量，必须加上后缀字符U</p><h2 id="拓展一个数字的位表示"><a href="#拓展一个数字的位表示" class="headerlink" title="拓展一个数字的位表示"></a>拓展一个数字的位表示</h2><ul><li>无符号数的零扩展（zero extension）：高位填0就行了</li><li>符号宽展（sign extension)：<img src="https://i.loli.net/2020/07/22/IK2Tw5Ee1AJrmcO.png" alt="img"></li></ul><p>当short转换成unsigned时，首先要改变大小，再完成从有符号到无符号之间的转换。也就是说(unsigned)sx等价于(unsigned)(int)sx。这个规则是C语言标准要求的。</p><p>对于C语言而言，无符号数移位是逻辑移位，有符号数移位是算术移位。 </p><h2 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h2><ul><li>截断无符号数：x’ = x mod 2的k次（截断为k位的结果）</li><li>截断补码数值：具有相似的属性，只不过要将最高位转换为符号位。</li></ul><h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><h2 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h2><p><img src="https://i.loli.net/2020/07/22/yv7sYBCVqb65W1L.png" alt="img"></p><p>对于两个非负整数，满足0≤x,y≤2的w次。每个数都表示为w位无符号数字，然而计算和，可能范围为0≤x+y≤2的（w+1）次-2。</p><p>一般来说，如果x+y＜2的w次，和的w+1位表示中的最高位会等于0，因此不会改变。相反另一种情况会等于1，因此丢弃它相当于从和中减去2的w次。</p><p><img src="https://i.loli.net/2020/07/22/hRTqSjyYUQPf1Ni.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/eonkqLh6mjz8GTD.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/YDNaCt5d6y2on9l.png" alt="img"></p><p>当执行C程序时，不会将溢出作为错误而发信号。所以需要另外检测。</p><p>对在范围0≤x,y≤umax中的x和y，令s = x+y，当s&lt;x或s&lt;y时，发生了溢出。另一方面，如果s确实溢出了，我们就有 s = x+y-2的w次。假设 y&lt;2的w次，我们就有 y-2的w次＜0，因此s&lt;x。</p><h3 id="无符号数取反"><a href="#无符号数取反" class="headerlink" title="无符号数取反"></a>无符号数取反</h3><p><img src="https://i.loli.net/2020/07/22/UvECyAiYpIgMDbJ.png" alt="img"></p><h2 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h2><p><img src="https://i.loli.net/2020/07/22/NJMkY8ew3WszdDu.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/TwpNJS372iqrCUV.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/4KkTBxauCGRtdJj.png" alt="img"></p><p>检测补码加法中的溢出：当x&lt;0,y&lt;0,但s≥0,计算s发生了负溢出。负溢出也是同样道理。</p><h2 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h2><p><img src="https://i.loli.net/2020/07/22/IgLaNrQ8MKezFG4.png" alt="img"></p><p><strong>补码非得位级表示：在C语言中，对于任意整数x,计算-x和~x+1结果一样。</strong></p><h2 id="无符号数乘法"><a href="#无符号数乘法" class="headerlink" title="无符号数乘法"></a>无符号数乘法</h2><p>范围在0&lt;=x,y&lt;=2w-1内的整数x和y可以被表示为w位的无符号数，但是它们的乘积的取值范围为0到2的2w次-2的（w+1）次+1。这可能需要2w位来表示。不过，C语言中的无符号乘法被定义为产生w位的值，就是2w位的整数乘积的低w位表示的值。</p><p><img src="https://i.loli.net/2020/07/22/kA7ZIKoeCUTSmYp.png" alt="img"></p><h2 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h2><p><strong>补码乘法和无符号数乘法具有位级等价性。</strong></p><p><img src="https://i.loli.net/2020/07/22/lLXw4xIu7HPR2bF.png" alt="img"></p><h2 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h2><p>大多数机器，整数乘法指令相当慢，需要10个或者更多的时钟周期，然后其他整数运算只需要1个时钟周期，所以试着用移位和加法运算的组合来代替乘以常数因子的乘法</p><h3 id="乘以2的幂"><a href="#乘以2的幂" class="headerlink" title="乘以2的幂"></a>乘以2的幂</h3><p>需要C语言编译器试图以移位，加法和减法的组合来消除很多整数乘以常数的情况。例如：x*14，编译器将乘法重写为(x&lt;&lt;3)+(x&lt;&lt;2)+(x&lt;&lt;1)</p><h3 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h3><p>整数除法比乘法更慢，需要30个或更多时钟周期。才用右移来实现，无符号数和补码数分别使用逻辑移位和算术移位来达到目的。</p><p>整数除法总是舍入到0。对于负数向上，对于正数向下。</p><p>对于无符号数。采用逻辑移位。设x’为w-k位[x的w-1,…,w的k]的无符号数，而x’’为k位表示[x的k-1,…,x的0]的无符号数,x = 2的k次*x’+x’’,而0≤x’’&lt;2的k次。因此x’自然向下取整。</p><p>对于补码来说。移位执行的是算术移位。对于正数来说，与无符号数一样的。对于负数，普通的算术移位，会导致向下舍入，所以需要配调整。</p><p>对于，负数想要向上舍入，如何调整？</p><p>在移位之前，“偏置（biasing）”这个值，来修正不适合的舍入。C变量x和k分别有补码值x和无符号数值k，且0≤k&lt;w,则当执行算术移位时，C表达式(x+(1&lt;&lt;k)-1)&gt;&gt;K。</p><p>根本原理：x/y向上取整 = （x+y-1）/y向下取整。</p><p>假设x=qy+r，其中0≤r&lt;y,得到(x+y-1)/y=q+(r+y-1)/y，因此。当r=0时，后面一项等于0，而当r&gt;0时，等于1。也就是说，通过给x增加一个偏量y-1，然后再用除法向下舍入，当y整数x时，我们得到q，否则，就得到q+1。回到y=2k的情况，C表达式X+(1&lt;&lt;K)-1得到数值x+2的k次-1。</p><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><h2 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h2><p>二进制小数点往左移动一位相当于这个数被2除。往右移动一位，相当于将该数乘2。假定我们仅考虑有限从长度的编码，有些小数是不能被精确表示(只能表示: x*2的y次)，只能通过长度不断逼近。</p><h2 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h2><p>IEEE浮点标准用<img src="https://i.loli.net/2020/07/22/olTFs5RBNMtiqvy.png" alt="img">的形式来表示一个数：</p><ul><li>符号（sign）s决定是负数（s=1）还是正数（s=0），而对于数值0的符号位解释作为特殊情况处理。</li><li>尾数（significand）M是一个二进制小数，它的范围是1<del>2-ε，或者是0</del>1-ε。</li><li>阶码（exponent）E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。</li></ul><p>在单精度浮点数中，s、exp、frac分别1、8、23。双精度1,11,52。</p><p>根据exp的值，被编码的值可以分成三种不同的情况（最后的情况有两个变种）。</p><p><img src="https://i.loli.net/2020/07/22/EfHFSGqmxK9oVBN.png" alt="img"></p><ul><li>情况1（规格化数）：阶码的值E = e-bias。e为无符号数。尾数具有隐含的1开头（implied leading 1）表示。</li><li>情况2 （非规格化数）:E = 1-bias。尾数不包含隐含位1开头。（这里设置1-bias是为了平滑过度到规格化值，具体看下图）</li><li>情况3（特殊值）：阶码全为1的时候出现的，当小数域全为0时，根据符号位，得到正负无穷。小数域非0时，结果值称为“NAN”(Not a Number)。例如计算根号-1。</li></ul><h2 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h2><p><img src="https://i.loli.net/2020/07/22/JUIsNwlijmrqC68.png" alt="img"></p><p><img src="https://i.loli.net/2020/07/22/xYSnNpm7fCOu12j.png" alt="img"></p><p>可以观察到最大非规格化数和最小规格化数之间的平滑转变。这是一个有趣的属性，当这些表达式解释为无符号整数时，它们就是按升序排列的。</p><h2 id="舍入（rounding）"><a href="#舍入（rounding）" class="headerlink" title="舍入（rounding）"></a>舍入（rounding）</h2><p>向偶数舍入（round-to-even），也被称为向最接近的值舍入（round-to-nearest），是默认的方式。</p><p><img src="https://i.loli.net/2020/07/22/hl1zEIGjO5Hn4gt.png" alt="img"></p><h2 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h2><p>浮点运算具有交换律，但不具备结合律。对于表达式（3.14+1e10）-1e10求得0，是因为3.14由于太小，被舍入丢失了。另外两个特例（正无穷加负无穷=NAN，x+NAN=NAN）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;信息存储&quot;&gt;&lt;a href=&quot;#信息存储&quot; class=&quot;headerlink&quot; title=&quot;信息存储&quot;&gt;&lt;/a&gt;信息存储&lt;/h1&gt;&lt;p&gt;机器级程序将内存视为字节数组，每一个字节都有一个数字来标识，称它为地址（address
      
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://cjay.life/2020/07/18/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/18/%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-18T10:29:54.000Z</published>
    <updated>2020-07-29T15:04:57.307Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Selection_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">MinPostion &#x3D; ScanForMin(A,i,N-1);&#x2F;&#x2F;找最小元O（N）</span><br><span class="line">Swap(A[i],A[MinPostion]);&#x2F;&#x2F;将未排序部分的最小元换到有序部分的最后位置</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看出，虽然元素交换次数变为N-1次，但是寻找最小元的次数固定为N2。</p><p>无论如何： T = O（N2）；</p><p>这里想提高效率，只能从寻找最小元找突破口。</p><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Heap_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">BuildHeap(A);&#x2F;&#x2F;O(N);</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">TmpA[i] &#x3D; DeleteMin(A);&#x2F;&#x2F;O(logN)</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">A[i] &#x3D; TmpA[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T(N) = O(NlogN)</p><p>需要额外O（N）空间，并且复制元素需要时间。</p><h2 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Heap_Sort(ElemtType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">BuildHeap(A);</span><br><span class="line">for(i &#x3D; N-1;i&gt;0;i--)&#123;</span><br><span class="line">Swap(&amp;A[0],&amp;A[i]);&#x2F;&#x2F; DeleteMax</span><br><span class="line">PercDown(A,0,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定理：堆排序处理N个不同元素的随机排列的平均比较次数是2NlogN-O(NloglogN);</p><p>虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void Swap(ElementType *a,ElementType *b)</span><br><span class="line">&#123;</span><br><span class="line">ElementType t &#x3D; *a;*a &#x3D; *b;*b &#x3D; t;</span><br><span class="line">&#125;</span><br><span class="line">void PercDown(ElementType A[],int p,int N)&#x2F;&#x2F;将N个元素的数组中以A[p]为根的子堆调为最大堆</span><br><span class="line">&#123;</span><br><span class="line">int Parent,Child;</span><br><span class="line">ElementType X;</span><br><span class="line">X &#x3D; A[p];</span><br><span class="line">for(Parent &#x3D; p;(Parent*2+1)&lt;N;Parent &#x3D; Child)&#123;</span><br><span class="line">Child &#x3D; Parent*2+1;</span><br><span class="line">if((Child!&#x3D;N-1)&amp;&amp;(A[Child]&lt;A[Child+1]))</span><br><span class="line">Child++;&#x2F;&#x2F;取左右子节点中的最大者;</span><br><span class="line">if(X&gt;&#x3D;A[Child]) break;</span><br><span class="line">else</span><br><span class="line">A[parent] &#x3D; A[Child];</span><br><span class="line">&#125;</span><br><span class="line">A[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line">void HeapSort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i &#x3D; N&#x2F;2-1;i&gt;&#x3D;0;i--)</span><br><span class="line">PercDown(A,i,N);</span><br><span class="line">for(i &#x3D; N-1;i&gt;0;i--)&#123;</span><br><span class="line">Swap(&amp;A[0],&amp;A[i]);</span><br><span class="line">PercDown(A,0,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>希尔排序</title>
    <link href="https://cjay.life/2020/07/18/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/18/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-18T09:31:15.000Z</published>
    <updated>2020-07-29T15:05:17.064Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>定义增量序列 Dm&gt;Dm-1&gt;…&gt;D1 = 1</p><p>对每个Dk进行Dk间隔排序（k = m,m-1,…1）</p><p>注意: Dk间隔有序的序列，在执行Dk-1间隔排序后，仍然是Dk间隔有序的</p><h1 id="希尔增量序列"><a href="#希尔增量序列" class="headerlink" title="希尔增量序列"></a>希尔增量序列</h1><p>原始希尔排序    Dm =    N/2向下取整,    Dk = Dk+1/2向下取整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void Shell_sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">for(D&#x3D;N&#x2F;2;D&gt;0;D&#x2F;&#x3D;2)&#123;&#x2F;&#x2F;希尔增量序列</span><br><span class="line">for(P&#x3D;D;P&lt;N;P++)&#123;&#x2F;&#x2F;插入排序</span><br><span class="line">Tmp &#x3D; A[P];</span><br><span class="line">for(i&#x3D;P;i&gt;&#x3D;0&amp;&amp;A[i-D]&gt;Tmp;i-&#x3D;D)</span><br><span class="line">A[i] &#x3D; A[i-D];</span><br><span class="line">A[i] &#x3D; Tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;最坏情况：T &#x3D; 平均时间复杂度（N2），如果增量序列里的元素不互质数，下面的排序都是无用功，直到增量为1才起作用</span><br></pre></td></tr></table></figure><h1 id="更多增量序列"><a href="#更多增量序列" class="headerlink" title="更多增量序列"></a>更多增量序列</h1><h2 id="Hibbard增量序列"><a href="#Hibbard增量序列" class="headerlink" title="Hibbard增量序列"></a>Hibbard增量序列</h2><p>Dk = 2的k次-1(相邻元素互质)</p><p>最坏情况 T = O（N的3/2次）</p><p>猜想: T平均 = O（N的5/4次）</p><h2 id="Sedgewick增量序列"><a href="#Sedgewick增量序列" class="headerlink" title="Sedgewick增量序列"></a>Sedgewick增量序列</h2><p>{1，5，19，41，109，。。。}</p><p>9*4的i次-9*2的i次+1    或           4的i次-3*2的i次+1</p><p>猜想： T平均 = O（N的7/6次)    ,T最差 = O(N的4/3次)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void ShellSort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">int si,D,P,i;</span><br><span class="line">ElementType Tmp;</span><br><span class="line">int Sedgewick[] &#x3D; &#123;929,505,209,41,19,5,1,0&#125;&#x2F;&#x2F;一小部分</span><br><span class="line">for(si &#x3D; 0;Sedgewocl[si]&gt;&#x3D;N;si++)</span><br><span class="line">;</span><br><span class="line">for(D &#x3D; Sedgewick[si];D&gt;0;D &#x3D; Sedgewick[++D])&#123;</span><br><span class="line">for(P &#x3D; D;P&lt;N;p++)&#123;</span><br><span class="line">Tmp &#x3D; A[p];</span><br><span class="line">for(i &#x3D; P;i&gt;&#x3D;0&amp;&amp;tmp&lt;A[i];i-&#x3D;D)</span><br><span class="line">A[i] &#x3D; A[i-D];</span><br><span class="line">A[i] &#x3D; Tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;定义增量序列 Dm&amp;gt;Dm-1&amp;gt;…&amp;gt;D1 = 1&lt;/p&gt;
&lt;p&gt;对每个Dk进行Dk间隔排序（k = m,m-1,…1）&lt;/p&gt;
&lt;p&gt;注意: Dk间隔有序的序列，在执行Dk-1间隔排序后，仍然是Dk间隔有序的&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>csapp第一章：计算机系统漫游</title>
    <link href="https://cjay.life/2020/07/17/csapp%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/"/>
    <id>https://cjay.life/2020/07/17/csapp%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/</id>
    <published>2020-07-17T04:23:05.000Z</published>
    <updated>2020-07-18T09:13:05.946Z</updated>
    
    <content type="html"><![CDATA[<p>本书第一章开头通过跟踪hello程序的生命周期对系统进行学习</p><a id="more"></a><h1 id="信息就是位-上下文"><a href="#信息就是位-上下文" class="headerlink" title="信息就是位+上下文"></a>信息就是位+上下文</h1><p>Hello程序在一开始仅仅只是由编辑器创建的文本文件。这些文本文件在本质上都只是比特序列。</p><p><strong>比特序列是如何表示成文本字符？</strong></p><p><strong>这里采用编码标准，标准有很多，这里已ASCII标准为例：ASCII标准将这些最原始的比特序列，分成以字节（8个bit）为单位来表示每个字符。相当于y = f(x),y是文本字符，x是一个字节的bit串，函数f()是ASCII标准，该函数一一映射</strong></p><p><img src="https://i.loli.net/2020/07/17/OKGhCnreoVE1NYX.png" alt></p><p><strong>注意：文本中，每个文本行都有看不见的换行符’\n’，对应整数10</strong></p><p>所以在计算机中，比特序列是通过<strong>读到数据对象时的上下文</strong>来区分不同的数据对象</p><h1 id="程序被其他程序翻译成不同的格式"><a href="#程序被其他程序翻译成不同的格式" class="headerlink" title="程序被其他程序翻译成不同的格式"></a>程序被其他程序翻译成不同的格式</h1><p>源程序到目标程序（也称为可执行目标文件）转变过程如下：</p><p><img src="https://i.loli.net/2020/07/18/kDML9f4TUYNvcIZ.jpg" alt></p><ul><li>预处理阶段：修改原始C程序，比如将#include&lt;stdio.h&gt;中的stdio.h的内容直接插入程序文本中。最后将扩展名改为.i</li><li>编译阶段：通过编译器，转成了汇编语言程序。</li><li>汇编阶段：通过汇编器，转成了机器语言指令，把这些指令打包成可重定位目标程序（relocatable object program）的格式，保存到hello.o中</li><li>链接阶段：hello程序中调用了printf函数，该阶段就是将hello.o与printf.o以某种方式合并起来</li></ul><h1 id="处理器读并解释存在内存中的指令"><a href="#处理器读并解释存在内存中的指令" class="headerlink" title="处理器读并解释存在内存中的指令"></a>处理器读并解释存在内存中的指令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; .&#x2F;hello</span><br><span class="line">hello,world</span><br><span class="line">linux&gt;</span><br></pre></td></tr></table></figure><p>上图是通过shell（命令行解释器）运行了hello程序。</p><h2 id="系统的硬件组成"><a href="#系统的硬件组成" class="headerlink" title="系统的硬件组成"></a>系统的硬件组成</h2><ol><li>总线：总线被设计成传送定长的字节快，也就是字（word）。字长是系统的一个基本参数，每个系统中都不尽相同。大多数系统中要不32位要不64位。</li><li>I/O设备：每个I/O设备都通过一个控制器或适配器与I/O总线相连。<ul><li>控制器是I/O设备本身或系统的电路板上的芯片组</li><li>适配器是插在主板卡槽上的卡</li></ul></li><li>主存：由一组动态随机存取存储器（DRAM）芯片组成的。</li><li>处理器：是届时或执行存储在内存中指令的引擎。存储器核心是一个大小为一个字的寄存器，称为程序计数器PC，用于指向内存中某条机器语言指令。</li></ol><h2 id="运行hello程序"><a href="#运行hello程序" class="headerlink" title="运行hello程序"></a>运行hello程序</h2><p>初始时，shell程序执行它的指令，等待我们输入一个命令。当在键盘上输入“./hello”后，shell程序将字符逐一读入寄存器，再把它放到内存中</p><p><img src="https://i.loli.net/2020/07/18/ygsBjpQWza2c8mK.png" alt></p><p>当输入回车，shell知道我们结束了命令的输入。然后shell执行一系列指令加载并执行hello文件，将这个文件复制到主存。</p><p><img src="https://i.loli.net/2020/07/18/sE1g2olaPY3XStk.png" alt></p><p>处理器就开始执行这些机器语言指令。“Hello world”字符串从主存复制到寄存器文件，再从寄存器文件复制到显示设备。</p><p><img src="https://i.loli.net/2020/07/18/req7AfVIOmHBhJl.png" alt></p><h2 id="高速缓存至关重要"><a href="#高速缓存至关重要" class="headerlink" title="高速缓存至关重要"></a>高速缓存至关重要</h2><p>高速缓存通过静态随机访问存储器（SRAM）的硬件技术实现。</p><h2 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h2><p>主要思想是上一层的存储器作为第一层存储器的高速缓存。</p><h2 id="操作系统管理硬件"><a href="#操作系统管理硬件" class="headerlink" title="操作系统管理硬件"></a>操作系统管理硬件</h2><p>shell与hello程序都没有直接访问硬件，取而代之是由操作系统提供服务。</p><p>操作系统两个基本功能：</p><ol><li>防止硬件被应用程序滥用</li><li>向应用程序提供简单的机制来控制硬件设备</li></ol><p>操作系统主要采用几个抽象概念来实现上面两个功能：</p><ol><li>文件对I/O设备的抽象表示</li><li>虚拟内存对主存和磁盘I/O设备的抽象表示</li><li>进程则是对处理器、主存和I/O设备的抽象表示</li></ol><p><img src="https://i.loli.net/2020/07/18/IdOl8L1XK7VxJn6.jpg" alt></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是操作系统对一个正在运行的程序一种抽象。有了这种抽象，一个系统上可以并发多个进程。这种并发执行，通过处理器来进程间切换来实现的。操作系统实行这种交错执行的机制称为<strong>上下文切换</strong>。</p><p><strong>上下文是指操作系统跟踪进程运行所需要的状态信息，比如PC和寄存器的当前值，以及主存的内容</strong></p><p>上下文切换其实就是保存当前进程的上下文，恢复新进程的上下文，然后将控制区传递给新进程。</p><p>对于两个并发进程：shell进程和hello进程。刚开始shell进程在运行，即等待命令行输入。</p><p>当运行hello程序，shell系统调用-》系统调用将控制权从shell到给操作系统-》操作系统保存shell进程上下文-》创建hello进程上下文并将控制权给hello进程-》hello进程终止-》操作系统恢复shell上下文，并将控制区给shell</p><p><img src="https://i.loli.net/2020/07/18/sFRvVEjpfN2KTrX.png" alt></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>现代操作系统中，进程由多个线程的执行单元构成，每个线程运行在进程上下文中，享有同样的代码与数据。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存是一种抽象概念，给进程提供一种假象，即每个进程都在独占使用主存。每个进程看到都是虚拟地址空间</p><p><img src="https://i.loli.net/2020/07/18/7vjezVrfUP1kngA.png" alt="Linux进程的虚拟地址空间"></p><p>最低地址开始，从上介绍。</p><ul><li>程序代码和数据：先是代码，接着是数据。</li><li>堆：代码与数据在进程开始运行时就被指定了大小。但调用像malloc和free这样C标准库函数时，堆在运行时动态扩展与搜索。</li><li>共享库：用来存放C标准库和数学库这样的共享库的代码和数据区域。</li><li>栈：编译器用它实现函数调用，调用一个函数，栈增长，一个函数返回时，栈就会收缩。也可以动态扩展和收缩。</li><li>内核虚拟内存：为内核保留</li></ul><p>虚拟内存的运作需要<strong>硬件和操作系统之间交互，包括堆处理器生成的每个地址的硬件翻译</strong></p><p>基本思想是进程虚拟内存的内容存在磁盘上，用主存作为磁盘的高速缓存。</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>文件本质是字节序列。但它向应用程序提供了一个统一的视图来看待各式各样的I/O设备。</p><h1 id="系统之间的网络通信"><a href="#系统之间的网络通信" class="headerlink" title="系统之间的网络通信"></a>系统之间的网络通信</h1><p>系统从主存复制一串字到网络适配器时，数据流过网络到达另一台机器。同时，系统也可以从读取其他机器发送过来的数据，并复制到主存。</p><p><img src="https://i.loli.net/2020/07/18/8SheWR1Fi7Jp5Ug.png" alt></p><h1 id="重要主题"><a href="#重要主题" class="headerlink" title="重要主题"></a>重要主题</h1><h2 id="Amdahl定律"><a href="#Amdahl定律" class="headerlink" title="Amdahl定律"></a>Amdahl定律</h2><p>若系统执行某应用程序需要时间Told。假设其中某部分与整体时间的比例为a。</p><p>若该部分性能提升k。则新的执行时间为：<strong>Tnew = (1-a)Told+（aTold）/k = Told[(1-a)+a/k]</strong></p><p>加速比 <strong>S = Told/Tnew = 1/[(1-a)+a/k];</strong></p><p><strong>若k-&gt;∞，则S = 1/（1-a）</strong>，说明想要高的加速比只有通过优化系统大部分组件才行。</p><h2 id="并发（concurrency）与并行-parallelism"><a href="#并发（concurrency）与并行-parallelism" class="headerlink" title="并发（concurrency）与并行(parallelism)"></a>并发（concurrency）与并行(parallelism)</h2><ol><li>线程级并发：使用线程可以在一个进程中执行多个控制流。想要实现线程级的并发，可以采用以下两个技术<ol><li>多核处理器：将多个CPU集成到一个集成电路芯片上。<img src="https://i.loli.net/2020/07/18/RPd5SgyTNUwiVlf.png" alt></li><li>超线程（hyperthreading）或称为同时多线程(simultaneous multi-threading)，允许一个CPU通过执行多个CPU。说是一个CPU，其实CPU里的某些硬件变成了多份，比如程序计数器和寄存器文件。平常线程切换大约需要20000个周期，而采用超线程技术后，只要一个周期。</li></ol></li><li>指令集并行：在较低抽象层次上，现代处理器可以同时执行多条指令。采用流水线(Pipelining),将一条指令分成不同步骤，将硬件组织分成一系列阶段。硬件不同部分来处理指令的不同部分。能够达到接近于一个时钟周期的执行效率。而超标量（super-scalar）处理器速度更快。</li><li>单指令、多数据并行(SIMD):允许一条指令产生多个可以并行的操作。</li></ol><h2 id="计算机系统中抽象的重要性"><a href="#计算机系统中抽象的重要性" class="headerlink" title="计算机系统中抽象的重要性"></a>计算机系统中抽象的重要性</h2><p>例如为一组函数规定简单的应用程序接口（API），使程序员无需了解它内部的工作便可使用。</p><p>指令集架构就是提供了堆实际处理器硬件的抽象。使用这个抽象，机器代码程序好像运行在一个一次只执行一次指令的处理器上。</p><p><img src="https://i.loli.net/2020/07/18/wchIqyM1FjCWVBP.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本书第一章开头通过跟踪hello程序的生命周期对系统进行学习&lt;/p&gt;
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>csapp</title>
    <link href="https://cjay.life/2020/07/17/csapp/"/>
    <id>https://cjay.life/2020/07/17/csapp/</id>
    <published>2020-07-17T04:13:29.000Z</published>
    <updated>2020-08-01T15:20:55.567Z</updated>
    
    <content type="html"><![CDATA[<p>计划:阅读CSAPP和看对应CMU课程，看完后，总结笔记。</p><a id="more"></a><hr><p>该篇blog用于记录实施进度。</p><p>2020.7.17    1-20</p><p>2020.7.18    20-34</p><p>2020.7.19    34-54</p><p>2020.7.20    54-60（没有效率的一天）</p><p>2020.7.21    60-75</p><p>20207.22    75-88</p><p>2020.7.24    109-122</p><p>2020.7.25    122-136</p><p>2020.7.26    136-149</p><p>2020.7.27    149-164</p><p>2020.7.28    164-176</p><p>2020.7.29    176-216（第3章结束）</p><p>2020.7.30    243-259</p><p>2020.8.1    259-277</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计划:阅读CSAPP和看对应CMU课程，看完后，总结笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://cjay.life/categories/%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="计划" scheme="https://cjay.life/tags/%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>简单排序</title>
    <link href="https://cjay.life/2020/07/16/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/16/%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-16T14:41:31.000Z</published>
    <updated>2020-07-29T15:05:04.054Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Bubble_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">for(p &#x3D; N-1;p&gt;&#x3D;0;p--)&#123;</span><br><span class="line">flag &#x3D; 0;</span><br><span class="line">for(i &#x3D; 0;i&lt;p;i++)&#123;&#x2F;&#x2F;一趟冒泡</span><br><span class="line">if(A[i]&gt;A[i+1])&#123;</span><br><span class="line">Swap(A[i],A[i+1]);</span><br><span class="line">flag &#x3D; 1;&#x2F;&#x2F;标识发生了交换</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag &#x3D;&#x3D; 0) break;&#x2F;&#x2F;全程无交换</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：顺序T=O（N）</p><p>最欢情况：逆序T=O（N2）</p><p>稳定，也可以应用于链表</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Insertion_Sort(ElementType A[],int N)</span><br><span class="line">&#123;</span><br><span class="line">for(p &#x3D; 1;p&lt;N;p++)&#123;</span><br><span class="line">Tmp &#x3D; A[p];</span><br><span class="line">for(i &#x3D; p;i&gt;&#x3D;0&amp;&amp;tmp&lt;A[i-1];i--)</span><br><span class="line">A[i] &#x3D; A[i-1];</span><br><span class="line">A[i] &#x3D; Tmp;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况：顺序T=O（N）；</p><p>最坏情况: 逆序T=O(N2);</p><h1 id="时间复杂度下界"><a href="#时间复杂度下界" class="headerlink" title="时间复杂度下界"></a>时间复杂度下界</h1><p>对于i&lt;j,如果A[i]&gt;A[j],则称（i,j）是一对逆序对（inversion）</p><p>对于简单排序，都是相邻元素交换，每交换一次正好消去1个逆序对！</p><p>插入排序：T（N,I）= O（N+I），如果序列基本有序，则插入排序简单高效</p><p>定理:任意N个不同元素组成的序列平均具有<strong>N（N-1）/4</strong>个逆序对。</p><p>定理:任何交换相邻元素排序的算法，其平均时间为<strong>Ω（N2）</strong>。</p><p>这意味着，想提高效率，必须:</p><ul><li>每次消去不止1个逆序对</li><li>每次交换相隔较远的2个元素</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="排序" scheme="https://cjay.life/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>cmu csapp lecture 02 Bits,Bytes,and Integer</title>
    <link href="https://cjay.life/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/"/>
    <id>https://cjay.life/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/</id>
    <published>2020-07-15T10:42:43.000Z</published>
    <updated>2020-07-17T07:18:05.230Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/02-03-bits-ints.pdf" target="_blank" rel="noopener">讲义地址</a></p><h1 id="Representing-amp-Manipulating-Sets"><a href="#Representing-amp-Manipulating-Sets" class="headerlink" title="Representing &amp; Manipulating Sets"></a>Representing &amp; Manipulating Sets</h1><h2 id="Representing"><a href="#Representing" class="headerlink" title="Representing"></a>Representing</h2><p>01101001{0,3,5,6}</p><p>01010101{0,2,4,6}</p><h1 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h1><p>&amp; Intersection {0,6}</p><p>|  Union            {0,2,3,4,5,6}</p><p>^  Symmetric difference {2,3,4,5}</p><p>~ Complement {1,3,5,7}</p><p>上面的布尔代数运算，是从集合的角度来看。</p><p>watch out for &amp;&amp; vs &amp;(and || vs |)..(Bit-level Operations and logic Operations)</p><h1 id="shift-Operations"><a href="#shift-Operations" class="headerlink" title="shift Operations"></a>shift Operations</h1><h2 id="Left-Shift-x-lt-lt-y"><a href="#Left-Shift-x-lt-lt-y" class="headerlink" title="Left Shift : x &lt;&lt; y"></a>Left Shift : x &lt;&lt; y</h2><h2 id="Right-Shift-x-gt-gt-y"><a href="#Right-Shift-x-gt-gt-y" class="headerlink" title="Right Shift: x&gt;&gt;y"></a>Right Shift: x&gt;&gt;y</h2><h3 id="Logical-shift-Fill-with-0’s-on-left"><a href="#Logical-shift-Fill-with-0’s-on-left" class="headerlink" title="Logical shift:Fill with 0’s on left"></a>Logical shift:Fill with 0’s on left</h3><h3 id="Arithmetic-shift-Replicate-most-significant-bit-on-letf"><a href="#Arithmetic-shift-Replicate-most-significant-bit-on-letf" class="headerlink" title="Arithmetic shift: Replicate most significant bit on letf"></a>Arithmetic shift: Replicate most significant bit on letf</h3><h1 id="Conversion-Visualized"><a href="#Conversion-Visualized" class="headerlink" title="Conversion Visualized"></a>Conversion Visualized</h1><p><img src="/2020/07/15/cmu-csapp-lecture-02-Bits-Bytes-and-Integer/1.png" alt="Conversion"></p><h1 id="Casting-Suprises"><a href="#Casting-Suprises" class="headerlink" title="Casting Suprises"></a>Casting Suprises</h1><p>在单一表达式中混有有符号数和无符号数，有符号数会转换成无符号数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cs.cmu.edu/afs/cs/academic/class/15213-f15/www/lectures/02-03-bits-ints.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;讲义地址&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="《深入理解计算机系统》" scheme="https://cjay.life/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B/"/>
    
    
      <category term="csapp,视频课程" scheme="https://cjay.life/tags/csapp-%E8%A7%86%E9%A2%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>三点心得</title>
    <link href="https://cjay.life/2020/07/14/%E4%B8%89%E7%82%B9%E5%BF%83%E5%BE%97/"/>
    <id>https://cjay.life/2020/07/14/%E4%B8%89%E7%82%B9%E5%BF%83%E5%BE%97/</id>
    <published>2020-07-14T09:42:12.000Z</published>
    <updated>2020-07-14T09:44:11.049Z</updated>
    
    <content type="html"><![CDATA[<ol><li>当脑海中浮现不开心的事情后，想开心的事情。</li><li>每次结束前，尽量克服难关。</li><li>趁热打铁</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;当脑海中浮现不开心的事情后，想开心的事情。&lt;/li&gt;
&lt;li&gt;每次结束前，尽量克服难关。&lt;/li&gt;
&lt;li&gt;趁热打铁&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="技巧" scheme="https://cjay.life/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="https://cjay.life/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>旅游规划</title>
    <link href="https://cjay.life/2020/07/13/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/"/>
    <id>https://cjay.life/2020/07/13/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/</id>
    <published>2020-07-13T14:46:14.000Z</published>
    <updated>2020-07-13T14:55:02.274Z</updated>
    
    <content type="html"><![CDATA[<p>7-9 旅游规划 (25分)</p><p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入数据的第1行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0~(<em>N</em>−1)；<em>M</em>是高速公路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。随后的<em>M</em>行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 40</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,S,D;</span><br><span class="line">int visited[505];</span><br><span class="line">int cost[505];</span><br><span class="line">int dist[505];</span><br><span class="line">int costs[505][505];</span><br><span class="line">int graph[505][505];</span><br><span class="line">int t1,t2,t3,t4;</span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;505;i++)&#123;</span><br><span class="line">for(int j &#x3D; 0;j&lt;505;j++)&#123;</span><br><span class="line">if(i!&#x3D;j)&#123;</span><br><span class="line">costs[i][j] &#x3D; 65535;</span><br><span class="line">graph[i][j] &#x3D; 65535;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Dijkstra(int s)&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;&#x2F;&#x2F;初始化</span><br><span class="line">cost[i] &#x3D; costs[s][i];</span><br><span class="line">dist[i] &#x3D; graph[s][i];</span><br><span class="line">&#125;</span><br><span class="line">while(1)&#123;</span><br><span class="line">int min &#x3D; 65535;</span><br><span class="line">int v &#x3D; -1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((i!&#x3D;s)&amp;&amp;(visited[i] &#x3D;&#x3D; 0)&amp;&amp;(graph[s][i]&lt;min))&#123;</span><br><span class="line">v &#x3D; i;</span><br><span class="line">min &#x3D; graph[s][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(v &#x3D;&#x3D; -1) break;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((visited[i] &#x3D;&#x3D; 0)&amp;&amp;(dist[v]+graph[v][i]&lt;dist[i]))&#123;</span><br><span class="line">dist[i] &#x3D; dist[v] + graph[v][i];</span><br><span class="line">cost[i] &#x3D; cost[v]+costs[v][i];</span><br><span class="line">&#125;else if((dist[v]+graph[v][i] &#x3D;&#x3D; dist[i])&amp;&amp;(cost[v]+costs[v][i]&lt;cost[i]))&#123;</span><br><span class="line">cost[i] &#x3D; cost[v] + costs[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;D;</span><br><span class="line">reset();&#x2F;&#x2F;初始化</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3&gt;&gt;t4;</span><br><span class="line">graph[t1][t2] &#x3D; t3;</span><br><span class="line">graph[t2][t1] &#x3D; t3;</span><br><span class="line">costs[t1][t2] &#x3D; t4;</span><br><span class="line">costs[t2][t1] &#x3D; t4;</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(S);</span><br><span class="line">cout&lt;&lt;dist[D]&lt;&lt;&quot; &quot;&lt;&lt;cost[D];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他变型问题"><a href="#其他变型问题" class="headerlink" title="其他变型问题"></a>其他变型问题</h3><p>要求数最短路径有几条</p><ol><li>初始化起点:count[s] = 1;</li><li>如果找到更短路：count[w] = count[v];</li><li>如果找到等长路：count[w]+=count[v];</li></ol><p>要求边数最少的最短路</p><pre><code>1. counts[s] = 0; 2. 如果找到更短路：count[w] = count[v]+1; 3. 如果找到等长路:  count[w] = count[v] + 1;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-9 旅游规划 (25分)&lt;/p&gt;
&lt;p&gt;有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="Dijkstra" scheme="https://cjay.life/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>关键路径</title>
    <link href="https://cjay.life/2020/07/13/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <id>https://cjay.life/2020/07/13/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</id>
    <published>2020-07-13T13:28:14.000Z</published>
    <updated>2020-07-13T13:42:09.499Z</updated>
    
    <content type="html"><![CDATA[<p>AOE（Activity On Edge,与AOV区别）网络</p><p>计算整个工期就是 计算最早完成时间</p><p>机动时间： D&lt;i,j&gt; = Latest[j] - Earliest[i] - C&lt;i,j&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AOE（Activity On Edge,与AOV区别）网络&lt;/p&gt;
&lt;p&gt;计算整个工期就是 计算最早完成时间&lt;/p&gt;
&lt;p&gt;机动时间： D&amp;lt;i,j&amp;gt; = Latest[j] - Earliest[i] - C&amp;lt;i,j&amp;gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="关键路径" scheme="https://cjay.life/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://cjay.life/2020/07/13/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/13/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-13T10:58:20.000Z</published>
    <updated>2020-07-13T14:46:40.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拓扑序定义"><a href="#拓扑序定义" class="headerlink" title="拓扑序定义"></a>拓扑序定义</h1><p>如果图中从v到w有一条有向途径,则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。</p><p>获得一个拓扑序的过程就是拓扑排序</p><p>Activity On Vertex (AOV) 网络如果有合理的拓扑序，则必定是有向无环图（Directed Acylic Grapg,DAG）</p><h1 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void TopSort()&#123;</span><br><span class="line">for(cnt &#x3D; 0;cnt&lt;v;cnt++)&#123;</span><br><span class="line">v &#x3D; 未输出的入度为0的顶点；&#x2F;&#x2F;O(V)</span><br><span class="line">if(这样的v不存在)&#123;</span><br><span class="line">Error(“图中有回路”);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">输出v，或者记录v的输出序号;</span><br><span class="line">for(v的每个邻接点)</span><br><span class="line">Indegree[w]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(V2)</span><br></pre></td></tr></table></figure><h1 id="聪明的算法"><a href="#聪明的算法" class="headerlink" title="聪明的算法"></a>聪明的算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;随时将入度变为0的顶点放到一个容器里</span><br><span class="line">void TopSort()&#123;</span><br><span class="line">for(图中每个顶点 v)</span><br><span class="line">if(Indegree[v] &#x3D;&#x3D; 0)</span><br><span class="line">enqueue(v,q);</span><br><span class="line">while(!isempty(q))&#123;</span><br><span class="line">v &#x3D; dequeue(q);</span><br><span class="line">输出v,或者记录v的输出序号;cnt++</span><br><span class="line">for(v 的每个邻接点 w)</span><br><span class="line">if(--Indegree[W] &#x3D;&#x3D; 0)</span><br><span class="line">enqueue(W,Q);</span><br><span class="line">&#125;</span><br><span class="line">if( cnt !&#x3D; v)</span><br><span class="line">error(“图中有回路”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(V+E)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;拓扑序定义&quot;&gt;&lt;a href=&quot;#拓扑序定义&quot; class=&quot;headerlink&quot; title=&quot;拓扑序定义&quot;&gt;&lt;/a&gt;拓扑序定义&lt;/h1&gt;&lt;p&gt;如果图中从v到w有一条有向途径,则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。&lt;/p&gt;
&lt;p&gt;获得一个拓扑
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="拓扑排序" scheme="https://cjay.life/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树问题(Minimum Spanning Tree)</title>
    <link href="https://cjay.life/2020/07/13/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/"/>
    <id>https://cjay.life/2020/07/13/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-13T09:48:18.000Z</published>
    <updated>2020-07-13T13:16:13.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>最小生成树首先是一棵树</p><ol><li>无回路</li><li>V个顶点一定有V-1条边</li></ol><p>是生成树</p><ol><li>包含全部顶点</li><li>V-1条边都在图里</li></ol><p>边的权重和最小</p><h1 id="生成最小生成树的算法思想（贪心思想）"><a href="#生成最小生成树的算法思想（贪心思想）" class="headerlink" title="生成最小生成树的算法思想（贪心思想）"></a>生成最小生成树的算法思想（贪心思想）</h1><p>每一步都是选最好的（权重最小的边）</p><p>选择过程中的约束：</p><ol><li>只能用图里的边</li><li>只能一种选择v-1条边</li><li>不能有回路</li></ol><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>类似Dijikastra算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">v &#x3D; 未收录顶点中dist最小值;</span><br><span class="line">if(这样的v不存在)</span><br><span class="line">break;</span><br><span class="line">collected[v] &#x3D; true;</span><br><span class="line">for(v 的每个邻接点 w)&#123;</span><br><span class="line">if((collected[w] &#x3D;&#x3D; false) &amp;&amp; (dist[v] + E&lt;v,w&gt; &lt; dist[w]))&#123;</span><br><span class="line">dist[w] &#x3D; dist[v] + E[v,w]l</span><br><span class="line">path[w] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void Prim()&#123;</span><br><span class="line">MST &#x3D; &#123;s&#125;;</span><br><span class="line">while(1)&#123;</span><br><span class="line">v &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">if(这样v不存在)</span><br><span class="line">break;</span><br><span class="line">将v收录进MST: dist[v] &#x3D; 0;</span><br><span class="line">for(v 的每个邻接点 w)&#123;</span><br><span class="line">if(dist[w] !&#x3D; 0)&#123;</span><br><span class="line">if(E&lt;v,w&gt; &lt;dist[w])&#123;</span><br><span class="line">dist[w] &#x3D; E&lt;v,w&gt;;</span><br><span class="line">parent[W] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(MST中收的顶点不到V个)</span><br><span class="line">Error(“生成树不存在”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;dist[v] &#x3D; E&lt;s,v&gt; 或 正无穷</span><br><span class="line">&#x2F;&#x2F;parent[s] &#x3D; -1</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(v2) 稠密图合算</span><br></pre></td></tr></table></figure><h2 id="Kruskal算法（将森林合并成树）"><a href="#Kruskal算法（将森林合并成树）" class="headerlink" title="Kruskal算法（将森林合并成树）"></a>Kruskal算法（将森林合并成树）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Kruskal (Graph G)&#123;</span><br><span class="line">MST &#x3D; &#123;&#125;;</span><br><span class="line">while(MST中不到|V|-1条边 &amp;&amp; E中还有边)&#123;</span><br><span class="line">从E中取一条权重最小边 &#x2F;*最小堆*&#x2F;</span><br><span class="line">将E&lt;v,w&gt;从E中删除；</span><br><span class="line">if(E&lt;v,w&gt;不在MST中构成回路) &#x2F;*并查集*&#x2F;</span><br><span class="line"> E(V,W) 加入 MST;</span><br><span class="line">else</span><br><span class="line">彻底无视 E(V,W);</span><br><span class="line">&#125;</span><br><span class="line">if ( MST 中不到 |V|-1 条边 )</span><br><span class="line">Error ( “生成树不存在” );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(ElogE)</span><br></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 邻接矩阵存储 - Prim最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">Vertex FindMinDist( MGraph Graph, WeightType dist[] )</span><br><span class="line">&#123; &#x2F;* 返回未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">    Vertex MinV, V;</span><br><span class="line">    WeightType MinDist &#x3D; INFINITY;</span><br><span class="line"> </span><br><span class="line">    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        if ( dist[V]!&#x3D;0 &amp;&amp; dist[V]&lt;MinDist) &#123;</span><br><span class="line">            &#x2F;* 若V未被收录，且dist[V]更小 *&#x2F;</span><br><span class="line">            MinDist &#x3D; dist[V]; &#x2F;* 更新最小距离 *&#x2F;</span><br><span class="line">            MinV &#x3D; V; &#x2F;* 更新对应顶点 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (MinDist &lt; INFINITY) &#x2F;* 若找到最小dist *&#x2F;</span><br><span class="line">        return MinV; &#x2F;* 返回对应的顶点下标 *&#x2F;</span><br><span class="line">    else return ERROR;  &#x2F;* 若这样的顶点不存在，返回-1作为标记 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Prim( MGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType dist[MaxVertexNum], TotalWeight;</span><br><span class="line">    Vertex parent[MaxVertexNum], V, W;</span><br><span class="line">    int VCount;</span><br><span class="line">    Edge E;</span><br><span class="line">     </span><br><span class="line">    &#x2F;* 初始化。默认初始点下标是0 *&#x2F;</span><br><span class="line">       for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        &#x2F;* 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY *&#x2F;</span><br><span class="line">           dist[V] &#x3D; Graph-&gt;G[0][V];</span><br><span class="line">           parent[V] &#x3D; 0; &#x2F;* 暂且定义所有顶点的父结点都是初始点0 *&#x2F; </span><br><span class="line">    &#125;</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    VCount &#x3D; 0;      &#x2F;* 初始化收录的顶点数 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    E &#x3D; (Edge)malloc( sizeof(struct ENode) ); &#x2F;* 建立空的边结点 *&#x2F;</span><br><span class="line">            </span><br><span class="line">    &#x2F;* 将初始点0收录进MST *&#x2F;</span><br><span class="line">    dist[0] &#x3D; 0;</span><br><span class="line">    VCount ++;</span><br><span class="line">    parent[0] &#x3D; -1; &#x2F;* 当前树根是0 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    while (1) &#123;</span><br><span class="line">        V &#x3D; FindMinDist( Graph, dist );</span><br><span class="line">        &#x2F;* V &#x3D; 未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">        if ( V&#x3D;&#x3D;ERROR ) &#x2F;* 若这样的V不存在 *&#x2F;</span><br><span class="line">            break;   &#x2F;* 算法结束 *&#x2F;</span><br><span class="line">             </span><br><span class="line">        &#x2F;* 将V及相应的边&lt;parent[V], V&gt;收录进MST *&#x2F;</span><br><span class="line">        E-&gt;V1 &#x3D; parent[V];</span><br><span class="line">        E-&gt;V2 &#x3D; V;</span><br><span class="line">        E-&gt;Weight &#x3D; dist[V];</span><br><span class="line">        InsertEdge( MST, E );</span><br><span class="line">        TotalWeight +&#x3D; dist[V];</span><br><span class="line">        dist[V] &#x3D; 0;</span><br><span class="line">        VCount++;</span><br><span class="line">         </span><br><span class="line">        for( W&#x3D;0; W&lt;Graph-&gt;Nv; W++ ) &#x2F;* 对图中的每个顶点W *&#x2F;</span><br><span class="line">            if ( dist[W]!&#x3D;0 &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;</span><br><span class="line">            &#x2F;* 若W是V的邻接点并且未被收录 *&#x2F;</span><br><span class="line">                if ( Graph-&gt;G[V][W] &lt; dist[W] ) &#123;</span><br><span class="line">                &#x2F;* 若收录V使得dist[W]变小 *&#x2F;</span><br><span class="line">                    dist[W] &#x3D; Graph-&gt;G[V][W]; &#x2F;* 更新dist[W] *&#x2F;</span><br><span class="line">                    parent[W] &#x3D; V; &#x2F;* 更新树 *&#x2F;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; &#x2F;* while结束*&#x2F;</span><br><span class="line">    if ( VCount &lt; Graph-&gt;Nv ) &#x2F;* MST中收的顶点不到|V|个 *&#x2F;</span><br><span class="line">       TotalWeight &#x3D; ERROR;</span><br><span class="line">    return TotalWeight;   &#x2F;* 算法执行完毕，返回最小权重和或错误标记 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 邻接表存储 - Kruskal最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 顶点并查集定义 --------------------*&#x2F;</span><br><span class="line">typedef Vertex ElementType; &#x2F;* 默认元素可以用非负整数表示 *&#x2F;</span><br><span class="line">typedef Vertex SetName;     &#x2F;* 默认用根结点的下标作为集合名称 *&#x2F;</span><br><span class="line">typedef ElementType SetType[MaxVertexNum]; &#x2F;* 假设集合元素下标从0开始 *&#x2F;</span><br><span class="line"> </span><br><span class="line">void InitializeVSet( SetType S, int N )</span><br><span class="line">&#123; &#x2F;* 初始化并查集 *&#x2F;</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    for ( X&#x3D;0; X&lt;N; X++ ) S[X] &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Union( SetType S, SetName Root1, SetName Root2 )</span><br><span class="line">&#123; &#x2F;* 这里默认Root1和Root2是不同集合的根结点 *&#x2F;</span><br><span class="line">    &#x2F;* 保证小集合并入大集合 *&#x2F;</span><br><span class="line">    if ( S[Root2] &lt; S[Root1] ) &#123; &#x2F;* 如果集合2比较大 *&#x2F;</span><br><span class="line">        S[Root2] +&#x3D; S[Root1];     &#x2F;* 集合1并入集合2  *&#x2F;</span><br><span class="line">        S[Root1] &#x3D; Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;                         &#x2F;* 如果集合1比较大 *&#x2F;</span><br><span class="line">        S[Root1] +&#x3D; S[Root2];     &#x2F;* 集合2并入集合1  *&#x2F;</span><br><span class="line">        S[Root2] &#x3D; Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SetName Find( SetType S, ElementType X )</span><br><span class="line">&#123; &#x2F;* 默认集合元素全部初始化为-1 *&#x2F;</span><br><span class="line">    if ( S[X] &lt; 0 ) &#x2F;* 找到集合的根 *&#x2F;</span><br><span class="line">        return X;</span><br><span class="line">    else</span><br><span class="line">        return S[X] &#x3D; Find( S, S[X] ); &#x2F;* 路径压缩 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )</span><br><span class="line">&#123; &#x2F;* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 *&#x2F;</span><br><span class="line">    Vertex Root1, Root2;</span><br><span class="line"> </span><br><span class="line">    Root1 &#x3D; Find( VSet, V1 ); &#x2F;* 得到V1所属的连通集名称 *&#x2F;</span><br><span class="line">    Root2 &#x3D; Find( VSet, V2 ); &#x2F;* 得到V2所属的连通集名称 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    if( Root1&#x3D;&#x3D;Root2 ) &#x2F;* 若V1和V2已经连通，则该边不能要 *&#x2F;</span><br><span class="line">        return false;</span><br><span class="line">    else &#123; &#x2F;* 否则该边可以被收集，同时将V1和V2并入同一连通集 *&#x2F;</span><br><span class="line">        Union( VSet, Root1, Root2 );</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 并查集定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 边的最小堆定义 --------------------*&#x2F;</span><br><span class="line">void PercDown( Edge ESet, int p, int N )</span><br><span class="line">&#123; &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p )    *&#x2F;</span><br><span class="line">  &#x2F;* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 *&#x2F;</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    struct ENode X;</span><br><span class="line"> </span><br><span class="line">    X &#x3D; ESet[p]; &#x2F;* 取出根结点存放的值 *&#x2F;</span><br><span class="line">    for( Parent&#x3D;p; (Parent*2+1)&lt;N; Parent&#x3D;Child ) &#123;</span><br><span class="line">        Child &#x3D; Parent * 2 + 1;</span><br><span class="line">        if( (Child!&#x3D;N-1) &amp;&amp; (ESet[Child].Weight&gt;ESet[Child+1].Weight) )</span><br><span class="line">            Child++;  &#x2F;* Child指向左右子结点的较小者 *&#x2F;</span><br><span class="line">        if( X.Weight &lt;&#x3D; ESet[Child].Weight ) break; &#x2F;* 找到了合适位置 *&#x2F;</span><br><span class="line">        else  &#x2F;* 下滤X *&#x2F;</span><br><span class="line">            ESet[Parent] &#x3D; ESet[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    ESet[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void InitializeESet( LGraph Graph, Edge ESet )</span><br><span class="line">&#123; &#x2F;* 将图的边存入数组ESet，并且初始化为最小堆 *&#x2F;</span><br><span class="line">    Vertex V;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    int ECount;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将图的边存入数组ESet *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;</span><br><span class="line">    for ( V&#x3D;0; V&lt;Graph-&gt;Nv; V++ )</span><br><span class="line">        for ( W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next )</span><br><span class="line">            if ( V &lt; W-&gt;AdjV ) &#123; &#x2F;* 避免重复录入无向图的边，只收V1&lt;V2的边 *&#x2F;</span><br><span class="line">                ESet[ECount].V1 &#x3D; V;</span><br><span class="line">                ESet[ECount].V2 &#x3D; W-&gt;AdjV;</span><br><span class="line">                ESet[ECount++].Weight &#x3D; W-&gt;Weight;</span><br><span class="line">            &#125;</span><br><span class="line">    &#x2F;* 初始化为最小堆 *&#x2F;</span><br><span class="line">    for ( ECount&#x3D;Graph-&gt;Ne&#x2F;2; ECount&gt;&#x3D;0; ECount-- )</span><br><span class="line">        PercDown( ESet, ECount, Graph-&gt;Ne );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int GetEdge( Edge ESet, int CurrentSize )</span><br><span class="line">&#123; &#x2F;* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将最小边与当前堆的最后一个位置的边交换 *&#x2F;</span><br><span class="line">    Swap( &amp;ESet[0], &amp;ESet[CurrentSize-1]);</span><br><span class="line">    &#x2F;* 将剩下的边继续调整成最小堆 *&#x2F;</span><br><span class="line">    PercDown( ESet, 0, CurrentSize-1 );</span><br><span class="line"> </span><br><span class="line">    return CurrentSize-1; &#x2F;* 返回最小边所在位置 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 最小堆定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int Kruskal( LGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType TotalWeight;</span><br><span class="line">    int ECount, NextEdge;</span><br><span class="line">    SetType VSet; &#x2F;* 顶点数组 *&#x2F;</span><br><span class="line">    Edge ESet;    &#x2F;* 边数组 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    InitializeVSet( VSet, Graph-&gt;Nv ); &#x2F;* 初始化顶点并查集 *&#x2F;</span><br><span class="line">    ESet &#x3D; (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne );</span><br><span class="line">    InitializeESet( Graph, ESet ); &#x2F;* 初始化边的最小堆 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;      &#x2F;* 初始化收录的边数 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    NextEdge &#x3D; Graph-&gt;Ne; &#x2F;* 原始边集的规模 *&#x2F;</span><br><span class="line">    while ( ECount &lt; Graph-&gt;Nv-1 ) &#123;  &#x2F;* 当收集的边不足以构成树时 *&#x2F;</span><br><span class="line">        NextEdge &#x3D; GetEdge( ESet, NextEdge ); &#x2F;* 从边集中得到最小边的位置 *&#x2F;</span><br><span class="line">        if (NextEdge &lt; 0) &#x2F;* 边集已空 *&#x2F;</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;* 如果该边的加入不构成回路，即两端结点不属于同一连通集 *&#x2F;</span><br><span class="line">        if ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )&#x3D;&#x3D;true ) &#123;</span><br><span class="line">            &#x2F;* 将该边插入MST *&#x2F;</span><br><span class="line">            InsertEdge( MST, ESet+NextEdge );</span><br><span class="line">            TotalWeight +&#x3D; ESet[NextEdge].Weight; &#x2F;* 累计权重 *&#x2F;</span><br><span class="line">            ECount++; &#x2F;* 生成树中边数加1 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( ECount &lt; Graph-&gt;Nv-1 )</span><br><span class="line">        TotalWeight &#x3D; -1; &#x2F;* 设置错误标记，表示生成树不存在 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    return TotalWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;最小生成树首先是一棵树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无回路&lt;/li&gt;
&lt;li&gt;V个顶点一定有V-1条边&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;是生成树&lt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最小生成树" scheme="https://cjay.life/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈利·波特的考试</title>
    <link href="https://cjay.life/2020/07/13/%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/"/>
    <id>https://cjay.life/2020/07/13/%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/</id>
    <published>2020-07-13T09:06:16.000Z</published>
    <updated>2020-07-13T09:09:36.107Z</updated>
    
    <content type="html"><![CDATA[<p>7-8 哈利·波特的考试 (25分)</p><p>哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。</p><p>现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入第1行给出两个正整数<em>N</em> (≤100)和<em>M</em>，其中<em>N</em>是考试涉及的动物总数，<em>M</em>是用于直接变形的魔咒条数。为简单起见，我们将动物按1~<em>N</em>编号。随后<em>M</em>行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">6 11</span><br><span class="line">3 4 70</span><br><span class="line">1 2 1</span><br><span class="line">5 4 50</span><br><span class="line">2 6 50</span><br><span class="line">5 6 60</span><br><span class="line">1 3 70</span><br><span class="line">4 6 60</span><br><span class="line">3 6 80</span><br><span class="line">5 1 100</span><br><span class="line">2 4 60</span><br><span class="line">5 2 80</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 70</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int D[105][105];</span><br><span class="line">int N,M;</span><br><span class="line">int t1,t2,t3;</span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">if(i!&#x3D;j)</span><br><span class="line">D[i][j] &#x3D; 65535; &#x2F;&#x2F;floyd算法要求无边就初始化为正无穷</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void floyd()&#123;</span><br><span class="line">for(int k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(D[i][k]+D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">D[i][j] &#x3D; D[i][k]+D[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int FindMaxDist(int i)&#123;</span><br><span class="line">int maxdist &#x3D; 0;</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(i!&#x3D;j &amp;&amp; D[i][j]&gt;maxdist)</span><br><span class="line">maxdist &#x3D; D[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;maxdist&lt;&lt;&#39;\n&#39;; </span><br><span class="line">return maxdist;</span><br><span class="line">&#125;</span><br><span class="line">void FindMinDist()&#123;</span><br><span class="line">int mindist &#x3D; 65535;</span><br><span class="line">int animal;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">int maxdist &#x3D; FindMaxDist(i);</span><br><span class="line">if(maxdist &#x3D;&#x3D; 65535)&#123;</span><br><span class="line">printf(&quot;0\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(mindist&gt;maxdist)&#123;</span><br><span class="line">mindist &#x3D; maxdist;</span><br><span class="line">animal &#x3D; i+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d %d\n&quot;,animal,mindist);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">reset();</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;</span><br><span class="line">D[t1-1][t2-1] &#x3D; t3;&#x2F;&#x2F;位置偏移</span><br><span class="line">D[t2-1][t1-1] &#x3D; t3;</span><br><span class="line">&#125;</span><br><span class="line">floyd();</span><br><span class="line">&#x2F;&#x2F;for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">&#x2F;&#x2F;for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;D[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">FindMinDist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-8 哈利·波特的考试 (25分)&lt;/p&gt;
&lt;p&gt;哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最短路径，floyd" scheme="https://cjay.life/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%8Cfloyd/"/>
    
  </entry>
  
</feed>
