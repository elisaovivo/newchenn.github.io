<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CJ&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cjay.life/"/>
  <updated>2020-07-14T09:44:11.049Z</updated>
  <id>https://cjay.life/</id>
  
  <author>
    <name>CJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三点心得</title>
    <link href="https://cjay.life/2020/07/14/%E4%B8%89%E7%82%B9%E5%BF%83%E5%BE%97/"/>
    <id>https://cjay.life/2020/07/14/%E4%B8%89%E7%82%B9%E5%BF%83%E5%BE%97/</id>
    <published>2020-07-14T09:42:12.000Z</published>
    <updated>2020-07-14T09:44:11.049Z</updated>
    
    <content type="html"><![CDATA[<ol><li>当脑海中浮现不开心的事情后，想开心的事情。</li><li>每次结束前，尽量克服难关。</li><li>趁热打铁</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;当脑海中浮现不开心的事情后，想开心的事情。&lt;/li&gt;
&lt;li&gt;每次结束前，尽量克服难关。&lt;/li&gt;
&lt;li&gt;趁热打铁&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="技巧" scheme="https://cjay.life/categories/%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="https://cjay.life/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>旅游规划</title>
    <link href="https://cjay.life/2020/07/13/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/"/>
    <id>https://cjay.life/2020/07/13/%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92/</id>
    <published>2020-07-13T14:46:14.000Z</published>
    <updated>2020-07-13T14:55:02.274Z</updated>
    
    <content type="html"><![CDATA[<p>7-9 旅游规划 (25分)</p><p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入数据的第1行给出4个正整数<em>N</em>、<em>M</em>、<em>S</em>、<em>D</em>，其中<em>N</em>（2≤<em>N</em>≤500）是城市的个数，顺便假设城市的编号为0~(<em>N</em>−1)；<em>M</em>是高速公路的条数；<em>S</em>是出发地的城市编号；<em>D</em>是目的地的城市编号。随后的<em>M</em>行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 40</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M,S,D;</span><br><span class="line">int visited[505];</span><br><span class="line">int cost[505];</span><br><span class="line">int dist[505];</span><br><span class="line">int costs[505][505];</span><br><span class="line">int graph[505][505];</span><br><span class="line">int t1,t2,t3,t4;</span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;505;i++)&#123;</span><br><span class="line">for(int j &#x3D; 0;j&lt;505;j++)&#123;</span><br><span class="line">if(i!&#x3D;j)&#123;</span><br><span class="line">costs[i][j] &#x3D; 65535;</span><br><span class="line">graph[i][j] &#x3D; 65535;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Dijkstra(int s)&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;&#x2F;&#x2F;初始化</span><br><span class="line">cost[i] &#x3D; costs[s][i];</span><br><span class="line">dist[i] &#x3D; graph[s][i];</span><br><span class="line">&#125;</span><br><span class="line">while(1)&#123;</span><br><span class="line">int min &#x3D; 65535;</span><br><span class="line">int v &#x3D; -1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((i!&#x3D;s)&amp;&amp;(visited[i] &#x3D;&#x3D; 0)&amp;&amp;(graph[s][i]&lt;min))&#123;</span><br><span class="line">v &#x3D; i;</span><br><span class="line">min &#x3D; graph[s][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(v &#x3D;&#x3D; -1) break;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((visited[i] &#x3D;&#x3D; 0)&amp;&amp;(dist[v]+graph[v][i]&lt;dist[i]))&#123;</span><br><span class="line">dist[i] &#x3D; dist[v] + graph[v][i];</span><br><span class="line">cost[i] &#x3D; cost[v]+costs[v][i];</span><br><span class="line">&#125;else if((dist[v]+graph[v][i] &#x3D;&#x3D; dist[i])&amp;&amp;(cost[v]+costs[v][i]&lt;cost[i]))&#123;</span><br><span class="line">cost[i] &#x3D; cost[v] + costs[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;D;</span><br><span class="line">reset();&#x2F;&#x2F;初始化</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3&gt;&gt;t4;</span><br><span class="line">graph[t1][t2] &#x3D; t3;</span><br><span class="line">graph[t2][t1] &#x3D; t3;</span><br><span class="line">costs[t1][t2] &#x3D; t4;</span><br><span class="line">costs[t2][t1] &#x3D; t4;</span><br><span class="line">&#125;</span><br><span class="line">Dijkstra(S);</span><br><span class="line">cout&lt;&lt;dist[D]&lt;&lt;&quot; &quot;&lt;&lt;cost[D];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他变型问题"><a href="#其他变型问题" class="headerlink" title="其他变型问题"></a>其他变型问题</h3><p>要求数最短路径有几条</p><ol><li>初始化起点:count[s] = 1;</li><li>如果找到更短路：count[w] = count[v];</li><li>如果找到等长路：count[w]+=count[v];</li></ol><p>要求边数最少的最短路</p><pre><code>1. counts[s] = 0; 2. 如果找到更短路：count[w] = count[v]+1; 3. 如果找到等长路:  count[w] = count[v] + 1;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-9 旅游规划 (25分)&lt;/p&gt;
&lt;p&gt;有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="Dijkstra" scheme="https://cjay.life/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>关键路径</title>
    <link href="https://cjay.life/2020/07/13/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    <id>https://cjay.life/2020/07/13/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</id>
    <published>2020-07-13T13:28:14.000Z</published>
    <updated>2020-07-13T13:42:09.499Z</updated>
    
    <content type="html"><![CDATA[<p>AOE（Activity On Edge,与AOV区别）网络</p><p>计算整个工期就是 计算最早完成时间</p><p>机动时间： D&lt;i,j&gt; = Latest[j] - Earliest[i] - C&lt;i,j&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AOE（Activity On Edge,与AOV区别）网络&lt;/p&gt;
&lt;p&gt;计算整个工期就是 计算最早完成时间&lt;/p&gt;
&lt;p&gt;机动时间： D&amp;lt;i,j&amp;gt; = Latest[j] - Earliest[i] - C&amp;lt;i,j&amp;gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="关键路径" scheme="https://cjay.life/tags/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://cjay.life/2020/07/13/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://cjay.life/2020/07/13/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2020-07-13T10:58:20.000Z</published>
    <updated>2020-07-13T14:46:40.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拓扑序定义"><a href="#拓扑序定义" class="headerlink" title="拓扑序定义"></a>拓扑序定义</h1><p>如果图中从v到w有一条有向途径,则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。</p><p>获得一个拓扑序的过程就是拓扑排序</p><p>Activity On Vertex (AOV) 网络如果有合理的拓扑序，则必定是有向无环图（Directed Acylic Grapg,DAG）</p><h1 id="算法伪代码"><a href="#算法伪代码" class="headerlink" title="算法伪代码"></a>算法伪代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void TopSort()&#123;</span><br><span class="line">for(cnt &#x3D; 0;cnt&lt;v;cnt++)&#123;</span><br><span class="line">v &#x3D; 未输出的入度为0的顶点；&#x2F;&#x2F;O(V)</span><br><span class="line">if(这样的v不存在)&#123;</span><br><span class="line">Error(“图中有回路”);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">输出v，或者记录v的输出序号;</span><br><span class="line">for(v的每个邻接点)</span><br><span class="line">Indegree[w]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(V2)</span><br></pre></td></tr></table></figure><h1 id="聪明的算法"><a href="#聪明的算法" class="headerlink" title="聪明的算法"></a>聪明的算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;随时将入度变为0的顶点放到一个容器里</span><br><span class="line">void TopSort()&#123;</span><br><span class="line">for(图中每个顶点 v)</span><br><span class="line">if(Indegree[v] &#x3D;&#x3D; 0)</span><br><span class="line">enqueue(v,q);</span><br><span class="line">while(!isempty(q))&#123;</span><br><span class="line">v &#x3D; dequeue(q);</span><br><span class="line">输出v,或者记录v的输出序号;cnt++</span><br><span class="line">for(v 的每个邻接点 w)</span><br><span class="line">if(--Indegree[W] &#x3D;&#x3D; 0)</span><br><span class="line">enqueue(W,Q);</span><br><span class="line">&#125;</span><br><span class="line">if( cnt !&#x3D; v)</span><br><span class="line">error(“图中有回路”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(V+E)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;拓扑序定义&quot;&gt;&lt;a href=&quot;#拓扑序定义&quot; class=&quot;headerlink&quot; title=&quot;拓扑序定义&quot;&gt;&lt;/a&gt;拓扑序定义&lt;/h1&gt;&lt;p&gt;如果图中从v到w有一条有向途径,则v一定排在w之前。满足此条件的顶点序列称为一个拓扑序。&lt;/p&gt;
&lt;p&gt;获得一个拓扑
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="拓扑排序" scheme="https://cjay.life/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树问题(Minimum Spanning Tree)</title>
    <link href="https://cjay.life/2020/07/13/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/"/>
    <id>https://cjay.life/2020/07/13/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-13T09:48:18.000Z</published>
    <updated>2020-07-13T13:16:13.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>最小生成树首先是一棵树</p><ol><li>无回路</li><li>V个顶点一定有V-1条边</li></ol><p>是生成树</p><ol><li>包含全部顶点</li><li>V-1条边都在图里</li></ol><p>边的权重和最小</p><h1 id="生成最小生成树的算法思想（贪心思想）"><a href="#生成最小生成树的算法思想（贪心思想）" class="headerlink" title="生成最小生成树的算法思想（贪心思想）"></a>生成最小生成树的算法思想（贪心思想）</h1><p>每一步都是选最好的（权重最小的边）</p><p>选择过程中的约束：</p><ol><li>只能用图里的边</li><li>只能一种选择v-1条边</li><li>不能有回路</li></ol><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><p>类似Dijikastra算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">v &#x3D; 未收录顶点中dist最小值;</span><br><span class="line">if(这样的v不存在)</span><br><span class="line">break;</span><br><span class="line">collected[v] &#x3D; true;</span><br><span class="line">for(v 的每个邻接点 w)&#123;</span><br><span class="line">if((collected[w] &#x3D;&#x3D; false) &amp;&amp; (dist[v] + E&lt;v,w&gt; &lt; dist[w]))&#123;</span><br><span class="line">dist[w] &#x3D; dist[v] + E[v,w]l</span><br><span class="line">path[w] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void Prim()&#123;</span><br><span class="line">MST &#x3D; &#123;s&#125;;</span><br><span class="line">while(1)&#123;</span><br><span class="line">v &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">if(这样v不存在)</span><br><span class="line">break;</span><br><span class="line">将v收录进MST: dist[v] &#x3D; 0;</span><br><span class="line">for(v 的每个邻接点 w)&#123;</span><br><span class="line">if(dist[w] !&#x3D; 0)&#123;</span><br><span class="line">if(E&lt;v,w&gt; &lt;dist[w])&#123;</span><br><span class="line">dist[w] &#x3D; E&lt;v,w&gt;;</span><br><span class="line">parent[W] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(MST中收的顶点不到V个)</span><br><span class="line">Error(“生成树不存在”);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;dist[v] &#x3D; E&lt;s,v&gt; 或 正无穷</span><br><span class="line">&#x2F;&#x2F;parent[s] &#x3D; -1</span><br><span class="line">&#x2F;&#x2F;T &#x3D; O(v2) 稠密图合算</span><br></pre></td></tr></table></figure><h2 id="Kruskal算法（将森林合并成树）"><a href="#Kruskal算法（将森林合并成树）" class="headerlink" title="Kruskal算法（将森林合并成树）"></a>Kruskal算法（将森林合并成树）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void Kruskal (Graph G)&#123;</span><br><span class="line">MST &#x3D; &#123;&#125;;</span><br><span class="line">while(MST中不到|V|-1条边 &amp;&amp; E中还有边)&#123;</span><br><span class="line">从E中取一条权重最小边 &#x2F;*最小堆*&#x2F;</span><br><span class="line">将E&lt;v,w&gt;从E中删除；</span><br><span class="line">if(E&lt;v,w&gt;不在MST中构成回路) &#x2F;*并查集*&#x2F;</span><br><span class="line"> E(V,W) 加入 MST;</span><br><span class="line">else</span><br><span class="line">彻底无视 E(V,W);</span><br><span class="line">&#125;</span><br><span class="line">if ( MST 中不到 |V|-1 条边 )</span><br><span class="line">Error ( “生成树不存在” );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; T &#x3D; O(ElogE)</span><br></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 邻接矩阵存储 - Prim最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">Vertex FindMinDist( MGraph Graph, WeightType dist[] )</span><br><span class="line">&#123; &#x2F;* 返回未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">    Vertex MinV, V;</span><br><span class="line">    WeightType MinDist &#x3D; INFINITY;</span><br><span class="line"> </span><br><span class="line">    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        if ( dist[V]!&#x3D;0 &amp;&amp; dist[V]&lt;MinDist) &#123;</span><br><span class="line">            &#x2F;* 若V未被收录，且dist[V]更小 *&#x2F;</span><br><span class="line">            MinDist &#x3D; dist[V]; &#x2F;* 更新最小距离 *&#x2F;</span><br><span class="line">            MinV &#x3D; V; &#x2F;* 更新对应顶点 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (MinDist &lt; INFINITY) &#x2F;* 若找到最小dist *&#x2F;</span><br><span class="line">        return MinV; &#x2F;* 返回对应的顶点下标 *&#x2F;</span><br><span class="line">    else return ERROR;  &#x2F;* 若这样的顶点不存在，返回-1作为标记 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int Prim( MGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType dist[MaxVertexNum], TotalWeight;</span><br><span class="line">    Vertex parent[MaxVertexNum], V, W;</span><br><span class="line">    int VCount;</span><br><span class="line">    Edge E;</span><br><span class="line">     </span><br><span class="line">    &#x2F;* 初始化。默认初始点下标是0 *&#x2F;</span><br><span class="line">       for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;</span><br><span class="line">        &#x2F;* 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY *&#x2F;</span><br><span class="line">           dist[V] &#x3D; Graph-&gt;G[0][V];</span><br><span class="line">           parent[V] &#x3D; 0; &#x2F;* 暂且定义所有顶点的父结点都是初始点0 *&#x2F; </span><br><span class="line">    &#125;</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    VCount &#x3D; 0;      &#x2F;* 初始化收录的顶点数 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    E &#x3D; (Edge)malloc( sizeof(struct ENode) ); &#x2F;* 建立空的边结点 *&#x2F;</span><br><span class="line">            </span><br><span class="line">    &#x2F;* 将初始点0收录进MST *&#x2F;</span><br><span class="line">    dist[0] &#x3D; 0;</span><br><span class="line">    VCount ++;</span><br><span class="line">    parent[0] &#x3D; -1; &#x2F;* 当前树根是0 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    while (1) &#123;</span><br><span class="line">        V &#x3D; FindMinDist( Graph, dist );</span><br><span class="line">        &#x2F;* V &#x3D; 未被收录顶点中dist最小者 *&#x2F;</span><br><span class="line">        if ( V&#x3D;&#x3D;ERROR ) &#x2F;* 若这样的V不存在 *&#x2F;</span><br><span class="line">            break;   &#x2F;* 算法结束 *&#x2F;</span><br><span class="line">             </span><br><span class="line">        &#x2F;* 将V及相应的边&lt;parent[V], V&gt;收录进MST *&#x2F;</span><br><span class="line">        E-&gt;V1 &#x3D; parent[V];</span><br><span class="line">        E-&gt;V2 &#x3D; V;</span><br><span class="line">        E-&gt;Weight &#x3D; dist[V];</span><br><span class="line">        InsertEdge( MST, E );</span><br><span class="line">        TotalWeight +&#x3D; dist[V];</span><br><span class="line">        dist[V] &#x3D; 0;</span><br><span class="line">        VCount++;</span><br><span class="line">         </span><br><span class="line">        for( W&#x3D;0; W&lt;Graph-&gt;Nv; W++ ) &#x2F;* 对图中的每个顶点W *&#x2F;</span><br><span class="line">            if ( dist[W]!&#x3D;0 &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;</span><br><span class="line">            &#x2F;* 若W是V的邻接点并且未被收录 *&#x2F;</span><br><span class="line">                if ( Graph-&gt;G[V][W] &lt; dist[W] ) &#123;</span><br><span class="line">                &#x2F;* 若收录V使得dist[W]变小 *&#x2F;</span><br><span class="line">                    dist[W] &#x3D; Graph-&gt;G[V][W]; &#x2F;* 更新dist[W] *&#x2F;</span><br><span class="line">                    parent[W] &#x3D; V; &#x2F;* 更新树 *&#x2F;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; &#x2F;* while结束*&#x2F;</span><br><span class="line">    if ( VCount &lt; Graph-&gt;Nv ) &#x2F;* MST中收的顶点不到|V|个 *&#x2F;</span><br><span class="line">       TotalWeight &#x3D; ERROR;</span><br><span class="line">    return TotalWeight;   &#x2F;* 算法执行完毕，返回最小权重和或错误标记 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 邻接表存储 - Kruskal最小生成树算法 *&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 顶点并查集定义 --------------------*&#x2F;</span><br><span class="line">typedef Vertex ElementType; &#x2F;* 默认元素可以用非负整数表示 *&#x2F;</span><br><span class="line">typedef Vertex SetName;     &#x2F;* 默认用根结点的下标作为集合名称 *&#x2F;</span><br><span class="line">typedef ElementType SetType[MaxVertexNum]; &#x2F;* 假设集合元素下标从0开始 *&#x2F;</span><br><span class="line"> </span><br><span class="line">void InitializeVSet( SetType S, int N )</span><br><span class="line">&#123; &#x2F;* 初始化并查集 *&#x2F;</span><br><span class="line">    ElementType X;</span><br><span class="line"> </span><br><span class="line">    for ( X&#x3D;0; X&lt;N; X++ ) S[X] &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Union( SetType S, SetName Root1, SetName Root2 )</span><br><span class="line">&#123; &#x2F;* 这里默认Root1和Root2是不同集合的根结点 *&#x2F;</span><br><span class="line">    &#x2F;* 保证小集合并入大集合 *&#x2F;</span><br><span class="line">    if ( S[Root2] &lt; S[Root1] ) &#123; &#x2F;* 如果集合2比较大 *&#x2F;</span><br><span class="line">        S[Root2] +&#x3D; S[Root1];     &#x2F;* 集合1并入集合2  *&#x2F;</span><br><span class="line">        S[Root1] &#x3D; Root2;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;                         &#x2F;* 如果集合1比较大 *&#x2F;</span><br><span class="line">        S[Root1] +&#x3D; S[Root2];     &#x2F;* 集合2并入集合1  *&#x2F;</span><br><span class="line">        S[Root2] &#x3D; Root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">SetName Find( SetType S, ElementType X )</span><br><span class="line">&#123; &#x2F;* 默认集合元素全部初始化为-1 *&#x2F;</span><br><span class="line">    if ( S[X] &lt; 0 ) &#x2F;* 找到集合的根 *&#x2F;</span><br><span class="line">        return X;</span><br><span class="line">    else</span><br><span class="line">        return S[X] &#x3D; Find( S, S[X] ); &#x2F;* 路径压缩 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )</span><br><span class="line">&#123; &#x2F;* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 *&#x2F;</span><br><span class="line">    Vertex Root1, Root2;</span><br><span class="line"> </span><br><span class="line">    Root1 &#x3D; Find( VSet, V1 ); &#x2F;* 得到V1所属的连通集名称 *&#x2F;</span><br><span class="line">    Root2 &#x3D; Find( VSet, V2 ); &#x2F;* 得到V2所属的连通集名称 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    if( Root1&#x3D;&#x3D;Root2 ) &#x2F;* 若V1和V2已经连通，则该边不能要 *&#x2F;</span><br><span class="line">        return false;</span><br><span class="line">    else &#123; &#x2F;* 否则该边可以被收集，同时将V1和V2并入同一连通集 *&#x2F;</span><br><span class="line">        Union( VSet, Root1, Root2 );</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 并查集定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line">&#x2F;*-------------------- 边的最小堆定义 --------------------*&#x2F;</span><br><span class="line">void PercDown( Edge ESet, int p, int N )</span><br><span class="line">&#123; &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p )    *&#x2F;</span><br><span class="line">  &#x2F;* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 *&#x2F;</span><br><span class="line">    int Parent, Child;</span><br><span class="line">    struct ENode X;</span><br><span class="line"> </span><br><span class="line">    X &#x3D; ESet[p]; &#x2F;* 取出根结点存放的值 *&#x2F;</span><br><span class="line">    for( Parent&#x3D;p; (Parent*2+1)&lt;N; Parent&#x3D;Child ) &#123;</span><br><span class="line">        Child &#x3D; Parent * 2 + 1;</span><br><span class="line">        if( (Child!&#x3D;N-1) &amp;&amp; (ESet[Child].Weight&gt;ESet[Child+1].Weight) )</span><br><span class="line">            Child++;  &#x2F;* Child指向左右子结点的较小者 *&#x2F;</span><br><span class="line">        if( X.Weight &lt;&#x3D; ESet[Child].Weight ) break; &#x2F;* 找到了合适位置 *&#x2F;</span><br><span class="line">        else  &#x2F;* 下滤X *&#x2F;</span><br><span class="line">            ESet[Parent] &#x3D; ESet[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    ESet[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void InitializeESet( LGraph Graph, Edge ESet )</span><br><span class="line">&#123; &#x2F;* 将图的边存入数组ESet，并且初始化为最小堆 *&#x2F;</span><br><span class="line">    Vertex V;</span><br><span class="line">    PtrToAdjVNode W;</span><br><span class="line">    int ECount;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将图的边存入数组ESet *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;</span><br><span class="line">    for ( V&#x3D;0; V&lt;Graph-&gt;Nv; V++ )</span><br><span class="line">        for ( W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next )</span><br><span class="line">            if ( V &lt; W-&gt;AdjV ) &#123; &#x2F;* 避免重复录入无向图的边，只收V1&lt;V2的边 *&#x2F;</span><br><span class="line">                ESet[ECount].V1 &#x3D; V;</span><br><span class="line">                ESet[ECount].V2 &#x3D; W-&gt;AdjV;</span><br><span class="line">                ESet[ECount++].Weight &#x3D; W-&gt;Weight;</span><br><span class="line">            &#125;</span><br><span class="line">    &#x2F;* 初始化为最小堆 *&#x2F;</span><br><span class="line">    for ( ECount&#x3D;Graph-&gt;Ne&#x2F;2; ECount&gt;&#x3D;0; ECount-- )</span><br><span class="line">        PercDown( ESet, ECount, Graph-&gt;Ne );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int GetEdge( Edge ESet, int CurrentSize )</span><br><span class="line">&#123; &#x2F;* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;* 将最小边与当前堆的最后一个位置的边交换 *&#x2F;</span><br><span class="line">    Swap( &amp;ESet[0], &amp;ESet[CurrentSize-1]);</span><br><span class="line">    &#x2F;* 将剩下的边继续调整成最小堆 *&#x2F;</span><br><span class="line">    PercDown( ESet, 0, CurrentSize-1 );</span><br><span class="line"> </span><br><span class="line">    return CurrentSize-1; &#x2F;* 返回最小边所在位置 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*-------------------- 最小堆定义结束 --------------------*&#x2F;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int Kruskal( LGraph Graph, LGraph MST )</span><br><span class="line">&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;</span><br><span class="line">    WeightType TotalWeight;</span><br><span class="line">    int ECount, NextEdge;</span><br><span class="line">    SetType VSet; &#x2F;* 顶点数组 *&#x2F;</span><br><span class="line">    Edge ESet;    &#x2F;* 边数组 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    InitializeVSet( VSet, Graph-&gt;Nv ); &#x2F;* 初始化顶点并查集 *&#x2F;</span><br><span class="line">    ESet &#x3D; (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne );</span><br><span class="line">    InitializeESet( Graph, ESet ); &#x2F;* 初始化边的最小堆 *&#x2F;</span><br><span class="line">    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;</span><br><span class="line">    MST &#x3D; CreateGraph(Graph-&gt;Nv);</span><br><span class="line">    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;</span><br><span class="line">    ECount &#x3D; 0;      &#x2F;* 初始化收录的边数 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    NextEdge &#x3D; Graph-&gt;Ne; &#x2F;* 原始边集的规模 *&#x2F;</span><br><span class="line">    while ( ECount &lt; Graph-&gt;Nv-1 ) &#123;  &#x2F;* 当收集的边不足以构成树时 *&#x2F;</span><br><span class="line">        NextEdge &#x3D; GetEdge( ESet, NextEdge ); &#x2F;* 从边集中得到最小边的位置 *&#x2F;</span><br><span class="line">        if (NextEdge &lt; 0) &#x2F;* 边集已空 *&#x2F;</span><br><span class="line">            break;</span><br><span class="line">        &#x2F;* 如果该边的加入不构成回路，即两端结点不属于同一连通集 *&#x2F;</span><br><span class="line">        if ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )&#x3D;&#x3D;true ) &#123;</span><br><span class="line">            &#x2F;* 将该边插入MST *&#x2F;</span><br><span class="line">            InsertEdge( MST, ESet+NextEdge );</span><br><span class="line">            TotalWeight +&#x3D; ESet[NextEdge].Weight; &#x2F;* 累计权重 *&#x2F;</span><br><span class="line">            ECount++; &#x2F;* 生成树中边数加1 *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( ECount &lt; Graph-&gt;Nv-1 )</span><br><span class="line">        TotalWeight &#x3D; -1; &#x2F;* 设置错误标记，表示生成树不存在 *&#x2F;</span><br><span class="line"> </span><br><span class="line">    return TotalWeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;最小生成树首先是一棵树&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无回路&lt;/li&gt;
&lt;li&gt;V个顶点一定有V-1条边&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;是生成树&lt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最小生成树" scheme="https://cjay.life/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈利·波特的考试</title>
    <link href="https://cjay.life/2020/07/13/%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/"/>
    <id>https://cjay.life/2020/07/13/%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95/</id>
    <published>2020-07-13T09:06:16.000Z</published>
    <updated>2020-07-13T09:09:36.107Z</updated>
    
    <content type="html"><![CDATA[<p>7-8 哈利·波特的考试 (25分)</p><p>哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。</p><p>现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入说明：输入第1行给出两个正整数<em>N</em> (≤100)和<em>M</em>，其中<em>N</em>是考试涉及的动物总数，<em>M</em>是用于直接变形的魔咒条数。为简单起见，我们将动物按1~<em>N</em>编号。随后<em>M</em>行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">6 11</span><br><span class="line">3 4 70</span><br><span class="line">1 2 1</span><br><span class="line">5 4 50</span><br><span class="line">2 6 50</span><br><span class="line">5 6 60</span><br><span class="line">1 3 70</span><br><span class="line">4 6 60</span><br><span class="line">3 6 80</span><br><span class="line">5 1 100</span><br><span class="line">2 4 60</span><br><span class="line">5 2 80</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 70</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int D[105][105];</span><br><span class="line">int N,M;</span><br><span class="line">int t1,t2,t3;</span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">if(i!&#x3D;j)</span><br><span class="line">D[i][j] &#x3D; 65535; &#x2F;&#x2F;floyd算法要求无边就初始化为正无穷</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void floyd()&#123;</span><br><span class="line">for(int k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(D[i][k]+D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">D[i][j] &#x3D; D[i][k]+D[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int FindMaxDist(int i)&#123;</span><br><span class="line">int maxdist &#x3D; 0;</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(i!&#x3D;j &amp;&amp; D[i][j]&gt;maxdist)</span><br><span class="line">maxdist &#x3D; D[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;maxdist&lt;&lt;&#39;\n&#39;; </span><br><span class="line">return maxdist;</span><br><span class="line">&#125;</span><br><span class="line">void FindMinDist()&#123;</span><br><span class="line">int mindist &#x3D; 65535;</span><br><span class="line">int animal;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">int maxdist &#x3D; FindMaxDist(i);</span><br><span class="line">if(maxdist &#x3D;&#x3D; 65535)&#123;</span><br><span class="line">printf(&quot;0\n&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(mindist&gt;maxdist)&#123;</span><br><span class="line">mindist &#x3D; maxdist;</span><br><span class="line">animal &#x3D; i+1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d %d\n&quot;,animal,mindist);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">reset();</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;</span><br><span class="line">D[t1-1][t2-1] &#x3D; t3;&#x2F;&#x2F;位置偏移</span><br><span class="line">D[t2-1][t1-1] &#x3D; t3;</span><br><span class="line">&#125;</span><br><span class="line">floyd();</span><br><span class="line">&#x2F;&#x2F;for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">&#x2F;&#x2F;for(int j &#x3D; 0;j&lt;N;j++)</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;D[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">FindMinDist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-8 哈利·波特的考试 (25分)&lt;/p&gt;
&lt;p&gt;哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最短路径，floyd" scheme="https://cjay.life/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%8Cfloyd/"/>
    
  </entry>
  
  <entry>
    <title>最短路径问题</title>
    <link href="https://cjay.life/2020/07/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/"/>
    <id>https://cjay.life/2020/07/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-07-10T12:25:18.000Z</published>
    <updated>2020-07-13T09:09:50.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路径问题的抽象"><a href="#最短路径问题的抽象" class="headerlink" title="最短路径问题的抽象"></a>最短路径问题的抽象</h1><p>最短路径就是源点（Source）和终点（Destination）之间权值之和最小的一条路径</p><h1 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h1><ol><li>单元最短路径问题：一点到其他顶点的最短路径<ol><li>（有向）无权图</li><li>（有向）有权图</li></ol></li><li>多源最短路径问题：任意两点之间的最短路径</li></ol><h1 id="无权图的单源最短路算法"><a href="#无权图的单源最短路算法" class="headerlink" title="无权图的单源最短路算法"></a>无权图的单源最短路算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;本质就是BFS的变型</span><br><span class="line">&#x2F;&#x2F;dist[w] &#x3D; S到W的最短距离</span><br><span class="line">&#x2F;&#x2F;dist[S] &#x3D; 0</span><br><span class="line">&#x2F;&#x2F;path[W] &#x3D; S到W的路上经过的某顶点（确切说是上个顶点）</span><br><span class="line">void Unweighted(Vertex S)&#123;</span><br><span class="line">Enqueue(S,Q);</span><br><span class="line">while(!IsEpmty(Q)))&#123;</span><br><span class="line">v &#x3D; Dequeue(Q);</span><br><span class="line">for(V 的每个邻接点 W)&#123;</span><br><span class="line">if(dist[W] &#x3D;&#x3D; -1)&#123;</span><br><span class="line">dist[W] &#x3D; dist[V]+1;</span><br><span class="line">path[W] &#x3D; V;</span><br><span class="line">enqueue(W,Q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有权图的单源最短路算法"><a href="#有权图的单源最短路算法" class="headerlink" title="有权图的单源最短路算法"></a>有权图的单源最短路算法</h1><p><strong><em>Dijkstra算法(按照递增的顺序找到各个顶点的最短路)</em></strong></p><p><strong>前提是不存在负值圈</strong></p><ol><li>令S={源点s + 已经确定了最短路径的顶点vi}</li><li>对不属于集合S的顶点v，定义dist[v]为s到v的最短路径长度，但该路径<em>仅仅经过S中的顶点。</em>即路径{s-&gt;(vi∈S)-&gt;v}的长度</li><li>若路径是按照递增的顺序生成的，则<ol><li>真正的最短路必须只经过S中的顶点（反证法：若存在另外一个结点，那也应该是这一个结点先被收录）</li><li>每次从未收录的顶点中选一个dist最小的收录（贪心）</li><li>增加一个v进入S，可能影响另外一个w的dist值（min{dist[w], dist[v] + &lt;v,w&gt;的权重}）</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Dijkstra(Vertex s)&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">V &#x3D; 未收录顶点中dist最小者;</span><br><span class="line">if(这样v不存在)</span><br><span class="line">break;</span><br><span class="line">collected[v] &#x3D; true;</span><br><span class="line">for(v 的每个邻接点 W)</span><br><span class="line">if(collected[W] &#x3D;&#x3D; false)&#123;</span><br><span class="line">if(dist[v]+E&lt;v,w&gt; &lt; dist[W])&#123;</span><br><span class="line">dist[W] &#x3D; dist[V] + E&lt;v,w&gt;;</span><br><span class="line">path[W] &#x3D; v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若将dist的值存在数组和堆中会产生不同的效果：</p><ol><li>数组中 T=O（V2 + E）适合稠密图</li><li>最小堆中<ol><li>更新dist[w] = O(logv)</li><li>T = O(VlogV + ElogV) = O(Elogv) 适合稀疏图</li></ol></li></ol><h1 id="多源最短路算法"><a href="#多源最短路算法" class="headerlink" title="多源最短路算法"></a>多源最短路算法</h1><ol><li>直接将单元最短路径算法调用V遍 T = O（V3 + E*V）</li><li>Floyd算法 T = O（V3）</li></ol><p>Floyd 算法 </p><ol><li>Dk[i][j] = 路径{i -&gt; {l&lt;=k} -&gt; j}的最小长度</li><li>D0,D1,…,DV-1[i][j]即给出了i到j的真正最短距离</li><li>最初的D-1（如果ij没边，初始化为正无穷）</li><li>Dk-1已经完成，递推到Dk时：<ol><li>或者k不∈最短路径{i-&gt;{l&lt;=k}-&gt;j},则Dk = Dk-1</li><li>或者k∈最短路径,则该路径由两端最短路径组成：Dk[i][j] = Dk-1[i][k] + Dk-1[k][j]</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void Floyd()&#123;</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line"> for(j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line"> D[i][j] &#x3D; G[i][j];</span><br><span class="line"> path[i][j] &#x3D; -1;&#x2F;&#x2F;用来打印路径用</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(k &#x3D; 0;k&lt;N;k++)&#123;</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">for(j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">if(D[i][k]+ D[k][j] &lt; D[i][j])&#123;</span><br><span class="line">D[i][j] &#x3D; D[i][k] + D[k][j];</span><br><span class="line">path[i][j] &#x3D; k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最短路径问题的抽象&quot;&gt;&lt;a href=&quot;#最短路径问题的抽象&quot; class=&quot;headerlink&quot; title=&quot;最短路径问题的抽象&quot;&gt;&lt;/a&gt;最短路径问题的抽象&lt;/h1&gt;&lt;p&gt;最短路径就是源点（Source）和终点（Destination）之间权值之和最小的一
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
      <category term="最短路径" scheme="https://cjay.life/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>2020-7-9</title>
    <link href="https://cjay.life/2020/07/09/2020-7-9/"/>
    <id>https://cjay.life/2020/07/09/2020-7-9/</id>
    <published>2020-07-09T09:31:07.000Z</published>
    <updated>2020-07-09T09:31:07.468Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>1064 Complete Binary Search Tree (30分)</title>
    <link href="https://cjay.life/2020/07/06/1064-Complete-Binary-Search-Tree-30%E5%88%86/"/>
    <id>https://cjay.life/2020/07/06/1064-Complete-Binary-Search-Tree-30%E5%88%86/</id>
    <published>2020-07-06T15:36:25.000Z</published>
    <updated>2020-07-06T15:38:17.314Z</updated>
    
    <content type="html"><![CDATA[<p>1064 Complete Binary Search Tree (30分)</p><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p><p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 3 8 1 5 7 9 0 2 4</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int num[1005];</span><br><span class="line">int ans[1005];</span><br><span class="line">int N;</span><br><span class="line">int getMid(int l,int r)&#123;</span><br><span class="line">int sum &#x3D; r-l+1;&#x2F;&#x2F;总数</span><br><span class="line">int layer &#x3D; floor(log(sum+1)&#x2F;log(2)); &#x2F;&#x2F;除最后一层的层数，</span><br><span class="line">int lastlayerleaf &#x3D; sum+1-pow(2,layer);&#x2F;&#x2F;最后一层的节点数</span><br><span class="line">int leftnum &#x3D; pow(2,layer-1)-1+min(lastlayerleaf,(int)pow(2,layer-1));&#x2F;&#x2F;左子树结点总数</span><br><span class="line">return l+leftnum; &#x2F;&#x2F;根位置</span><br><span class="line">&#125; </span><br><span class="line">void solve(int l,int r,int root)&#123;</span><br><span class="line">if(r-l+1 &#x3D;&#x3D; 0) return;</span><br><span class="line">int mid &#x3D; getMid(l,r);</span><br><span class="line">ans[root] &#x3D; num[mid];</span><br><span class="line">solve(l,mid-1,root*2+1);</span><br><span class="line">solve(mid+1,r,root*2+2); </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line">for(int i&#x3D;0;i&lt;N;i++)</span><br><span class="line">cin&gt;&gt;num[i];</span><br><span class="line">sort(num,num+N);</span><br><span class="line">solve(0,N-1,0);</span><br><span class="line">cout&lt;&lt;ans[0];</span><br><span class="line">for(int i &#x3D; 1;i&lt;N;i++)</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1064 Complete Binary Search Tree (30分)&lt;/p&gt;
&lt;p&gt;A Binary Search Tree (BST) is recursively defined as a binary tree which has the following 
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树，公式推导" scheme="https://cjay.life/tags/%E6%A0%91%EF%BC%8C%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>1086 Tree Traversals Again (25分)</title>
    <link href="https://cjay.life/2020/07/06/1086-Tree-Traversals-Again-25%E5%88%86/"/>
    <id>https://cjay.life/2020/07/06/1086-Tree-Traversals-Again-25%E5%88%86/</id>
    <published>2020-07-06T14:31:55.000Z</published>
    <updated>2020-07-06T14:34:55.193Z</updated>
    
    <content type="html"><![CDATA[<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p><p><img src="https://images.ptausercontent.com/30" alt="img"><br>Figure 1</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 2 6 5 1</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,n,i,j,k;</span><br><span class="line">string s;</span><br><span class="line">int preorder[35];</span><br><span class="line">int inorder[35];</span><br><span class="line">int postorder[35];</span><br><span class="line">void porder(int ileft,int iright,int pleft,int pright)&#123;&#x2F;&#x2F;核心算法</span><br><span class="line">if((ileft&gt;iright)||(pleft&gt;pright))</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">postorder[k++] &#x3D; preorder[pleft];</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;postorder[k-1]&lt;&lt;endl;</span><br><span class="line">for(i &#x3D; ileft;i&lt;&#x3D;iright;i++)&#123;</span><br><span class="line">if(inorder[i] &#x3D;&#x3D; preorder[pleft])</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">porder(i+1,iright,pleft+1+i-ileft,pright);</span><br><span class="line">porder(ileft,i-1,pleft+1,pleft+i-ileft);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line">int NN &#x3D; 2*N;</span><br><span class="line">stack&lt;int&gt; ss;</span><br><span class="line">while(NN--)&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">if(s&#x3D;&#x3D;&quot;Push&quot;)&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">ss.push(n);</span><br><span class="line">preorder[i++] &#x3D; n;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">n &#x3D; ss.top();</span><br><span class="line">ss.pop();</span><br><span class="line">inorder[j++] &#x3D; n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">porder(0,N-1,0,N-1);</span><br><span class="line">cout&lt;&lt;postorder[N-1];</span><br><span class="line">for(int j &#x3D; N-2;j&gt;&#x3D;0;j--)&#123;</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;postorder[j];</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary t
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树的遍历" scheme="https://cjay.life/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>关于高效学习</title>
    <link href="https://cjay.life/2020/07/06/%E5%85%B3%E4%BA%8E%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    <id>https://cjay.life/2020/07/06/%E5%85%B3%E4%BA%8E%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-06T04:38:50.000Z</published>
    <updated>2020-07-06T05:01:54.023Z</updated>
    
    <content type="html"><![CDATA[<p>看完高效学习篇之后，想要进一步将知识缩减，并带入自己的思考。</p><h1 id="端正学习态度"><a href="#端正学习态度" class="headerlink" title="端正学习态度"></a>端正学习态度</h1><p><img src="https://dingyue.ws.126.net/d62vefHcMwmSZZFe0RXktPa4DG1hElKx4fjzHitgkZx4v1571967477433.jpg" alt="推荐丨金字塔学习法，输出和实践最能提升学习效率_网易订阅"></p><p>在学习知识后，必须有对知识本身有着思考，总结与归纳，不断对这些知识进行应用，对外输出。</p><p>更详细得步骤：</p><ol><li>好的信息源头</li><li>将知识连成地图</li><li>对于知识本身反思与思辨</li><li>举一反三，进行应用</li></ol><h1 id="源头、原理和知识地图"><a href="#源头、原理和知识地图" class="headerlink" title="源头、原理和知识地图"></a>源头、原理和知识地图</h1><p>好的信息源头有如下特质:</p><ol><li>第一首资料</li><li>有佐证、有数据、有引用</li><li>加入了自己经验与思考</li></ol><p>注重基础和原理</p><p>将所有得知识串联起来。</p><h1 id="深度归纳和坚持实践"><a href="#深度归纳和坚持实践" class="headerlink" title="深度归纳和坚持实践"></a>深度归纳和坚持实践</h1><p>对于新技术，除了知识图，还需要问自己多个为什么？</p><ol><li>技术出现得背景、初衷和需要用来解决什么问题</li><li>该技术的优势和劣势</li><li>适用场景（所谓场景一般分别两个，一个是业务场景，一个是技术场景。）</li><li>技术的组成部分和关键点（技术的核心思想和核心组件）</li><li>技术的底层原理和关键实现</li><li>已有的实现和它之间的对比</li></ol><p>举一反三的能力：</p><ol><li>联想能力：对同一个事物的不同看法，联想相关事物</li><li>抽象能力：从不同问题中抽象出解的结构</li><li>自省能力：自己的不足</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完高效学习篇之后，想要进一步将知识缩减，并带入自己的思考。&lt;/p&gt;
&lt;h1 id=&quot;端正学习态度&quot;&gt;&lt;a href=&quot;#端正学习态度&quot; class=&quot;headerlink&quot; title=&quot;端正学习态度&quot;&gt;&lt;/a&gt;端正学习态度&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https:
      
    
    </summary>
    
    
      <category term="学习方法" scheme="https://cjay.life/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="学习方法，左耳朵耗子极客时间" scheme="https://cjay.life/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B7%A6%E8%80%B3%E6%9C%B5%E8%80%97%E5%AD%90%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>7-7 六度空间</title>
    <link href="https://cjay.life/2020/07/05/7-7-%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/"/>
    <id>https://cjay.life/2020/07/05/7-7-%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</id>
    <published>2020-07-05T13:56:26.000Z</published>
    <updated>2020-07-05T14:12:42.386Z</updated>
    
    <content type="html"><![CDATA[<p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p><p><img src="https://images.ptausercontent.com/35" alt="img"><br>图1 六度空间示意图</p><p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p><p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数，分别表示社交网络图的结点数<em>N</em>（1&lt;<em>N</em>≤103，表示人数）、边数<em>M</em>（≤33×<em>N</em>，表示社交关系数）。随后的<em>M</em>行对应<em>M</em>条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到<em>N</em>编号）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1: 70.00%</span><br><span class="line">2: 80.00%</span><br><span class="line">3: 90.00%</span><br><span class="line">4: 100.00%</span><br><span class="line">5: 100.00%</span><br><span class="line">6: 100.00%</span><br><span class="line">7: 100.00%</span><br><span class="line">8: 90.00%</span><br><span class="line">9: 80.00%</span><br><span class="line">10: 70.00%</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int v[1005][1005];</span><br><span class="line">int flag[1005];</span><br><span class="line">int t1,t2,sum;</span><br><span class="line">int BFS(int node)&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int count &#x3D; 1;</span><br><span class="line">int level &#x3D; 0;</span><br><span class="line">int last &#x3D; node;</span><br><span class="line">int tail;</span><br><span class="line">flag[node] &#x3D; 1;</span><br><span class="line">q.push(node);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">node &#x3D; q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">if((v[node][i] &#x3D;&#x3D; 1) &amp;&amp; (flag[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">flag[i] &#x3D; 1;</span><br><span class="line">q.push(i);</span><br><span class="line">count++;</span><br><span class="line">tail &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(node &#x3D;&#x3D; last)&#123;</span><br><span class="line">level++;</span><br><span class="line">last &#x3D; tail;</span><br><span class="line">&#125;</span><br><span class="line">if(level&#x3D;&#x3D;6) break;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">flag[i] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">v[t1][t2] &#x3D; 1;</span><br><span class="line">v[t2][t1] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 1 ;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">sum &#x3D; BFS(i);</span><br><span class="line">printf(&quot;%d: %.2f%%\n&quot;,i,(double)sum&#x2F;N*100);</span><br><span class="line">reset();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="该题要点"><a href="#该题要点" class="headerlink" title="该题要点"></a>该题要点</h3><p>这个题目在传统的BFS算法上进行改造，需要在BFS过程中记录当前遍历的层数。</p><p>这里再原来的基础上增加了三个变量 tail,last,level;</p><p>tail表示下一层的最后一个元素；</p><p>last表示当前层的最后一个元素；</p><p>level表示当前位于第几层；</p><hr><p>初始 tail不用设，last = node（第0层最后一个结点就是自己）,level = 0(自己不算）</p><hr><p>这里关键点是为什么能知道当前node是该层最后一个元素？</p><p>while循环中，最后判断时，弹出的当前结点node == last 时，表明：</p><p>该层最后一个结点已经被弹出，且下一层所有结点全在队列中了；</p><p>这个时候更改新一层的last，将last = tail，并将level++；</p><p>level的数值表示，当前i层的所有数据已经被访问完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="BFS" scheme="https://cjay.life/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>7-10 Saving James Bond - Easy Version</title>
    <link href="https://cjay.life/2020/07/05/7-10-Saving-James-Bond-Easy-Version/"/>
    <id>https://cjay.life/2020/07/05/7-10-Saving-James-Bond-Easy-Version/</id>
    <published>2020-07-05T12:51:32.000Z</published>
    <updated>2020-07-05T12:53:00.625Z</updated>
    
    <content type="html"><![CDATA[<p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p><p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if James can escape, or “No” if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">14 20</span><br><span class="line">25 -15</span><br><span class="line">-25 28</span><br><span class="line">8 49</span><br><span class="line">29 15</span><br><span class="line">-35 -2</span><br><span class="line">5 28</span><br><span class="line">27 -29</span><br><span class="line">-8 -28</span><br><span class="line">-20 -35</span><br><span class="line">-25 -20</span><br><span class="line">-13 29</span><br><span class="line">-30 15</span><br><span class="line">-35 40</span><br><span class="line">12 12</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 13</span><br><span class="line">-12 12</span><br><span class="line">12 12</span><br><span class="line">-12 -12</span><br><span class="line">12 -12</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> struct node&#123;</span><br><span class="line"> int x,y;</span><br><span class="line"> &#125;;</span><br><span class="line"> node cro[105];</span><br><span class="line"> int visited[105];</span><br><span class="line"> int N,D;</span><br><span class="line"> int t1,t2;</span><br><span class="line"> bool answer &#x3D; 0;</span><br><span class="line"> double distance(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line"> return pow(x2-x1,2)+pow(y2-y1,2);</span><br><span class="line"> &#125; </span><br><span class="line">  bool DFS(int x, int y,int n)&#123;</span><br><span class="line"> if((x-D&lt;&#x3D;-50)||(x+D&gt;&#x3D;50)||(y-D&lt;&#x3D;-50)||(y+D&gt;&#x3D;50))&#123;</span><br><span class="line"> answer &#x3D; true;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">visited[n] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((distance(x,y,cro[i].x,cro[i].y)&lt;&#x3D;pow(D,2)) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">DFS(cro[i].x,cro[i].y,i);</span><br><span class="line">if(answer &#x3D;&#x3D; true) break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"> return answer;</span><br><span class="line"> &#125;</span><br><span class="line"> void toJump()&#123;</span><br><span class="line"> for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line"> if((distance(0,0,cro[i].x,cro[i].y)&lt;&#x3D;pow(D+15,2)) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">answer &#x3D; DFS(cro[i].x,cro[i].y,i);</span><br><span class="line">if(answer &#x3D;&#x3D; true) break; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(answer) cout&lt;&lt;&quot;Yes&quot;;</span><br><span class="line">else cout&lt;&lt;&quot;No&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> int main()&#123;</span><br><span class="line"> cin&gt;&gt;N&gt;&gt;D;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line"> cin&gt;&gt;cro[i].x&gt;&gt;cro[i].y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toJump();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="DFS" scheme="https://cjay.life/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>列出连通集</title>
    <link href="https://cjay.life/2020/06/21/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/"/>
    <id>https://cjay.life/2020/06/21/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</id>
    <published>2020-06-21T13:07:36.000Z</published>
    <updated>2020-06-28T15:30:28.257Z</updated>
    
    <content type="html"><![CDATA[<p>7-6 列出连通集 (25分)</p><p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照”{ <em>v</em>1 <em>v</em>2 … <em>v**k</em> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int g[10][10];</span><br><span class="line">int visited[10];</span><br><span class="line">int n,m,t1,t2;</span><br><span class="line">void BFS(int v)&#123;</span><br><span class="line">int vt;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">q.push(v);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">vt &#x3D; q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if((g[vt][i] &#x3D;&#x3D; 1) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">visited[i] &#x3D; 1;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int v)&#123;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if((g[v][i] &#x3D;&#x3D; 1) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">DFS(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i &#x3D; 0;i&lt;m;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">g[t1][t2] &#x3D; 1;</span><br><span class="line">g[t2][t1] &#x3D; 1;</span><br><span class="line">&#125; </span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if(visited[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">DFS(i);</span><br><span class="line">cout&lt;&lt;&quot;&#125;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)</span><br><span class="line">visited[i] &#x3D; 0;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if(visited[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">BFS(i);</span><br><span class="line">cout&lt;&lt;&quot;&#125;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-6 列出连通集 (25分)&lt;/p&gt;
&lt;p&gt;给定一个有&lt;em&gt;N&lt;/em&gt;个顶点和&lt;em&gt;E&lt;/em&gt;条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到&lt;em&gt;N&lt;/em&gt;−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="BFS" scheme="https://cjay.life/tags/BFS/"/>
    
      <category term="DFS" scheme="https://cjay.life/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://cjay.life/2020/06/20/%E5%9B%BE/"/>
    <id>https://cjay.life/2020/06/20/%E5%9B%BE/</id>
    <published>2020-06-20T10:41:22.000Z</published>
    <updated>2020-06-28T15:37:46.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图定义"><a href="#图定义" class="headerlink" title="图定义"></a>图定义</h1><p>由V（Vertex）表示有限顶点集合和E（Edge）表示有限边的集合组成</p><p><strong><em>不考虑重边和自回路</em></strong></p><p><strong><em>V不能为空，E能为空</em></strong></p><p>图又可分为好几种类型，比如：</p><p>有向图与无向图</p><p>网络与非网络图（边是否有权重）</p><h1 id="在程序中表示一个图"><a href="#在程序中表示一个图" class="headerlink" title="在程序中表示一个图"></a>在程序中表示一个图</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><h3 id="无向图用一维矩阵代替二维矩阵"><a href="#无向图用一维矩阵代替二维矩阵" class="headerlink" title="无向图用一维矩阵代替二维矩阵"></a>无向图用一维矩阵代替二维矩阵</h3><p>假定G [N] [N] 矩阵，可以用一个长度为N(N+1)/2的一维矩阵A存储，则Gij在A中对应的下标是：<strong>i（i+1）/2+j</strong></p><h3 id="邻接矩阵的优势"><a href="#邻接矩阵的优势" class="headerlink" title="邻接矩阵的优势"></a>邻接矩阵的优势</h3><ol><li>直观，好理解</li><li>方便查找两个顶点之间是否存在边</li><li>方便查找一个顶点的邻接点（对于无向图，只需要查找一行，有向图要查找一行一列）</li><li>方便计算度</li></ol><h3 id="邻接矩阵的劣势"><a href="#邻接矩阵的劣势" class="headerlink" title="邻接矩阵的劣势"></a>邻接矩阵的劣势</h3><ol><li>对于稀疏图（点多边少）</li><li>若要统计图中边的数量，只能遍历完整个矩阵</li></ol><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>设置G[N]为指针数组，数组中每个单元都存放着一个链表（存放G[i]的临接点）</p><h3 id="邻接表的优势"><a href="#邻接表的优势" class="headerlink" title="邻接表的优势"></a>邻接表的优势</h3><ol><li>方便查找任一结点的所有“邻接点”</li><li>对于稀疏图节约空间：N个头指针+2E个结点（每个结点两个域）</li><li>对于无向图方便计算顶点的度</li></ol><h3 id="邻接表的劣势"><a href="#邻接表的劣势" class="headerlink" title="邻接表的劣势"></a>邻接表的劣势</h3><ol><li>对于边多点少的稠密图就不划算</li><li>对于有向图，只能计算出度；对于入度，需要构造逆邻接表（存指向自己的边）来方便计算入度</li><li>对于查找一对顶点间是否存在边很不方便</li></ol><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深搜（Depth-First-Search-DFS）"><a href="#深搜（Depth-First-Search-DFS）" class="headerlink" title="深搜（Depth First Search ,DFS）"></a>深搜（Depth First Search ,DFS）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Vertex X)&#123;</span><br><span class="line">visited[X] &#x3D; true;</span><br><span class="line">for(V的每个临接点 W)</span><br><span class="line">if(visited[W] &#x3D;&#x3D; false)</span><br><span class="line">DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若有N个顶点，E条边，时间复杂度</p><ul><li>邻接表，O（N+E）</li><li>邻接矩阵，O(N2)</li></ul><h2 id="广搜（Breadth-First-Search）"><a href="#广搜（Breadth-First-Search）" class="headerlink" title="广搜（Breadth First Search）"></a>广搜（Breadth First Search）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Void BFS(Vertex V)&#123;</span><br><span class="line">visited[V] &#x3D; true;</span><br><span class="line">Enqueue(V,Q);</span><br><span class="line">while(!IsEmpty(Q))&#123;</span><br><span class="line">V &#x3D; Dequeue(Q);</span><br><span class="line">for(V 的每个邻接点 W)</span><br><span class="line">if(!visited[w])&#123;</span><br><span class="line">visited[W] &#x3D; true;</span><br><span class="line">Enqueue(W,Q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若有N个顶点，E条边，时间复杂度</p><ul><li>邻接表，O（N+E）</li><li>邻接矩阵，O(N2)</li></ul><h1 id="图论的一些概念"><a href="#图论的一些概念" class="headerlink" title="图论的一些概念"></a>图论的一些概念</h1><p>连通 ：V到W存在一条路径，则称V和W是连通的</p><p>连通图: 图中任意两顶点均连通</p><p>连通分量： <strong><em>无向图</em></strong>的极大连通子图</p><p>​     极大顶点数</p><pre><code>极大边数</code></pre><p>强连通： <strong><em>有向图</em></strong>中顶点V和W之间存在双向路径</p><p>强连通图:  <strong><em>有向图</em></strong>中任意两顶点均强连通</p><p>强连通分量：有向图的极大连通子图</p><p>简单路径：V到W之间的所有顶点都不同</p><p>回路：起点等于终点的路径</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图定义&quot;&gt;&lt;a href=&quot;#图定义&quot; class=&quot;headerlink&quot; title=&quot;图定义&quot;&gt;&lt;/a&gt;图定义&lt;/h1&gt;&lt;p&gt;由V（Vertex）表示有限顶点集合和E（Edge）表示有限边的集合组成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不考虑重边和自回路&lt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>File Transfer</title>
    <link href="https://cjay.life/2020/06/19/File-Transfer/"/>
    <id>https://cjay.life/2020/06/19/File-Transfer/</id>
    <published>2020-06-19T09:23:10.000Z</published>
    <updated>2020-06-19T09:24:55.821Z</updated>
    
    <content type="html"><![CDATA[<p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains <em>N</em> (2≤<em>N</em>≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and <em>N</em>. Then in the following lines, the input is given in the format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I c1 c2</span><br></pre></td></tr></table></figure><p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C c1 c2</span><br></pre></td></tr></table></figure><p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure><p>where <code>S</code> stands for stopping this case.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each <code>C</code> case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are <code>k</code> components.” where <code>k</code> is the number of connected components in this network.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">There are 2 components.</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">I 1 3</span><br><span class="line">C 1 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">The network is connected.</span><br></pre></td></tr></table></figure><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char c;</span><br><span class="line">int N;</span><br><span class="line">int pc[10005];</span><br><span class="line">int find(int a)&#123;</span><br><span class="line">if(pc[a]&lt;0) return a;</span><br><span class="line">else return pc[a] &#x3D; find(pc[a]);</span><br><span class="line">&#125;</span><br><span class="line">void input()&#123;</span><br><span class="line">int t1,t2;</span><br><span class="line">scanf(&quot;%d %d\n&quot;,&amp;t1,&amp;t2);</span><br><span class="line">int root1,root2;</span><br><span class="line">root1 &#x3D; find(t1);</span><br><span class="line">root2 &#x3D; find(t2);</span><br><span class="line">pc[root1] &#x3D; root2;</span><br><span class="line">&#125;</span><br><span class="line">void check()&#123;</span><br><span class="line">int t1,t2;</span><br><span class="line">scanf(&quot;%d %d\n&quot;,&amp;t1,&amp;t2);</span><br><span class="line">if(find(t1) &#x3D;&#x3D; find(t2)) cout&lt;&lt;&quot;yes\n&quot;;</span><br><span class="line">else cout&lt;&lt;&quot;no\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">void sum()&#123;</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">if(pc[i] &#x3D;&#x3D; -1) a++;</span><br><span class="line">if(a &#x3D;&#x3D; 1) cout&lt;&lt;&quot;The network is connected.\n&quot;;</span><br><span class="line">else printf(&quot;There are %d components.\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d\n&quot;,&amp;N);</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">pc[i] &#x3D; -1;</span><br><span class="line">do&#123;</span><br><span class="line">scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">switch(c)&#123;</span><br><span class="line">case &#39;I&#39;: input(); break;</span><br><span class="line">case &#39;C&#39;: check(); break;</span><br><span class="line">case &#39;S&#39;: sum(); break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;while(c!&#x3D;&#39;S&#39;); &#x2F;&#x2F;不要忘了；</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one comput
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="并查集" scheme="https://cjay.life/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>集合及运算</title>
    <link href="https://cjay.life/2020/06/19/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
    <id>https://cjay.life/2020/06/19/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/</id>
    <published>2020-06-19T07:33:27.000Z</published>
    <updated>2020-06-19T09:03:14.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>定义：集合<strong><em>并，查</em></strong>某元素属于什么集合</p><p><em>双亲表示法：孩子指向双亲(与普通树的指针刚好相反)</em></p><h1 id="并查集存储"><a href="#并查集存储" class="headerlink" title="并查集存储"></a>并查集存储</h1><p>typedef struct{</p><p>​    ElementType Data;</p><p>​    int parent;</p><p>} SetType;</p><h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><h2 id="查找某个元素所在集合"><a href="#查找某个元素所在集合" class="headerlink" title="查找某个元素所在集合"></a>查找某个元素所在集合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Find(SetType S[],ElementType X)&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i &#x3D; 0;i&lt;MaxSize &amp;&amp; S[i].data !&#x3D; X; i++);</span><br><span class="line">if(i &gt;&#x3D; MaxSize) return -1; &#x2F;&#x2F;未找到X，返回-1</span><br><span class="line">for(;S[i].parent &gt;&#x3D; 0; i &#x3D; S[i].Parent);</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合的并运算"><a href="#集合的并运算" class="headerlink" title="集合的并运算"></a>集合的并运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Union(SetType S[], ElementType X1, ElementType X2)&#123;</span><br><span class="line">int root1, root2;</span><br><span class="line">root1 &#x3D; Find(S,X1);</span><br><span class="line">root2 &#x3D; Find(S,X2);</span><br><span class="line">if(root1!&#x3D;root2) S[root2].parent &#x3D; Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>改写Find方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int Find(SetType S[], ElementType X)&#123;</span><br><span class="line">if(S[X]&lt;0)</span><br><span class="line">return x;</span><br><span class="line">else return S[X] &#x3D; Find(S,S[X]);&#x2F;&#x2F;尾递归不用担心爆内存，编译器编译时会优化成循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h1&gt;&lt;p&gt;定义：集合&lt;strong&gt;&lt;em&gt;并，查&lt;/em&gt;&lt;/strong&gt;某元素属于什么集合&lt;/p&gt;
&lt;p&gt;&lt;em&gt;双亲表示法：孩子指向双
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="并查集" scheme="https://cjay.life/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树与哈夫曼编码</title>
    <link href="https://cjay.life/2020/06/18/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <id>https://cjay.life/2020/06/18/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</id>
    <published>2020-06-18T14:15:56.000Z</published>
    <updated>2020-06-18T14:44:47.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h1><p>哈夫曼树又称为最优二叉树，是WPL最小的二叉树</p><h1 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TreeNode *HuffmanTree;</span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">int Weight;</span><br><span class="line">HuffmanTree Left,Right;</span><br><span class="line">&#125;</span><br><span class="line">HuffmanTree Huffman(MinHeap H)&#123;</span><br><span class="line">int i; HuffmanTree T;</span><br><span class="line">BuildMinHeap(H)&#x2F;&#x2F;调整为最小堆</span><br><span class="line">for(i &#x3D; 1;i&lt; H-&gt;Size;i++)&#123;&#x2F;&#x2F;做H-&gt;size-1次合并</span><br><span class="line">T &#x3D; malloc(sizeof(struct TreeNode));</span><br><span class="line">T-&gt;Left &#x3D; DeleteMin(H);</span><br><span class="line">T-&gt;Right &#x3D; DeleteMin(H);</span><br><span class="line">T-&gt;Weight &#x3D; T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;</span><br><span class="line">Insert(H,T);</span><br><span class="line">&#125;</span><br><span class="line">T &#x3D; DeleteMin(H);</span><br><span class="line">return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体复杂度NlogN。</p><h1 id="哈夫曼树特点"><a href="#哈夫曼树特点" class="headerlink" title="哈夫曼树特点"></a>哈夫曼树特点</h1><h2 id="没有度为1的节点"><a href="#没有度为1的节点" class="headerlink" title="没有度为1的节点"></a>没有度为1的节点</h2><h2 id="n个叶子结点的哈夫曼树共有2n-1个结点（n2-n0-1）"><a href="#n个叶子结点的哈夫曼树共有2n-1个结点（n2-n0-1）" class="headerlink" title="n个叶子结点的哈夫曼树共有2n-1个结点（n2 = n0-1）"></a>n个叶子结点的哈夫曼树共有2n-1个结点（n2 = n0-1）</h2><h2 id="任意非叶结点的左右子树交换仍是哈夫曼树"><a href="#任意非叶结点的左右子树交换仍是哈夫曼树" class="headerlink" title="任意非叶结点的左右子树交换仍是哈夫曼树"></a>任意非叶结点的左右子树交换仍是哈夫曼树</h2><h2 id="对于同一组权值，存在着不同构的两棵哈夫曼树-1-2-3-3"><a href="#对于同一组权值，存在着不同构的两棵哈夫曼树-1-2-3-3" class="headerlink" title="对于同一组权值，存在着不同构的两棵哈夫曼树({1,2,3,3})"></a>对于同一组权值，存在着不同构的两棵哈夫曼树({1,2,3,3})</h2><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>不等长编码，且可以避免二义性。</p><p>就是一种前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈夫曼树定义&quot;&gt;&lt;a href=&quot;#哈夫曼树定义&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼树定义&quot;&gt;&lt;/a&gt;哈夫曼树定义&lt;/h1&gt;&lt;p&gt;哈夫曼树又称为最优二叉树，是WPL最小的二叉树&lt;/p&gt;
&lt;h1 id=&quot;构建哈夫曼树&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="哈夫曼" scheme="https://cjay.life/tags/%E5%93%88%E5%A4%AB%E6%9B%BC/"/>
    
  </entry>
  
  <entry>
    <title>堆中的路径</title>
    <link href="https://cjay.life/2020/06/18/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://cjay.life/2020/06/18/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2020-06-18T10:46:13.000Z</published>
    <updated>2020-06-18T14:34:35.307Z</updated>
    
    <content type="html"><![CDATA[<p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每组测试第1行包含2个正整数<em>N</em>和<em>M</em>(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的<em>N</em>个要被插入一个初始为空的小顶堆的整数。最后一行给出<em>M</em>个下标。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure><hr><p>一开始解这道题的时候思路是先将这N个数字存储下来，再从最后一个具有子节点的节点开始向下调整。</p><p>但是这样解错了。</p><h3 id="自己的解法（错误）"><a href="#自己的解法（错误）" class="headerlink" title="自己的解法（错误）"></a>自己的解法（错误）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int a[1005],b[1005];</span><br><span class="line">void ajust(int index)&#123;</span><br><span class="line">int parent;</span><br><span class="line">int child;</span><br><span class="line">int temp &#x3D; a[index];</span><br><span class="line">for(parent &#x3D; index; parent*2&lt;&#x3D;N;parent &#x3D; child)&#123;</span><br><span class="line">child &#x3D; 2*parent;</span><br><span class="line">if((child!&#x3D;N) &amp;&amp; (a[child]&gt;a[child+1]))</span><br><span class="line">child++;</span><br><span class="line">if(temp&lt;&#x3D;a[child]) break;</span><br><span class="line">else a[parent] &#x3D; a[child];</span><br><span class="line">&#125;</span><br><span class="line">a[parent] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void buildHeap()&#123;</span><br><span class="line">for(int i &#x3D; N&#x2F;2 ;i&gt;0;i--)&#123;</span><br><span class="line">ajust(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void printPath(int index)&#123;</span><br><span class="line">int flag &#x3D; 1;</span><br><span class="line">for(int i &#x3D; index;i&gt;0;i&#x3D;i&#x2F;2)&#123;</span><br><span class="line">if(flag)&#123;</span><br><span class="line">printf(&quot;%d&quot;,a[i]);</span><br><span class="line">flag &#x3D; 0;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot; %d&quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">a[0] &#x3D; -10001;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;M;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">&#125;</span><br><span class="line">buildHeap();</span><br><span class="line">&#x2F;&#x2F;for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt; a[i];</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;M;i++)&#123;</span><br><span class="line">printPath(b[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正确的解法"><a href="#正确的解法" class="headerlink" title="正确的解法"></a>正确的解法</h3><p>该题目采用建立小顶堆的方式是逐个插入，逐个调整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M;</span><br><span class="line">int a[1005];</span><br><span class="line">int size &#x3D; 0;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">a[0] &#x3D; -10001;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">int temp;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">int j;</span><br><span class="line">for(j &#x3D; ++size;a[j&#x2F;2]&gt;temp;j &#x3D; j&#x2F;2)&#123;</span><br><span class="line">a[j] &#x3D; a[j&#x2F;2];</span><br><span class="line">&#125;</span><br><span class="line">a[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">int temp;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">cout&lt;&lt;a[temp];</span><br><span class="line">while(temp!&#x3D;1)&#123;</span><br><span class="line">temp &#x3D; temp&#x2F;2;</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;a[temp];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;\n&quot;; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，分别采用这两种方式构建小顶堆，结果是不一样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将一系列给定数字插入一个初始为空的小顶堆&lt;code&gt;H[]&lt;/code&gt;。随后对任意给定的下标&lt;code&gt;i&lt;/code&gt;，打印从&lt;code&gt;H[i]&lt;/code&gt;到根结点的路径。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="堆" scheme="https://cjay.life/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://cjay.life/2020/06/17/%E5%A0%86/"/>
    <id>https://cjay.life/2020/06/17/%E5%A0%86/</id>
    <published>2020-06-17T14:42:56.000Z</published>
    <updated>2020-06-18T14:34:44.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><p>优先队列（Priority Queue）: 取出元素的顺序按优先权大小，而不是元素进入队列的先后顺序。</p><p>若堆可以用二叉搜索树来实现，插入操作时间效率就是对数级，删除操作也是对数级，但如果不断删除最大或最小的，树会歪掉，树的高度就不再是对数级别了。</p><h1 id="堆的两个特性"><a href="#堆的两个特性" class="headerlink" title="堆的两个特性"></a>堆的两个特性</h1><p>结构性：用数组表示的完全二叉树。</p><p>有序性：任一节点的关键字是其子树所有结点的最大值（或最小值）</p><h1 id="堆的操作集"><a href="#堆的操作集" class="headerlink" title="堆的操作集"></a>堆的操作集</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct HeapStruct *MaxHeap;</span><br><span class="line">struct HeapStruct&#123;</span><br><span class="line">ElementType *Elements;&#x2F;&#x2F; 存储堆元素的数组</span><br><span class="line">int Size;&#x2F;&#x2F;堆当前元素个数</span><br><span class="line">int Capacity;&#x2F;&#x2F;堆最大容量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaxHeap Create(int MaxSize)&#123;</span><br><span class="line">MaxHeap H &#x3D; malloc(sizeof(struct HeapStruct));</span><br><span class="line">H-&gt;Elements &#x3D; malloc((MaxSize+1)*sizeof(ElementType));</span><br><span class="line">H-&gt;Size &#x3D; 0;</span><br><span class="line">H-&gt;Capacity &#x3D; MaxSize;</span><br><span class="line">H-&gt;Elements[0] &#x3D; MaxData;&#x2F;&#x2F;作为哨兵，便于以后更快操作</span><br><span class="line">return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Insert(MaxHeap H,ElementType item)&#123;</span><br><span class="line">int i;</span><br><span class="line">if(isFull(H))&#123;</span><br><span class="line">printf(&quot;最大堆已满&quot;)；</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">i &#x3D; ++H-&gt;Size;</span><br><span class="line">for(;H-&gt;Elements[i&#x2F;2] &lt; item; i&#x2F;&#x3D;2)</span><br><span class="line">H-&gt;Elements[i] &#x3D; H-&gt;Elements[i&#x2F;2];</span><br><span class="line">H-&gt;Elements[i] &#x3D; item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ElementType DeleteMax(MaxHeap H)&#123;</span><br><span class="line">&#x2F;&#x2F;取出键值最大的元素，并删除有一个节点</span><br><span class="line">int Parent,Child;</span><br><span class="line">ElementType MaxItem,temp;</span><br><span class="line">if(isEmpty(H))&#123;</span><br><span class="line">printf(&quot;最大堆已为空&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">MaxItem &#x3D; H-&gt;Elements[1];</span><br><span class="line">for(Parent &#x3D; 1; Parent*2&lt;&#x3D;H-&gt;Size; Parent &#x3D; Child)&#123;</span><br><span class="line">Child &#x3D; Parent * 2;</span><br><span class="line">if((Child!&#x3D; H-&gt;Size) &amp;&amp; (H-&gt;Element[Child]&lt;H-&gt;Element[Child+1]))</span><br><span class="line">Child++;</span><br><span class="line">if( temp &gt;&#x3D; H-&gt;Elements[Child]) break;</span><br><span class="line">else H-&gt;Elements[Parent] &#x3D; H-&gt;Elements[Child];</span><br><span class="line">&#125;    </span><br><span class="line">H-&gt;Elements[Parent] &#x3D; temp;</span><br><span class="line">return MaxItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大堆的建立"><a href="#最大堆的建立" class="headerlink" title="最大堆的建立"></a>最大堆的建立</h2><p>将已经存在的N个元素按最大堆的要求放在一个一维数组中。</p><p>方法1：将N个元素一个个相继插入到一个初始为空的堆中去，时间代价为NlogN。</p><p>方法2：（1）将N个元素顺序存入，先满足完全二叉树的结构特性。（2）调节各节点位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void PercDown(MaxHeap H,int p)&#123;</span><br><span class="line">int Parent,Child;</span><br><span class="line">ElementType X;</span><br><span class="line">X &#x3D; H-&gt;Data[p];</span><br><span class="line">for(Parent &#x3D; p; Parent*2&lt;&#x3D;H-&gt;Size; Parent &#x3D; Child)&#123;</span><br><span class="line">Child &#x3D; Parent*2;</span><br><span class="line">if((Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]))</span><br><span class="line">Child++;</span><br><span class="line">if(X&gt;&#x3D;H-&gt;Data[Child]) break;</span><br><span class="line">else H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];</span><br><span class="line">&#125;</span><br><span class="line">H-&gt;Data[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line">void BuildHeap(MaxHeap H)&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i &#x3D; H-&gt;Size&#x2F;2;i&gt;0;i--)</span><br><span class="line">PercDown(H,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是堆&quot;&gt;&lt;a href=&quot;#什么是堆&quot; class=&quot;headerlink&quot; title=&quot;什么是堆&quot;&gt;&lt;/a&gt;什么是堆&lt;/h1&gt;&lt;p&gt;优先队列（Priority Queue）: 取出元素的顺序按优先权大小，而不是元素进入队列的先后顺序。&lt;/p&gt;
&lt;p&gt;若堆可
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="堆" scheme="https://cjay.life/tags/%E5%A0%86/"/>
    
  </entry>
  
</feed>
