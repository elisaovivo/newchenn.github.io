<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CJ&#39;S BLOG</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cjay.life/"/>
  <updated>2020-07-06T15:38:17.314Z</updated>
  <id>https://cjay.life/</id>
  
  <author>
    <name>CJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1064 Complete Binary Search Tree (30分)</title>
    <link href="https://cjay.life/2020/07/06/1064-Complete-Binary-Search-Tree-30%E5%88%86/"/>
    <id>https://cjay.life/2020/07/06/1064-Complete-Binary-Search-Tree-30%E5%88%86/</id>
    <published>2020-07-06T15:36:25.000Z</published>
    <updated>2020-07-06T15:38:17.314Z</updated>
    
    <content type="html"><![CDATA[<p>1064 Complete Binary Search Tree (30分)</p><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p><p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 3 8 1 5 7 9 0 2 4</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int num[1005];</span><br><span class="line">int ans[1005];</span><br><span class="line">int N;</span><br><span class="line">int getMid(int l,int r)&#123;</span><br><span class="line">int sum &#x3D; r-l+1;&#x2F;&#x2F;总数</span><br><span class="line">int layer &#x3D; floor(log(sum+1)&#x2F;log(2)); &#x2F;&#x2F;除最后一层的层数，</span><br><span class="line">int lastlayerleaf &#x3D; sum+1-pow(2,layer);&#x2F;&#x2F;最后一层的节点数</span><br><span class="line">int leftnum &#x3D; pow(2,layer-1)-1+min(lastlayerleaf,(int)pow(2,layer-1));&#x2F;&#x2F;左子树结点总数</span><br><span class="line">return l+leftnum; &#x2F;&#x2F;根位置</span><br><span class="line">&#125; </span><br><span class="line">void solve(int l,int r,int root)&#123;</span><br><span class="line">if(r-l+1 &#x3D;&#x3D; 0) return;</span><br><span class="line">int mid &#x3D; getMid(l,r);</span><br><span class="line">ans[root] &#x3D; num[mid];</span><br><span class="line">solve(l,mid-1,root*2+1);</span><br><span class="line">solve(mid+1,r,root*2+2); </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line">for(int i&#x3D;0;i&lt;N;i++)</span><br><span class="line">cin&gt;&gt;num[i];</span><br><span class="line">sort(num,num+N);</span><br><span class="line">solve(0,N-1,0);</span><br><span class="line">cout&lt;&lt;ans[0];</span><br><span class="line">for(int i &#x3D; 1;i&lt;N;i++)</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1064 Complete Binary Search Tree (30分)&lt;/p&gt;
&lt;p&gt;A Binary Search Tree (BST) is recursively defined as a binary tree which has the following 
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树，公式推导" scheme="https://cjay.life/tags/%E6%A0%91%EF%BC%8C%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>1086 Tree Traversals Again (25分)</title>
    <link href="https://cjay.life/2020/07/06/1086-Tree-Traversals-Again-25%E5%88%86/"/>
    <id>https://cjay.life/2020/07/06/1086-Tree-Traversals-Again-25%E5%88%86/</id>
    <published>2020-07-06T14:31:55.000Z</published>
    <updated>2020-07-06T14:34:55.193Z</updated>
    
    <content type="html"><![CDATA[<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p><p><img src="https://images.ptausercontent.com/30" alt="img"><br>Figure 1</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 2 6 5 1</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,n,i,j,k;</span><br><span class="line">string s;</span><br><span class="line">int preorder[35];</span><br><span class="line">int inorder[35];</span><br><span class="line">int postorder[35];</span><br><span class="line">void porder(int ileft,int iright,int pleft,int pright)&#123;&#x2F;&#x2F;核心算法</span><br><span class="line">if((ileft&gt;iright)||(pleft&gt;pright))</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">postorder[k++] &#x3D; preorder[pleft];</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt;postorder[k-1]&lt;&lt;endl;</span><br><span class="line">for(i &#x3D; ileft;i&lt;&#x3D;iright;i++)&#123;</span><br><span class="line">if(inorder[i] &#x3D;&#x3D; preorder[pleft])</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">porder(i+1,iright,pleft+1+i-ileft,pright);</span><br><span class="line">porder(ileft,i-1,pleft+1,pleft+i-ileft);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line">int NN &#x3D; 2*N;</span><br><span class="line">stack&lt;int&gt; ss;</span><br><span class="line">while(NN--)&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">if(s&#x3D;&#x3D;&quot;Push&quot;)&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">ss.push(n);</span><br><span class="line">preorder[i++] &#x3D; n;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">n &#x3D; ss.top();</span><br><span class="line">ss.pop();</span><br><span class="line">inorder[j++] &#x3D; n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">porder(0,N-1,0,N-1);</span><br><span class="line">cout&lt;&lt;postorder[N-1];</span><br><span class="line">for(int j &#x3D; N-2;j&gt;&#x3D;0;j--)&#123;</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;postorder[j];</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary t
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树的遍历" scheme="https://cjay.life/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>关于高效学习</title>
    <link href="https://cjay.life/2020/07/06/%E5%85%B3%E4%BA%8E%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    <id>https://cjay.life/2020/07/06/%E5%85%B3%E4%BA%8E%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-06T04:38:50.000Z</published>
    <updated>2020-07-06T05:01:54.023Z</updated>
    
    <content type="html"><![CDATA[<p>看完高效学习篇之后，想要进一步将知识缩减，并带入自己的思考。</p><h1 id="端正学习态度"><a href="#端正学习态度" class="headerlink" title="端正学习态度"></a>端正学习态度</h1><p><img src="https://dingyue.ws.126.net/d62vefHcMwmSZZFe0RXktPa4DG1hElKx4fjzHitgkZx4v1571967477433.jpg" alt="推荐丨金字塔学习法，输出和实践最能提升学习效率_网易订阅"></p><p>在学习知识后，必须有对知识本身有着思考，总结与归纳，不断对这些知识进行应用，对外输出。</p><p>更详细得步骤：</p><ol><li>好的信息源头</li><li>将知识连成地图</li><li>对于知识本身反思与思辨</li><li>举一反三，进行应用</li></ol><h1 id="源头、原理和知识地图"><a href="#源头、原理和知识地图" class="headerlink" title="源头、原理和知识地图"></a>源头、原理和知识地图</h1><p>好的信息源头有如下特质:</p><ol><li>第一首资料</li><li>有佐证、有数据、有引用</li><li>加入了自己经验与思考</li></ol><p>注重基础和原理</p><p>将所有得知识串联起来。</p><h1 id="深度归纳和坚持实践"><a href="#深度归纳和坚持实践" class="headerlink" title="深度归纳和坚持实践"></a>深度归纳和坚持实践</h1><p>对于新技术，除了知识图，还需要问自己多个为什么？</p><ol><li>技术出现得背景、初衷和需要用来解决什么问题</li><li>该技术的优势和劣势</li><li>适用场景（所谓场景一般分别两个，一个是业务场景，一个是技术场景。）</li><li>技术的组成部分和关键点（技术的核心思想和核心组件）</li><li>技术的底层原理和关键实现</li><li>已有的实现和它之间的对比</li></ol><p>举一反三的能力：</p><ol><li>联想能力：对同一个事物的不同看法，联想相关事物</li><li>抽象能力：从不同问题中抽象出解的结构</li><li>自省能力：自己的不足</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看完高效学习篇之后，想要进一步将知识缩减，并带入自己的思考。&lt;/p&gt;
&lt;h1 id=&quot;端正学习态度&quot;&gt;&lt;a href=&quot;#端正学习态度&quot; class=&quot;headerlink&quot; title=&quot;端正学习态度&quot;&gt;&lt;/a&gt;端正学习态度&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https:
      
    
    </summary>
    
    
      <category term="学习方法" scheme="https://cjay.life/categories/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="学习方法，左耳朵耗子极客时间" scheme="https://cjay.life/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B7%A6%E8%80%B3%E6%9C%B5%E8%80%97%E5%AD%90%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>7-7 六度空间</title>
    <link href="https://cjay.life/2020/07/05/7-7-%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/"/>
    <id>https://cjay.life/2020/07/05/7-7-%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4/</id>
    <published>2020-07-05T13:56:26.000Z</published>
    <updated>2020-07-05T14:12:42.386Z</updated>
    
    <content type="html"><![CDATA[<p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。</p><p><img src="https://images.ptausercontent.com/35" alt="img"><br>图1 六度空间示意图</p><p>“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。</p><p>假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出两个正整数，分别表示社交网络图的结点数<em>N</em>（1&lt;<em>N</em>≤103，表示人数）、边数<em>M</em>（≤33×<em>N</em>，表示社交关系数）。随后的<em>M</em>行对应<em>M</em>条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到<em>N</em>编号）。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">10 9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br><span class="line">7 8</span><br><span class="line">8 9</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1: 70.00%</span><br><span class="line">2: 80.00%</span><br><span class="line">3: 90.00%</span><br><span class="line">4: 100.00%</span><br><span class="line">5: 100.00%</span><br><span class="line">6: 100.00%</span><br><span class="line">7: 100.00%</span><br><span class="line">8: 90.00%</span><br><span class="line">9: 80.00%</span><br><span class="line">10: 70.00%</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int v[1005][1005];</span><br><span class="line">int flag[1005];</span><br><span class="line">int t1,t2,sum;</span><br><span class="line">int BFS(int node)&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int count &#x3D; 1;</span><br><span class="line">int level &#x3D; 0;</span><br><span class="line">int last &#x3D; node;</span><br><span class="line">int tail;</span><br><span class="line">flag[node] &#x3D; 1;</span><br><span class="line">q.push(node);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">node &#x3D; q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">if((v[node][i] &#x3D;&#x3D; 1) &amp;&amp; (flag[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">flag[i] &#x3D; 1;</span><br><span class="line">q.push(i);</span><br><span class="line">count++;</span><br><span class="line">tail &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(node &#x3D;&#x3D; last)&#123;</span><br><span class="line">level++;</span><br><span class="line">last &#x3D; tail;</span><br><span class="line">&#125;</span><br><span class="line">if(level&#x3D;&#x3D;6) break;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset()&#123;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">flag[i] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">v[t1][t2] &#x3D; 1;</span><br><span class="line">v[t2][t1] &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 1 ;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">sum &#x3D; BFS(i);</span><br><span class="line">printf(&quot;%d: %.2f%%\n&quot;,i,(double)sum&#x2F;N*100);</span><br><span class="line">reset();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="该题要点"><a href="#该题要点" class="headerlink" title="该题要点"></a>该题要点</h3><p>这个题目在传统的BFS算法上进行改造，需要在BFS过程中记录当前遍历的层数。</p><p>这里再原来的基础上增加了三个变量 tail,last,level;</p><p>tail表示下一层的最后一个元素；</p><p>last表示当前层的最后一个元素；</p><p>level表示当前位于第几层；</p><hr><p>初始 tail不用设，last = node（第0层最后一个结点就是自己）,level = 0(自己不算）</p><hr><p>这里关键点是为什么能知道当前node是该层最后一个元素？</p><p>while循环中，最后判断时，弹出的当前结点node == last 时，表明：</p><p>该层最后一个结点已经被弹出，且下一层所有结点全在队列中了；</p><p>这个时候更改新一层的last，将last = tail，并将level++；</p><p>level的数值表示，当前i层的所有数据已经被访问完。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图1所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="BFS" scheme="https://cjay.life/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>7-10 Saving James Bond - Easy Version</title>
    <link href="https://cjay.life/2020/07/05/7-10-Saving-James-Bond-Easy-Version/"/>
    <id>https://cjay.life/2020/07/05/7-10-Saving-James-Bond-Easy-Version/</id>
    <published>2020-07-05T12:51:32.000Z</published>
    <updated>2020-07-05T12:53:00.625Z</updated>
    
    <content type="html"><![CDATA[<p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).</p><p>Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case starts with a line containing two positive integers <em>N</em> (≤100), the number of crocodiles, and <em>D</em>, the maximum distance that James could jump. Then <em>N</em> lines follow, each containing the (<em>x</em>,<em>y</em>) location of a crocodile. Note that no two crocodiles are staying at the same position.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in a line “Yes” if James can escape, or “No” if not.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">14 20</span><br><span class="line">25 -15</span><br><span class="line">-25 28</span><br><span class="line">8 49</span><br><span class="line">29 15</span><br><span class="line">-35 -2</span><br><span class="line">5 28</span><br><span class="line">27 -29</span><br><span class="line">-8 -28</span><br><span class="line">-20 -35</span><br><span class="line">-25 -20</span><br><span class="line">-13 29</span><br><span class="line">-30 15</span><br><span class="line">-35 40</span><br><span class="line">12 12</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 13</span><br><span class="line">-12 12</span><br><span class="line">12 12</span><br><span class="line">-12 -12</span><br><span class="line">12 -12</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"> using namespace std;</span><br><span class="line"> struct node&#123;</span><br><span class="line"> int x,y;</span><br><span class="line"> &#125;;</span><br><span class="line"> node cro[105];</span><br><span class="line"> int visited[105];</span><br><span class="line"> int N,D;</span><br><span class="line"> int t1,t2;</span><br><span class="line"> bool answer &#x3D; 0;</span><br><span class="line"> double distance(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line"> return pow(x2-x1,2)+pow(y2-y1,2);</span><br><span class="line"> &#125; </span><br><span class="line">  bool DFS(int x, int y,int n)&#123;</span><br><span class="line"> if((x-D&lt;&#x3D;-50)||(x+D&gt;&#x3D;50)||(y-D&lt;&#x3D;-50)||(y+D&gt;&#x3D;50))&#123;</span><br><span class="line"> answer &#x3D; true;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">visited[n] &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">if((distance(x,y,cro[i].x,cro[i].y)&lt;&#x3D;pow(D,2)) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">DFS(cro[i].x,cro[i].y,i);</span><br><span class="line">if(answer &#x3D;&#x3D; true) break;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"> return answer;</span><br><span class="line"> &#125;</span><br><span class="line"> void toJump()&#123;</span><br><span class="line"> for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line"> if((distance(0,0,cro[i].x,cro[i].y)&lt;&#x3D;pow(D+15,2)) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">answer &#x3D; DFS(cro[i].x,cro[i].y,i);</span><br><span class="line">if(answer &#x3D;&#x3D; true) break; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(answer) cout&lt;&lt;&quot;Yes&quot;;</span><br><span class="line">else cout&lt;&lt;&quot;No&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"> int main()&#123;</span><br><span class="line"> cin&gt;&gt;N&gt;&gt;D;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)</span><br><span class="line"> cin&gt;&gt;cro[i].x&gt;&gt;cro[i].y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toJump();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="DFS" scheme="https://cjay.life/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>列出连通集</title>
    <link href="https://cjay.life/2020/06/21/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/"/>
    <id>https://cjay.life/2020/06/21/%E5%88%97%E5%87%BA%E8%BF%9E%E9%80%9A%E9%9B%86/</id>
    <published>2020-06-21T13:07:36.000Z</published>
    <updated>2020-06-28T15:30:28.257Z</updated>
    
    <content type="html"><![CDATA[<p>7-6 列出连通集 (25分)</p><p>给定一个有<em>N</em>个顶点和<em>E</em>条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到<em>N</em>−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出2个整数<em>N</em>(0&lt;<em>N</em>≤10)和<em>E</em>，分别是图的顶点数和边数。随后<em>E</em>行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>按照”{ <em>v</em>1 <em>v</em>2 … <em>v**k</em> }”的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">8 6</span><br><span class="line">0 7</span><br><span class="line">0 1</span><br><span class="line">2 0</span><br><span class="line">4 1</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; 0 1 4 2 7 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br><span class="line">&#123; 0 1 2 7 4 &#125;</span><br><span class="line">&#123; 3 5 &#125;</span><br><span class="line">&#123; 6 &#125;</span><br></pre></td></tr></table></figure><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int g[10][10];</span><br><span class="line">int visited[10];</span><br><span class="line">int n,m,t1,t2;</span><br><span class="line">void BFS(int v)&#123;</span><br><span class="line">int vt;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">q.push(v);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">vt &#x3D; q.front();</span><br><span class="line">q.pop();</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if((g[vt][i] &#x3D;&#x3D; 1) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">visited[i] &#x3D; 1;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int v)&#123;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if((g[v][i] &#x3D;&#x3D; 1) &amp;&amp; (visited[i] &#x3D;&#x3D; 0))&#123;</span><br><span class="line">DFS(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">for(int i &#x3D; 0;i&lt;m;i++)&#123;</span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br><span class="line">g[t1][t2] &#x3D; 1;</span><br><span class="line">g[t2][t1] &#x3D; 1;</span><br><span class="line">&#125; </span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if(visited[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">DFS(i);</span><br><span class="line">cout&lt;&lt;&quot;&#125;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)</span><br><span class="line">visited[i] &#x3D; 0;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">if(visited[i] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">BFS(i);</span><br><span class="line">cout&lt;&lt;&quot;&#125;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;7-6 列出连通集 (25分)&lt;/p&gt;
&lt;p&gt;给定一个有&lt;em&gt;N&lt;/em&gt;个顶点和&lt;em&gt;E&lt;/em&gt;条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到&lt;em&gt;N&lt;/em&gt;−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="BFS" scheme="https://cjay.life/tags/BFS/"/>
    
      <category term="DFS" scheme="https://cjay.life/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://cjay.life/2020/06/20/%E5%9B%BE/"/>
    <id>https://cjay.life/2020/06/20/%E5%9B%BE/</id>
    <published>2020-06-20T10:41:22.000Z</published>
    <updated>2020-06-28T15:37:46.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图定义"><a href="#图定义" class="headerlink" title="图定义"></a>图定义</h1><p>由V（Vertex）表示有限顶点集合和E（Edge）表示有限边的集合组成</p><p><strong><em>不考虑重边和自回路</em></strong></p><p><strong><em>V不能为空，E能为空</em></strong></p><p>图又可分为好几种类型，比如：</p><p>有向图与无向图</p><p>网络与非网络图（边是否有权重）</p><h1 id="在程序中表示一个图"><a href="#在程序中表示一个图" class="headerlink" title="在程序中表示一个图"></a>在程序中表示一个图</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><h3 id="无向图用一维矩阵代替二维矩阵"><a href="#无向图用一维矩阵代替二维矩阵" class="headerlink" title="无向图用一维矩阵代替二维矩阵"></a>无向图用一维矩阵代替二维矩阵</h3><p>假定G [N] [N] 矩阵，可以用一个长度为N(N+1)/2的一维矩阵A存储，则Gij在A中对应的下标是：<strong>i（i+1）/2+j</strong></p><h3 id="邻接矩阵的优势"><a href="#邻接矩阵的优势" class="headerlink" title="邻接矩阵的优势"></a>邻接矩阵的优势</h3><ol><li>直观，好理解</li><li>方便查找两个顶点之间是否存在边</li><li>方便查找一个顶点的邻接点（对于无向图，只需要查找一行，有向图要查找一行一列）</li><li>方便计算度</li></ol><h3 id="邻接矩阵的劣势"><a href="#邻接矩阵的劣势" class="headerlink" title="邻接矩阵的劣势"></a>邻接矩阵的劣势</h3><ol><li>对于稀疏图（点多边少）</li><li>若要统计图中边的数量，只能遍历完整个矩阵</li></ol><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>设置G[N]为指针数组，数组中每个单元都存放着一个链表（存放G[i]的临接点）</p><h3 id="邻接表的优势"><a href="#邻接表的优势" class="headerlink" title="邻接表的优势"></a>邻接表的优势</h3><ol><li>方便查找任一结点的所有“邻接点”</li><li>对于稀疏图节约空间：N个头指针+2E个结点（每个结点两个域）</li><li>对于无向图方便计算顶点的度</li></ol><h3 id="邻接表的劣势"><a href="#邻接表的劣势" class="headerlink" title="邻接表的劣势"></a>邻接表的劣势</h3><ol><li>对于边多点少的稠密图就不划算</li><li>对于有向图，只能计算出度；对于入度，需要构造逆邻接表（存指向自己的边）来方便计算入度</li><li>对于查找一对顶点间是否存在边很不方便</li></ol><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深搜（Depth-First-Search-DFS）"><a href="#深搜（Depth-First-Search-DFS）" class="headerlink" title="深搜（Depth First Search ,DFS）"></a>深搜（Depth First Search ,DFS）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void DFS(Vertex X)&#123;</span><br><span class="line">visited[X] &#x3D; true;</span><br><span class="line">for(V的每个临接点 W)</span><br><span class="line">if(visited[W] &#x3D;&#x3D; false)</span><br><span class="line">DFS(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若有N个顶点，E条边，时间复杂度</p><ul><li>邻接表，O（N+E）</li><li>邻接矩阵，O(N2)</li></ul><h2 id="广搜（Breadth-First-Search）"><a href="#广搜（Breadth-First-Search）" class="headerlink" title="广搜（Breadth First Search）"></a>广搜（Breadth First Search）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Void BFS(Vertex V)&#123;</span><br><span class="line">visited[V] &#x3D; true;</span><br><span class="line">Enqueue(V,Q);</span><br><span class="line">while(!IsEmpty(Q))&#123;</span><br><span class="line">V &#x3D; Dequeue(Q);</span><br><span class="line">for(V 的每个邻接点 W)</span><br><span class="line">if(!visited[w])&#123;</span><br><span class="line">visited[W] &#x3D; true;</span><br><span class="line">Enqueue(W,Q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若有N个顶点，E条边，时间复杂度</p><ul><li>邻接表，O（N+E）</li><li>邻接矩阵，O(N2)</li></ul><h1 id="图论的一些概念"><a href="#图论的一些概念" class="headerlink" title="图论的一些概念"></a>图论的一些概念</h1><p>连通 ：V到W存在一条路径，则称V和W是连通的</p><p>连通图: 图中任意两顶点均连通</p><p>连通分量： <strong><em>无向图</em></strong>的极大连通子图</p><p>​     极大顶点数</p><pre><code>极大边数</code></pre><p>强连通： <strong><em>有向图</em></strong>中顶点V和W之间存在双向路径</p><p>强连通图:  <strong><em>有向图</em></strong>中任意两顶点均强连通</p><p>强连通分量：有向图的极大连通子图</p><p>简单路径：V到W之间的所有顶点都不同</p><p>回路：起点等于终点的路径</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;图定义&quot;&gt;&lt;a href=&quot;#图定义&quot; class=&quot;headerlink&quot; title=&quot;图定义&quot;&gt;&lt;/a&gt;图定义&lt;/h1&gt;&lt;p&gt;由V（Vertex）表示有限顶点集合和E（Edge）表示有限边的集合组成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;不考虑重边和自回路&lt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="图" scheme="https://cjay.life/tags/%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>File Transfer</title>
    <link href="https://cjay.life/2020/06/19/File-Transfer/"/>
    <id>https://cjay.life/2020/06/19/File-Transfer/</id>
    <published>2020-06-19T09:23:10.000Z</published>
    <updated>2020-06-19T09:24:55.821Z</updated>
    
    <content type="html"><![CDATA[<p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains <em>N</em> (2≤<em>N</em>≤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and <em>N</em>. Then in the following lines, the input is given in the format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I c1 c2</span><br></pre></td></tr></table></figure><p>where <code>I</code> stands for inputting a connection between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C c1 c2</span><br></pre></td></tr></table></figure><p>where <code>C</code> stands for checking if it is possible to transfer files between <code>c1</code> and <code>c2</code>; or</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S</span><br></pre></td></tr></table></figure><p>where <code>S</code> stands for stopping this case.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each <code>C</code> case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between <code>c1</code> and <code>c2</code>, respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are <code>k</code> components.” where <code>k</code> is the number of connected components in this network.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">There are 2 components.</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">C 3 2</span><br><span class="line">I 3 2</span><br><span class="line">C 1 5</span><br><span class="line">I 4 5</span><br><span class="line">I 2 4</span><br><span class="line">C 3 5</span><br><span class="line">I 1 3</span><br><span class="line">C 1 5</span><br><span class="line">S</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">no</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">yes</span><br><span class="line">The network is connected.</span><br></pre></td></tr></table></figure><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">char c;</span><br><span class="line">int N;</span><br><span class="line">int pc[10005];</span><br><span class="line">int find(int a)&#123;</span><br><span class="line">if(pc[a]&lt;0) return a;</span><br><span class="line">else return pc[a] &#x3D; find(pc[a]);</span><br><span class="line">&#125;</span><br><span class="line">void input()&#123;</span><br><span class="line">int t1,t2;</span><br><span class="line">scanf(&quot;%d %d\n&quot;,&amp;t1,&amp;t2);</span><br><span class="line">int root1,root2;</span><br><span class="line">root1 &#x3D; find(t1);</span><br><span class="line">root2 &#x3D; find(t2);</span><br><span class="line">pc[root1] &#x3D; root2;</span><br><span class="line">&#125;</span><br><span class="line">void check()&#123;</span><br><span class="line">int t1,t2;</span><br><span class="line">scanf(&quot;%d %d\n&quot;,&amp;t1,&amp;t2);</span><br><span class="line">if(find(t1) &#x3D;&#x3D; find(t2)) cout&lt;&lt;&quot;yes\n&quot;;</span><br><span class="line">else cout&lt;&lt;&quot;no\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">void sum()&#123;</span><br><span class="line">int a &#x3D; 0;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">if(pc[i] &#x3D;&#x3D; -1) a++;</span><br><span class="line">if(a &#x3D;&#x3D; 1) cout&lt;&lt;&quot;The network is connected.\n&quot;;</span><br><span class="line">else printf(&quot;There are %d components.\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(&quot;%d\n&quot;,&amp;N);</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">pc[i] &#x3D; -1;</span><br><span class="line">do&#123;</span><br><span class="line">scanf(&quot;%c&quot;,&amp;c);</span><br><span class="line">switch(c)&#123;</span><br><span class="line">case &#39;I&#39;: input(); break;</span><br><span class="line">case &#39;C&#39;: check(); break;</span><br><span class="line">case &#39;S&#39;: sum(); break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;while(c!&#x3D;&#39;S&#39;); &#x2F;&#x2F;不要忘了；</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one comput
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="并查集" scheme="https://cjay.life/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>集合及运算</title>
    <link href="https://cjay.life/2020/06/19/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/"/>
    <id>https://cjay.life/2020/06/19/%E9%9B%86%E5%90%88%E5%8F%8A%E8%BF%90%E7%AE%97/</id>
    <published>2020-06-19T07:33:27.000Z</published>
    <updated>2020-06-19T09:03:14.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>定义：集合<strong><em>并，查</em></strong>某元素属于什么集合</p><p><em>双亲表示法：孩子指向双亲(与普通树的指针刚好相反)</em></p><h1 id="并查集存储"><a href="#并查集存储" class="headerlink" title="并查集存储"></a>并查集存储</h1><p>typedef struct{</p><p>​    ElementType Data;</p><p>​    int parent;</p><p>} SetType;</p><h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><h2 id="查找某个元素所在集合"><a href="#查找某个元素所在集合" class="headerlink" title="查找某个元素所在集合"></a>查找某个元素所在集合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int Find(SetType S[],ElementType X)&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i &#x3D; 0;i&lt;MaxSize &amp;&amp; S[i].data !&#x3D; X; i++);</span><br><span class="line">if(i &gt;&#x3D; MaxSize) return -1; &#x2F;&#x2F;未找到X，返回-1</span><br><span class="line">for(;S[i].parent &gt;&#x3D; 0; i &#x3D; S[i].Parent);</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合的并运算"><a href="#集合的并运算" class="headerlink" title="集合的并运算"></a>集合的并运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Union(SetType S[], ElementType X1, ElementType X2)&#123;</span><br><span class="line">int root1, root2;</span><br><span class="line">root1 &#x3D; Find(S,X1);</span><br><span class="line">root2 &#x3D; Find(S,X2);</span><br><span class="line">if(root1!&#x3D;root2) S[root2].parent &#x3D; Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>改写Find方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int Find(SetType S[], ElementType X)&#123;</span><br><span class="line">if(S[X]&lt;0)</span><br><span class="line">return x;</span><br><span class="line">else return S[X] &#x3D; Find(S,S[X]);&#x2F;&#x2F;尾递归不用担心爆内存，编译器编译时会优化成循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h1&gt;&lt;p&gt;定义：集合&lt;strong&gt;&lt;em&gt;并，查&lt;/em&gt;&lt;/strong&gt;某元素属于什么集合&lt;/p&gt;
&lt;p&gt;&lt;em&gt;双亲表示法：孩子指向双
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="并查集" scheme="https://cjay.life/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>哈夫曼树与哈夫曼编码</title>
    <link href="https://cjay.life/2020/06/18/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <id>https://cjay.life/2020/06/18/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</id>
    <published>2020-06-18T14:15:56.000Z</published>
    <updated>2020-06-18T14:44:47.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h1><p>哈夫曼树又称为最优二叉树，是WPL最小的二叉树</p><h1 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct TreeNode *HuffmanTree;</span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">int Weight;</span><br><span class="line">HuffmanTree Left,Right;</span><br><span class="line">&#125;</span><br><span class="line">HuffmanTree Huffman(MinHeap H)&#123;</span><br><span class="line">int i; HuffmanTree T;</span><br><span class="line">BuildMinHeap(H)&#x2F;&#x2F;调整为最小堆</span><br><span class="line">for(i &#x3D; 1;i&lt; H-&gt;Size;i++)&#123;&#x2F;&#x2F;做H-&gt;size-1次合并</span><br><span class="line">T &#x3D; malloc(sizeof(struct TreeNode));</span><br><span class="line">T-&gt;Left &#x3D; DeleteMin(H);</span><br><span class="line">T-&gt;Right &#x3D; DeleteMin(H);</span><br><span class="line">T-&gt;Weight &#x3D; T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;</span><br><span class="line">Insert(H,T);</span><br><span class="line">&#125;</span><br><span class="line">T &#x3D; DeleteMin(H);</span><br><span class="line">return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体复杂度NlogN。</p><h1 id="哈夫曼树特点"><a href="#哈夫曼树特点" class="headerlink" title="哈夫曼树特点"></a>哈夫曼树特点</h1><h2 id="没有度为1的节点"><a href="#没有度为1的节点" class="headerlink" title="没有度为1的节点"></a>没有度为1的节点</h2><h2 id="n个叶子结点的哈夫曼树共有2n-1个结点（n2-n0-1）"><a href="#n个叶子结点的哈夫曼树共有2n-1个结点（n2-n0-1）" class="headerlink" title="n个叶子结点的哈夫曼树共有2n-1个结点（n2 = n0-1）"></a>n个叶子结点的哈夫曼树共有2n-1个结点（n2 = n0-1）</h2><h2 id="任意非叶结点的左右子树交换仍是哈夫曼树"><a href="#任意非叶结点的左右子树交换仍是哈夫曼树" class="headerlink" title="任意非叶结点的左右子树交换仍是哈夫曼树"></a>任意非叶结点的左右子树交换仍是哈夫曼树</h2><h2 id="对于同一组权值，存在着不同构的两棵哈夫曼树-1-2-3-3"><a href="#对于同一组权值，存在着不同构的两棵哈夫曼树-1-2-3-3" class="headerlink" title="对于同一组权值，存在着不同构的两棵哈夫曼树({1,2,3,3})"></a>对于同一组权值，存在着不同构的两棵哈夫曼树({1,2,3,3})</h2><h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>不等长编码，且可以避免二义性。</p><p>就是一种前缀码（prefix code）: 任何字符的编码都不是另一字符编码的前缀</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈夫曼树定义&quot;&gt;&lt;a href=&quot;#哈夫曼树定义&quot; class=&quot;headerlink&quot; title=&quot;哈夫曼树定义&quot;&gt;&lt;/a&gt;哈夫曼树定义&lt;/h1&gt;&lt;p&gt;哈夫曼树又称为最优二叉树，是WPL最小的二叉树&lt;/p&gt;
&lt;h1 id=&quot;构建哈夫曼树&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="哈夫曼" scheme="https://cjay.life/tags/%E5%93%88%E5%A4%AB%E6%9B%BC/"/>
    
  </entry>
  
  <entry>
    <title>堆中的路径</title>
    <link href="https://cjay.life/2020/06/18/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <id>https://cjay.life/2020/06/18/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</id>
    <published>2020-06-18T10:46:13.000Z</published>
    <updated>2020-06-18T14:34:35.307Z</updated>
    
    <content type="html"><![CDATA[<p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>每组测试第1行包含2个正整数<em>N</em>和<em>M</em>(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的<em>N</em>个要被插入一个初始为空的小顶堆的整数。最后一行给出<em>M</em>个下标。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure><hr><p>一开始解这道题的时候思路是先将这N个数字存储下来，再从最后一个具有子节点的节点开始向下调整。</p><p>但是这样解错了。</p><h3 id="自己的解法（错误）"><a href="#自己的解法（错误）" class="headerlink" title="自己的解法（错误）"></a>自己的解法（错误）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N,M;</span><br><span class="line">int a[1005],b[1005];</span><br><span class="line">void ajust(int index)&#123;</span><br><span class="line">int parent;</span><br><span class="line">int child;</span><br><span class="line">int temp &#x3D; a[index];</span><br><span class="line">for(parent &#x3D; index; parent*2&lt;&#x3D;N;parent &#x3D; child)&#123;</span><br><span class="line">child &#x3D; 2*parent;</span><br><span class="line">if((child!&#x3D;N) &amp;&amp; (a[child]&gt;a[child+1]))</span><br><span class="line">child++;</span><br><span class="line">if(temp&lt;&#x3D;a[child]) break;</span><br><span class="line">else a[parent] &#x3D; a[child];</span><br><span class="line">&#125;</span><br><span class="line">a[parent] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void buildHeap()&#123;</span><br><span class="line">for(int i &#x3D; N&#x2F;2 ;i&gt;0;i--)&#123;</span><br><span class="line">ajust(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void printPath(int index)&#123;</span><br><span class="line">int flag &#x3D; 1;</span><br><span class="line">for(int i &#x3D; index;i&gt;0;i&#x3D;i&#x2F;2)&#123;</span><br><span class="line">if(flag)&#123;</span><br><span class="line">printf(&quot;%d&quot;,a[i]);</span><br><span class="line">flag &#x3D; 0;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot; %d&quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">a[0] &#x3D; -10001;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;N;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;M;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;b[i]);</span><br><span class="line">&#125;</span><br><span class="line">buildHeap();</span><br><span class="line">&#x2F;&#x2F;for(int i &#x3D; 1;i&lt;&#x3D;N;i++)</span><br><span class="line">&#x2F;&#x2F;cout&lt;&lt; a[i];</span><br><span class="line">for(int i &#x3D; 1;i&lt;&#x3D;M;i++)&#123;</span><br><span class="line">printPath(b[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正确的解法"><a href="#正确的解法" class="headerlink" title="正确的解法"></a>正确的解法</h3><p>该题目采用建立小顶堆的方式是逐个插入，逐个调整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,M;</span><br><span class="line">int a[1005];</span><br><span class="line">int size &#x3D; 0;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line">a[0] &#x3D; -10001;</span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">int temp;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">int j;</span><br><span class="line">for(j &#x3D; ++size;a[j&#x2F;2]&gt;temp;j &#x3D; j&#x2F;2)&#123;</span><br><span class="line">a[j] &#x3D; a[j&#x2F;2];</span><br><span class="line">&#125;</span><br><span class="line">a[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 0;i&lt;M;i++)&#123;</span><br><span class="line">int temp;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">cout&lt;&lt;a[temp];</span><br><span class="line">while(temp!&#x3D;1)&#123;</span><br><span class="line">temp &#x3D; temp&#x2F;2;</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;a[temp];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;\n&quot;; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，分别采用这两种方式构建小顶堆，结果是不一样的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;将一系列给定数字插入一个初始为空的小顶堆&lt;code&gt;H[]&lt;/code&gt;。随后对任意给定的下标&lt;code&gt;i&lt;/code&gt;，打印从&lt;code&gt;H[i]&lt;/code&gt;到根结点的路径。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="堆" scheme="https://cjay.life/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="https://cjay.life/2020/06/17/%E5%A0%86/"/>
    <id>https://cjay.life/2020/06/17/%E5%A0%86/</id>
    <published>2020-06-17T14:42:56.000Z</published>
    <updated>2020-06-18T14:34:44.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h1><p>优先队列（Priority Queue）: 取出元素的顺序按优先权大小，而不是元素进入队列的先后顺序。</p><p>若堆可以用二叉搜索树来实现，插入操作时间效率就是对数级，删除操作也是对数级，但如果不断删除最大或最小的，树会歪掉，树的高度就不再是对数级别了。</p><h1 id="堆的两个特性"><a href="#堆的两个特性" class="headerlink" title="堆的两个特性"></a>堆的两个特性</h1><p>结构性：用数组表示的完全二叉树。</p><p>有序性：任一节点的关键字是其子树所有结点的最大值（或最小值）</p><h1 id="堆的操作集"><a href="#堆的操作集" class="headerlink" title="堆的操作集"></a>堆的操作集</h1> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct HeapStruct *MaxHeap;</span><br><span class="line">struct HeapStruct&#123;</span><br><span class="line">ElementType *Elements;&#x2F;&#x2F; 存储堆元素的数组</span><br><span class="line">int Size;&#x2F;&#x2F;堆当前元素个数</span><br><span class="line">int Capacity;&#x2F;&#x2F;堆最大容量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MaxHeap Create(int MaxSize)&#123;</span><br><span class="line">MaxHeap H &#x3D; malloc(sizeof(struct HeapStruct));</span><br><span class="line">H-&gt;Elements &#x3D; malloc((MaxSize+1)*sizeof(ElementType));</span><br><span class="line">H-&gt;Size &#x3D; 0;</span><br><span class="line">H-&gt;Capacity &#x3D; MaxSize;</span><br><span class="line">H-&gt;Elements[0] &#x3D; MaxData;&#x2F;&#x2F;作为哨兵，便于以后更快操作</span><br><span class="line">return H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void Insert(MaxHeap H,ElementType item)&#123;</span><br><span class="line">int i;</span><br><span class="line">if(isFull(H))&#123;</span><br><span class="line">printf(&quot;最大堆已满&quot;)；</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">i &#x3D; ++H-&gt;Size;</span><br><span class="line">for(;H-&gt;Elements[i&#x2F;2] &lt; item; i&#x2F;&#x3D;2)</span><br><span class="line">H-&gt;Elements[i] &#x3D; H-&gt;Elements[i&#x2F;2];</span><br><span class="line">H-&gt;Elements[i] &#x3D; item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ElementType DeleteMax(MaxHeap H)&#123;</span><br><span class="line">&#x2F;&#x2F;取出键值最大的元素，并删除有一个节点</span><br><span class="line">int Parent,Child;</span><br><span class="line">ElementType MaxItem,temp;</span><br><span class="line">if(isEmpty(H))&#123;</span><br><span class="line">printf(&quot;最大堆已为空&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">MaxItem &#x3D; H-&gt;Elements[1];</span><br><span class="line">for(Parent &#x3D; 1; Parent*2&lt;&#x3D;H-&gt;Size; Parent &#x3D; Child)&#123;</span><br><span class="line">Child &#x3D; Parent * 2;</span><br><span class="line">if((Child!&#x3D; H-&gt;Size) &amp;&amp; (H-&gt;Element[Child]&lt;H-&gt;Element[Child+1]))</span><br><span class="line">Child++;</span><br><span class="line">if( temp &gt;&#x3D; H-&gt;Elements[Child]) break;</span><br><span class="line">else H-&gt;Elements[Parent] &#x3D; H-&gt;Elements[Child];</span><br><span class="line">&#125;    </span><br><span class="line">H-&gt;Elements[Parent] &#x3D; temp;</span><br><span class="line">return MaxItem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大堆的建立"><a href="#最大堆的建立" class="headerlink" title="最大堆的建立"></a>最大堆的建立</h2><p>将已经存在的N个元素按最大堆的要求放在一个一维数组中。</p><p>方法1：将N个元素一个个相继插入到一个初始为空的堆中去，时间代价为NlogN。</p><p>方法2：（1）将N个元素顺序存入，先满足完全二叉树的结构特性。（2）调节各节点位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void PercDown(MaxHeap H,int p)&#123;</span><br><span class="line">int Parent,Child;</span><br><span class="line">ElementType X;</span><br><span class="line">X &#x3D; H-&gt;Data[p];</span><br><span class="line">for(Parent &#x3D; p; Parent*2&lt;&#x3D;H-&gt;Size; Parent &#x3D; Child)&#123;</span><br><span class="line">Child &#x3D; Parent*2;</span><br><span class="line">if((Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]))</span><br><span class="line">Child++;</span><br><span class="line">if(X&gt;&#x3D;H-&gt;Data[Child]) break;</span><br><span class="line">else H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];</span><br><span class="line">&#125;</span><br><span class="line">H-&gt;Data[Parent] &#x3D; X;</span><br><span class="line">&#125;</span><br><span class="line">void BuildHeap(MaxHeap H)&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i &#x3D; H-&gt;Size&#x2F;2;i&gt;0;i--)</span><br><span class="line">PercDown(H,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是堆&quot;&gt;&lt;a href=&quot;#什么是堆&quot; class=&quot;headerlink&quot; title=&quot;什么是堆&quot;&gt;&lt;/a&gt;什么是堆&lt;/h1&gt;&lt;p&gt;优先队列（Priority Queue）: 取出元素的顺序按优先权大小，而不是元素进入队列的先后顺序。&lt;/p&gt;
&lt;p&gt;若堆可
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="堆" scheme="https://cjay.life/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>Root of AVL Tree</title>
    <link href="https://cjay.life/2020/06/08/Root-of-AVL-Tree/"/>
    <id>https://cjay.life/2020/06/08/Root-of-AVL-Tree/</id>
    <published>2020-06-08T14:22:41.000Z</published>
    <updated>2020-06-28T15:33:05.394Z</updated>
    
    <content type="html"><![CDATA[<p>1066 Root of AVL Tree (25分)</p><p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p><p><img src="https://images.ptausercontent.com/31" alt="img"> <img src="https://images.ptausercontent.com/32" alt="img"></p><p><img src="https://images.ptausercontent.com/33" alt="img"> <img src="https://images.ptausercontent.com/34" alt="img"></p><p>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤20) which is the total number of keys to be inserted. Then <em>N</em> distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the root of the resulting AVL tree in one line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N;</span><br><span class="line">struct Node&#123;</span><br><span class="line">Node* l;</span><br><span class="line">Node* r;</span><br><span class="line">int data;</span><br><span class="line">int height;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int getHeight(Node* root)&#123;</span><br><span class="line">if(!root) return 0;</span><br><span class="line">return root-&gt;height; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void updateHeight(Node* root)&#123;</span><br><span class="line">root-&gt;height &#x3D; max(getHeight(root-&gt;l),getHeight(root-&gt;r))+1; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void R(Node* &amp;root)&#123;</span><br><span class="line">Node* temp &#x3D; root-&gt;l;</span><br><span class="line">root-&gt;l &#x3D; root-&gt;l-&gt;r;</span><br><span class="line">temp-&gt;r &#x3D; root;</span><br><span class="line">updateHeight(root);</span><br><span class="line">updateHeight(temp);</span><br><span class="line">root &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void L(Node* &amp;root)&#123;</span><br><span class="line">Node* temp &#x3D; root-&gt;r;</span><br><span class="line">root-&gt;r &#x3D; root-&gt;r-&gt;l;</span><br><span class="line">temp-&gt;l &#x3D; root;</span><br><span class="line">updateHeight(root);</span><br><span class="line">updateHeight(temp);</span><br><span class="line">root &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">Node* newNode(int t)&#123;</span><br><span class="line">Node* node &#x3D; new Node();</span><br><span class="line">node-&gt;l &#x3D; node-&gt;r &#x3D; NULL;</span><br><span class="line">node-&gt;data &#x3D; t;</span><br><span class="line">node-&gt;height &#x3D; 1;</span><br><span class="line">return node; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int getBalanceFactor(Node* root)&#123;</span><br><span class="line">return getHeight(root-&gt;l) - getHeight(root-&gt;r);</span><br><span class="line">&#125; </span><br><span class="line">void insert(int t,Node* &amp;node)&#123;</span><br><span class="line">if(!node)&#123;</span><br><span class="line">node &#x3D; newNode(t);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(node-&gt;data&lt;t)&#123;</span><br><span class="line">insert(t,node-&gt;r);</span><br><span class="line">updateHeight(node);</span><br><span class="line">if(getBalanceFactor(node) &#x3D;&#x3D; -2)&#123;</span><br><span class="line">if(getBalanceFactor(node-&gt;r) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">L(node);</span><br><span class="line">&#125;else if(getBalanceFactor(node-&gt;r) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">R(node-&gt;r);</span><br><span class="line">L(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">insert(t,node-&gt;l);</span><br><span class="line">updateHeight(node);</span><br><span class="line">if(getBalanceFactor(node) &#x3D;&#x3D; 2)&#123;</span><br><span class="line">if(getBalanceFactor(node-&gt;l) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">R(node);</span><br><span class="line">&#125;else if(getBalanceFactor(node-&gt;l) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">L(node-&gt;l);</span><br><span class="line">R(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;N;</span><br><span class="line">Node* node &#x3D; NULL; </span><br><span class="line">for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">int temp &#x3D; 0;</span><br><span class="line">cin&gt;&gt;temp;</span><br><span class="line">insert(temp,node);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;node-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1066 Root of AVL Tree (25分)&lt;/p&gt;
&lt;p&gt;An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>是否同一棵二叉搜索树</title>
    <link href="https://cjay.life/2020/06/08/%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://cjay.life/2020/06/08/%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2020-06-08T14:17:19.000Z</published>
    <updated>2020-06-28T15:27:04.234Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数<em>N</em> (≤10)和<em>L</em>，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出<em>N</em>个以空格分隔的正整数，作为初始插入序列。最后<em>L</em>行，每行给出<em>N</em>个插入的元素，属于<em>L</em>个需要检查的序列。</p><p>简单起见，我们保证每个插入序列都是1到<em>N</em>的一个排列。当读到<em>N</em>为0时，标志输入结束，这组数据不要处理。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int N,L;</span><br><span class="line">struct node&#123;</span><br><span class="line">int v;</span><br><span class="line">node* l;</span><br><span class="line">node* r;</span><br><span class="line">int flag;</span><br><span class="line">&#125;;</span><br><span class="line">node* addNode(int value,node* root)&#123;</span><br><span class="line">if(!root)&#123;</span><br><span class="line">node* temp &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">temp-&gt;l &#x3D; NULL;</span><br><span class="line">temp-&gt;r &#x3D; NULL;</span><br><span class="line">temp-&gt;v &#x3D; value;</span><br><span class="line">temp-&gt;flag &#x3D; 0;</span><br><span class="line">return temp;</span><br><span class="line">&#125; </span><br><span class="line">if(value&lt;root-&gt;v) root-&gt;l &#x3D; addNode(value,root-&gt;l);</span><br><span class="line">else root-&gt;r &#x3D; addNode(value,root-&gt;r);</span><br><span class="line">return root; </span><br><span class="line">&#125;</span><br><span class="line">int check(node* root,int temp)&#123;</span><br><span class="line">if(!root) return 0;</span><br><span class="line">if((root-&gt;flag &#x3D;&#x3D; 0)&amp;&amp;(root-&gt;v!&#x3D;temp)) return 0;</span><br><span class="line">if((root-&gt;flag &#x3D;&#x3D; 0)&amp;&amp;(root-&gt;v&#x3D;&#x3D;temp))&#123;</span><br><span class="line">root-&gt;flag &#x3D; 1;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">if((root-&gt;flag &#x3D;&#x3D; 1)&amp;&amp;(root-&gt;v!&#x3D;temp))&#123;</span><br><span class="line">if(root-&gt;v&gt;temp) return check(root-&gt;l,temp);</span><br><span class="line">else return check(root-&gt;r,temp);</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">void reset(node* root)&#123;</span><br><span class="line">if(!root) return;</span><br><span class="line">root-&gt;flag &#x3D; 0;</span><br><span class="line">reset(root-&gt;l);</span><br><span class="line">reset(root-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line"> while(true)&#123;</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line"> if(N&#x3D;&#x3D;0) break;</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;L);</span><br><span class="line"> node* root &#x3D; NULL; </span><br><span class="line"> for(int i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line"> int temp;</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line"> root &#x3D; addNode(temp,root);</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;0;i&lt;L;i++)&#123;</span><br><span class="line">int temp,flag &#x3D; 1,flag2 &#x3D; 1;</span><br><span class="line">for(int j &#x3D; 0;j&lt;N;j++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;temp);</span><br><span class="line">flag &#x3D; check(root,temp);</span><br><span class="line">if((flag &#x3D;&#x3D; 0)&amp;&amp;(flag2 &#x3D;&#x3D; 1))&#123;</span><br><span class="line">cout&lt;&lt;&quot;No\n&quot;;</span><br><span class="line">flag &#x3D; 0;</span><br><span class="line">flag2 &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag2 &#x3D;&#x3D; 1) cout&lt;&lt;&quot;Yes\n&quot;;</span><br><span class="line">reset(root);</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。&lt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉搜索树" scheme="https://cjay.life/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树的操作集</title>
    <link href="https://cjay.life/2020/06/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86/"/>
    <id>https://cjay.life/2020/06/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9B%86/</id>
    <published>2020-06-08T14:16:13.000Z</published>
    <updated>2020-06-09T10:44:30.961Z</updated>
    
    <content type="html"><![CDATA[<p>6-12 二叉搜索树的操作集 (30分)</p><p>本题要求实现给定二叉搜索树的5种常用操作。</p><h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>BinTree</code>结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li><li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li><li>函数<code>Find</code>在二叉搜索树<code>BST</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li><li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li><li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li></ul><h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">( BinTree BT )</span></span>; <span class="comment">/* 先序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">( BinTree BT )</span></span>;  <span class="comment">/* 中序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="keyword">int</span> N, i;</span><br><span class="line"></span><br><span class="line">    BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        BST = Insert(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Preorder:"</span>); PreorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    MinP = FindMin(BST);</span><br><span class="line">    MaxP = FindMax(BST);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        Tmp = Find(BST, X);</span><br><span class="line">        <span class="keyword">if</span> (Tmp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">"%d is not found\n"</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d is found\n"</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MinP) <span class="built_in">printf</span>(<span class="string">"%d is the smallest key\n"</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MaxP) <span class="built_in">printf</span>(<span class="string">"%d is the largest key\n"</span>, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        BST = Delete(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Inorder:"</span>); InorderTraversal(BST); <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">5 8 6 2 4 1 0 10 9 7</span><br><span class="line">5</span><br><span class="line">6 3 10 0 5</span><br><span class="line">5</span><br><span class="line">5 7 0 10 3</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Preorder: 5 2 1 0 4 8 6 7 10 9</span><br><span class="line">6 is found</span><br><span class="line">3 is not found</span><br><span class="line">10 is found</span><br><span class="line">10 is the largest key</span><br><span class="line">0 is found</span><br><span class="line">0 is the smallest key</span><br><span class="line">5 is found</span><br><span class="line">Not Found</span><br><span class="line">Inorder: 1 2 4 6 8 9</span><br></pre></td></tr></table></figure><h3 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">BinTree Insert( BinTree BST, ElementType X )&#123;</span><br><span class="line">if(!BST)&#123;</span><br><span class="line">BST &#x3D; (BinTree)malloc(sizeof(struct TNode));</span><br><span class="line">BST-&gt;Data &#x3D; X;</span><br><span class="line">BST-&gt;Left &#x3D; NULL;</span><br><span class="line">BST-&gt;Right &#x3D; NULL;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(X&lt;BST-&gt;Data) BST-&gt;Left &#x3D; Insert(BST-&gt;Left,X); &#x2F;&#x2F;插入操作需要先找到插入位置，但函数一到达插入位置， </span><br><span class="line">else BST-&gt;Right &#x3D; Insert(BST-&gt;Right,X);&#x2F;&#x2F;就无法记住父亲节点位置，所以采用递归方式，返回插入位置的地址给上一层。 </span><br><span class="line">&#125;</span><br><span class="line">return BST;</span><br><span class="line">&#125;</span><br><span class="line">Position Find( BinTree BST, ElementType X )&#123;</span><br><span class="line">if(!BST)&#123;</span><br><span class="line">return BST;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(BST-&gt;Data &#x3D;&#x3D; X) return BST;</span><br><span class="line">else if(BST-&gt;Data &lt; X) Find(BST-&gt;Right,X);</span><br><span class="line">else Find(BST-&gt;Left,X);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Position FindMin( BinTree BST )&#123;</span><br><span class="line">if(!BST) return BST;</span><br><span class="line">if(!BST-&gt;Left) return BST;</span><br><span class="line">else FindMin(BST-&gt;Left);</span><br><span class="line">&#125;</span><br><span class="line">Position FindMax( BinTree BST )&#123;</span><br><span class="line">if(!BST) return BST;</span><br><span class="line">if(!BST-&gt;Right) return BST;</span><br><span class="line">else FindMax(BST-&gt;Right);</span><br><span class="line">&#125;</span><br><span class="line">BinTree Delete( BinTree BST, ElementType X )&#123;</span><br><span class="line">if(!BST)&#123;</span><br><span class="line">printf(&quot;Not Found\n&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(BST-&gt;Data &lt; X)&#123;</span><br><span class="line">BST-&gt;Right &#x3D; Delete(BST-&gt;Right,X);</span><br><span class="line">&#125;else if(BST-&gt;Data &gt; X)&#123;</span><br><span class="line">BST-&gt;Left &#x3D; Delete(BST-&gt;Left,X);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">BinTree temp &#x3D; BST;</span><br><span class="line">if(!BST-&gt;Left)&#123;</span><br><span class="line">BST &#x3D; BST-&gt;Right;</span><br><span class="line">free(temp);</span><br><span class="line">&#125;else if(!BST-&gt;Right)&#123;</span><br><span class="line">BST &#x3D; BST-&gt;Left;</span><br><span class="line">free(temp);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">temp &#x3D; FindMin(BST-&gt;Right);</span><br><span class="line">BST-&gt;Data &#x3D; temp-&gt;Data;</span><br><span class="line">BST-&gt;Right &#x3D; Delete(BST-&gt;Right,BST-&gt;Data);</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"> return BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;6-12 二叉搜索树的操作集 (30分)&lt;/p&gt;
&lt;p&gt;本题要求实现给定二叉搜索树的5种常用操作。&lt;/p&gt;
&lt;h3 id=&quot;函数接口定义：&quot;&gt;&lt;a href=&quot;#函数接口定义：&quot; class=&quot;headerlink&quot; title=&quot;函数接口定义：&quot;&gt;&lt;/a&gt;函数接口定义：&lt;
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="二叉搜索树" scheme="https://cjay.life/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="https://cjay.life/2020/06/07/AVL%E6%A0%91/"/>
    <id>https://cjay.life/2020/06/07/AVL%E6%A0%91/</id>
    <published>2020-06-07T07:23:40.000Z</published>
    <updated>2020-06-07T08:24:11.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​    AVL树是一种特殊的二叉查找树，但对AVL树来说，左子树和右子树的高度差的绝对值不超过1，高度之差被称为<strong><em>平衡因子</em></strong>。</p><p>​    AVL树能使每次插入元素后树高度仍能保持O（logn）的级别（也就是查找时间也为O(logn)）</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void search(node* root,int x)&#123;</span><br><span class="line">if(root &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">printf(&quot;search failed\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">if(x &#x3D;&#x3D; root-&gt;data)&#123;</span><br><span class="line">printf(&quot;success&quot;);</span><br><span class="line">&#125;else if(x &lt; root-&gt;data)&#123;</span><br><span class="line">search(root-&gt;left,x)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">search(root-&gt;right,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void L(node* &amp;root)&#123;</span><br><span class="line">node* temp &#x3D; root-&gt;rchild;</span><br><span class="line">root-&gt;rchild &#x3D; temp-&gt;lchild;</span><br><span class="line">temp-&gt;lchild &#x3D; root;</span><br><span class="line">root &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void R(node* &amp;root)&#123;</span><br><span class="line">node* temp &#x3D; root-&gt;lchild;</span><br><span class="line">root-&gt;lchild &#x3D; temp-&gt;rchild;</span><br><span class="line">tmep-&gt;rchild &#x3D; root;</span><br><span class="line">root &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LL型旋转"><a href="#LL型旋转" class="headerlink" title="LL型旋转"></a>LL型旋转</h3><p><a href="/1.png">LL</a></p><p>4,6看成整体，以1为根右旋</p><h3 id="LR型旋转"><a href="#LR型旋转" class="headerlink" title="LR型旋转"></a>LR型旋转</h3><p><a href="/2.png">LR</a></p><p>先以2为根左旋，旋转结束后变为LL型，再以1节点为跟右旋。</p><h3 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">int v,height;</span><br><span class="line">node* lchild,node* rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node* newNode(int v)&#123;</span><br><span class="line">node* Node &#x3D; new node;</span><br><span class="line">Node-&gt;v &#x3D; v;</span><br><span class="line">Node-&gt;height &#x3D; 1;</span><br><span class="line">Node-&gt;lchild &#x3D; Node-&gt;rchild &#x3D; NULL;</span><br><span class="line">return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getHeight(node* root)&#123;</span><br><span class="line">if(root &#x3D;&#x3D; NULL) return 0;</span><br><span class="line">return root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getBalanceFactor(node* root)&#123;</span><br><span class="line">return getHeight(root-&gt;lchild)-getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void updateHeight(node* root)&#123;</span><br><span class="line">root-&gt;hegith &#x3D; max(getHeight(root-&gt;lchild),getHeight(root-&gt;rchild))+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void insert(node* &amp;root,int v)&#123;</span><br><span class="line">if(root &#x3D;&#x3D; NULL)&#123;</span><br><span class="line">root &#x3D; newNode(v);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(v&lt;root-&gt;v)&#123;</span><br><span class="line">insert(root-&gt;lchild,v);</span><br><span class="line">uodateHeight(root);</span><br><span class="line">if(getBalanceFactor(root) &#x3D;&#x3D; 2)&#123;</span><br><span class="line">if(getBalanceFactor(root-&gt;lchild) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">R(root);</span><br><span class="line">&#125;else if(getBalanceFactor(root-&gt;lchild) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">L(root-&gt;lchild);</span><br><span class="line">R(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">insert(root-&gt;child,v);</span><br><span class="line">updateHeight(root);</span><br><span class="line">if(getBalanceFactor(root) &#x3D;&#x3D; -2)&#123;</span><br><span class="line">if(getBalanceFactor(root) &#x3D;&#x3D; -1)&#123;</span><br><span class="line">L(root);</span><br><span class="line">&#125;else if(getBalanceFactor(root-&gt;rchild) &#x3D;&#x3D; 1)&#123;</span><br><span class="line">R(root-&gt;rchild);</span><br><span class="line">L(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVL树的建立"><a href="#AVL树的建立" class="headerlink" title="AVL树的建立"></a>AVL树的建立</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node* Create(int data[],int n)&#123;</span><br><span class="line">node* root &#x3D; NULL;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">insert(root,data[i]);</span><br><span class="line">&#125;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;​    AVL树是一种特殊的二叉查找树，但对AVL树来说，左子树和右子树的高度差的绝对值不超过1，高度之差被称为&lt;strong&gt;&lt;em&gt;平
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="AVL树" scheme="https://cjay.life/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>List Leaves</title>
    <link href="https://cjay.life/2020/06/02/List-Leaves/"/>
    <id>https://cjay.life/2020/06/02/List-Leaves/</id>
    <published>2020-06-02T10:58:23.000Z</published>
    <updated>2020-06-02T11:01:55.537Z</updated>
    
    <content type="html"><![CDATA[<p>Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to <em>N</em>−1. Then <em>N</em> lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 -</span><br><span class="line">- -</span><br><span class="line">0 -</span><br><span class="line">2 7</span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line">5 -</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 1 5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int b,c;</span><br><span class="line">&#125;;</span><br><span class="line">node n[12];</span><br><span class="line">int check[12];</span><br><span class="line">int find(node n[])&#123;</span><br><span class="line">int N,i;</span><br><span class="line">char l,r;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;N);</span><br><span class="line">getchar();</span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)&#123;</span><br><span class="line">scanf(&quot;%c %c&quot;,&amp;l,&amp;r);</span><br><span class="line">getchar();</span><br><span class="line">if(l!&#x3D;&#39;-&#39;)&#123;</span><br><span class="line">n[i].b &#x3D; l-&#39;0&#39;;</span><br><span class="line">check[n[i].b] &#x3D; 1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">n[i].b &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line">if(r!&#x3D;&#39;-&#39;)&#123;</span><br><span class="line">n[i].c &#x3D; r-&#39;0&#39;;</span><br><span class="line">check[n[i].c] &#x3D; 1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">n[i].c &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">for(i &#x3D; 0;i&lt;N;i++)</span><br><span class="line">if(check[i] &#x3D;&#x3D; 0)</span><br><span class="line">break;</span><br><span class="line">return i;</span><br><span class="line">&#125; </span><br><span class="line">int flag &#x3D; 0;</span><br><span class="line">void print(int root)&#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">int flag &#x3D; 0;</span><br><span class="line">if(root!&#x3D;-1)&#123;</span><br><span class="line">q.push(root);</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">int top &#x3D; q.front();</span><br><span class="line">q.pop();</span><br><span class="line">if((n[top].b &#x3D;&#x3D; -1)&amp;&amp;(n[top].c &#x3D;&#x3D; -1))&#123;</span><br><span class="line">if(flag)</span><br><span class="line">printf(&quot; %d&quot;,top);</span><br><span class="line">else&#123;</span><br><span class="line">printf(&quot;%d&quot;,top);</span><br><span class="line">flag &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(n[top].b!&#x3D;-1)</span><br><span class="line">q.push(n[top].b);</span><br><span class="line">if(n[top].c!&#x3D;-1)</span><br><span class="line">q.push(n[top].c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int root &#x3D; find(n); </span><br><span class="line">print(root);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.&lt;/p&gt;
&lt;h3 id=&quot;Input-Specification&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="树" scheme="https://cjay.life/tags/%E6%A0%91/"/>
    
      <category term="层级遍历" scheme="https://cjay.life/tags/%E5%B1%82%E7%BA%A7%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Pop Sequence</title>
    <link href="https://cjay.life/2020/05/28/Pop-Sequence/"/>
    <id>https://cjay.life/2020/05/28/Pop-Sequence/</id>
    <published>2020-05-28T10:58:13.000Z</published>
    <updated>2020-05-28T14:03:18.658Z</updated>
    
    <content type="html"><![CDATA[<p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805427332562944" target="_blank" rel="noopener">链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int M,N,K;</span><br><span class="line">int main()&#123;</span><br><span class="line">cin&gt;&gt;M&gt;&gt;N&gt;&gt;K;</span><br><span class="line">vector&lt;int&gt; v(N+1);</span><br><span class="line">while(K--)&#123;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">for(int i &#x3D; 1;i &lt;&#x3D; N;i++)</span><br><span class="line">cin&gt;&gt;v[i];</span><br><span class="line">int current &#x3D; 1;</span><br><span class="line">for(int i &#x3D; 1;i &lt;&#x3D; N;i++)&#123;</span><br><span class="line">s.push(i);</span><br><span class="line">if(s.size()&gt;M) break;</span><br><span class="line">while(!s.empty()&amp;&amp;s.top()&#x3D;&#x3D;v[current])&#123;</span><br><span class="line">s.pop();</span><br><span class="line">current++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(current &#x3D;&#x3D; N+1) cout&lt;&lt;&quot;YES\n&quot;;</span><br><span class="line">else cout&lt;&lt;&quot;NO\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>current确定当前扫描到第几个位置。</p><p>栈只需要从1顺序进，每进一个就while循环，判断栈顶和current当前位置，只要对上了，current往后走，栈不停弹出。</p><p>判断成功的方法：current最后到了N+1，也就是前面都通过检验。</p><p>这里就相当于一个证明题：对于一个命题，错与对哪个好证明，就证明哪个，最后用反证法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a stack which can keep &lt;em&gt;M&lt;/em&gt; numbers at most. Push &lt;em&gt;N&lt;/em&gt; numbers in the order of 1, 2, 3, …, &lt;em&gt;N&lt;/em&gt; and pop randomly.
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="https://cjay.life/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Reversing Linked List</title>
    <link href="https://cjay.life/2020/05/28/Reversing-Linked-List/"/>
    <id>https://cjay.life/2020/05/28/Reversing-Linked-List/</id>
    <published>2020-05-28T10:57:58.000Z</published>
    <updated>2020-05-28T13:58:06.125Z</updated>
    
    <content type="html"><![CDATA[<p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p><p>Then <em>N</em> lines follow, each describes a node in the format:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure><p><a href="https://pintia.cn/problem-sets/1211841066264109056/problems/1231458941036285954" target="_blank" rel="noopener">链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int temp,data[100005],nex[100005],lis[100005],ans[100005];</span><br><span class="line">int main()&#123;</span><br><span class="line">int first,k,n,sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;first&gt;&gt;n&gt;&gt;k;</span><br><span class="line">for(int i &#x3D; 0;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;temp;</span><br><span class="line">cin&gt;&gt;data[temp]&gt;&gt;nex[temp];</span><br><span class="line">&#125;</span><br><span class="line">while(first!&#x3D;-1)&#123;</span><br><span class="line">lis[sum++] &#x3D; first;</span><br><span class="line">first &#x3D; nex[first];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 0;i&lt;sum;i++) ans[i] &#x3D; lis[i];</span><br><span class="line">for(int i &#x3D; 0;i&lt;(sum-sum%k);i++)&#123;&#x2F;&#x2F;反转范围为前k的整数倍,后面剩余部分不动</span><br><span class="line">ans[i] &#x3D; lis[i&#x2F;k*k+k-1-i%k];&#x2F;&#x2F;i&#x2F;k*k确定第几组反转的起步位置，k-1-i%k控制组内的顺序移动</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 0;i&lt;sum-1;i++)</span><br><span class="line">printf(&quot;%05d %d %05d\n&quot;,ans[i],data[ans[i]],ans[i+1]);</span><br><span class="line">printf(&quot;%05d %d -1\n&quot;,ans[sum-1],data[ans[sum-1]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用数组模拟链表</p><p>对于节点元素：value,next；</p><p>分别用两个数组模拟,数组下标为节点地址，只要有节点地址，就能通过访问两个数组获取相应的值；</p><p>对于翻转，只要关注节点排列的顺序就行了。</p><p>lis数组存储链表上节点的顺序依次地址。</p><p>ans来存储lis按照一定k值重写排列的地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given a constant &lt;em&gt;K&lt;/em&gt; and a singly linked list &lt;em&gt;L&lt;/em&gt;, you are supposed to reverse the links of every &lt;em&gt;K&lt;/em&gt; elements on &lt;e
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://cjay.life/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>一元多项式的乘法与加法运算</title>
    <link href="https://cjay.life/2020/05/28/%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/"/>
    <id>https://cjay.life/2020/05/28/%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E4%B9%98%E6%B3%95%E4%B8%8E%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97/</id>
    <published>2020-05-28T10:57:40.000Z</published>
    <updated>2020-05-28T13:48:40.574Z</updated>
    
    <content type="html"><![CDATA[<p>设计函数分别求两个一元多项式的乘积与和。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure><p><a href="https://pintia.cn/problem-sets/434/problems/5865" target="_blank" rel="noopener">链接</a></p><p>解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">int co;</span><br><span class="line">int ex;</span><br><span class="line">node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void attach(node** rear,int a,int b)&#123;</span><br><span class="line">node* temp &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">temp-&gt;co &#x3D; a;</span><br><span class="line">temp-&gt;ex &#x3D; b;</span><br><span class="line">temp-&gt;next &#x3D; NULL;</span><br><span class="line">(*rear)-&gt;next &#x3D; temp;</span><br><span class="line">(*rear) &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">node* read()&#123;</span><br><span class="line">int c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">node* p &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">p-&gt;next &#x3D; NULL;</span><br><span class="line">node* rear &#x3D; p;</span><br><span class="line">while(c--)&#123;</span><br><span class="line">int a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">attach(&amp;rear,a,b);</span><br><span class="line">&#125;</span><br><span class="line">node* t &#x3D; p-&gt;next;</span><br><span class="line">free(p);</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">node* plu(node* a,node* b)&#123;</span><br><span class="line">node* p &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">node* rear &#x3D; p;</span><br><span class="line">p-&gt;next &#x3D; NULL;</span><br><span class="line">while(a&amp;&amp;b)&#123;</span><br><span class="line">if(a-&gt;ex&gt;b-&gt;ex)&#123;</span><br><span class="line">attach(&amp;rear,a-&gt;co,a-&gt;ex);</span><br><span class="line">a &#x3D; a-&gt;next;</span><br><span class="line">&#125;else if(a-&gt;ex&lt;b-&gt;ex)&#123;</span><br><span class="line">attach(&amp;rear,b-&gt;co,b-&gt;ex);</span><br><span class="line">b &#x3D; b-&gt;next;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">if(a-&gt;co+b-&gt;co !&#x3D; 0)&#123;</span><br><span class="line">attach(&amp;rear,a-&gt;co+b-&gt;co,a-&gt;ex);</span><br><span class="line">&#125; </span><br><span class="line">a &#x3D; a-&gt;next;</span><br><span class="line">b &#x3D; b-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">while(a)&#123;</span><br><span class="line">attach(&amp;rear,a-&gt;co,a-&gt;ex);</span><br><span class="line">a &#x3D; a-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">while(b)&#123;</span><br><span class="line">attach(&amp;rear,b-&gt;co,b-&gt;ex);</span><br><span class="line">b &#x3D; b-&gt;next; </span><br><span class="line">&#125; </span><br><span class="line">node* t &#x3D; p-&gt;next;</span><br><span class="line">free(p);</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">void print(node* a)&#123;</span><br><span class="line">if(!a) printf(&quot;0 0&quot;);</span><br><span class="line">else&#123;</span><br><span class="line">bool flag &#x3D; false;</span><br><span class="line">while(a)&#123;</span><br><span class="line">if(!flag)&#123;</span><br><span class="line">cout&lt;&lt;a-&gt;co&lt;&lt;&quot; &quot;&lt;&lt;a-&gt;ex;</span><br><span class="line">flag &#x3D; true;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">cout&lt;&lt;&quot; &quot;&lt;&lt;a-&gt;co&lt;&lt;&quot; &quot;&lt;&lt;a-&gt;ex;</span><br><span class="line">&#125;</span><br><span class="line">a &#x3D; a-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">node* muti(node* a,node* b)&#123;</span><br><span class="line">node* p &#x3D; NULL;</span><br><span class="line">if(!a||!b) return NULL;</span><br><span class="line">while(a)&#123;</span><br><span class="line">node* temp &#x3D; (node*)malloc(sizeof(node));</span><br><span class="line">temp-&gt;next &#x3D; NULL;</span><br><span class="line">node* bp &#x3D; b;</span><br><span class="line">node* rear &#x3D; temp; </span><br><span class="line">while(bp)&#123;</span><br><span class="line">attach(&amp;rear,a-&gt;co*bp-&gt;co,a-&gt;ex+bp-&gt;ex);</span><br><span class="line">bp &#x3D; bp-&gt;next;</span><br><span class="line">&#125; </span><br><span class="line">node* t &#x3D; temp-&gt;next;</span><br><span class="line">free(temp);</span><br><span class="line">p &#x3D; plu(p,t);</span><br><span class="line">a &#x3D; a-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">node* a &#x3D; read();</span><br><span class="line">node* b &#x3D; read();</span><br><span class="line">node* c &#x3D; muti(a,b);</span><br><span class="line">print(c);</span><br><span class="line">cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">c &#x3D; plu(a,b);</span><br><span class="line">print(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、在用malloc创建节点时，不要忘了对里面的指针初始化。</p><p>2、attach函数参数为node**，这是指针的指针，目的是更改指向节点的指针的值（需要不断更改rear的位置）</p><p>node** a（b的内存地址）</p><p>-&gt;node* b(c的内存地址)</p><p>-&gt;node c</p><p>更改c的属性值： b-&gt;value = xxx;（*a）-&gt;value = xxx;</p><p>更改b的值： (*a) = xxx;</p><p>3、注意代码的可重用性，这里的乘法就可以用到加法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设计函数分别求两个一元多项式的乘积与和。&lt;/p&gt;
&lt;h3 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式:&quot;&gt;&lt;/a&gt;输入格式:&lt;/h3&gt;&lt;p&gt;输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输
      
    
    </summary>
    
    
      <category term="算法与数据结构" scheme="https://cjay.life/categories/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="线性表" scheme="https://cjay.life/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
</feed>
